<!doctype html>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="noindex">
<title>SÄÄ SEURAAVAT 12 h</title>
<style>
  :root { color-scheme: dark; }
  html,body{height:100%}
  body{
    margin:0; padding:28px 14px 24px; background:#000; color:#e8e8e8;
    font:17px/1.5 Arial,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility
  }
  .mini{ color:#5d676f; font-size:12px; letter-spacing:.3px }
  .caps{ text-transform:uppercase; letter-spacing:.5px }
  .list{ border-top:1px solid #2a2a2a; margin-top:6px; }

  /* Grid: [time | temp | desc | rain | wind] */
  .klohdr{
    color:#5d676f; font-size:12px; letter-spacing:.3px; margin:6px 0 4px 0;
    display:grid; grid-template-columns:54px 64px 1fr 70px 64px; align-items:end;
  }
  .klohdr > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px; }
  .klohdr > div:nth-child(2), .klohdr > div:nth-child(3){ visibility:hidden } /* ei otsikoita näille */

  .row{
    display:grid; grid-template-columns:54px 64px 1fr 70px 64px;
    gap:8px; padding:6px 0; border-bottom:1px solid #1c1c1c; align-items:center;
  }
  .row > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px; }

  .muted{ color:#515a62 } .soft{ color:#515a62 }
  .t{ text-align:left } .t.hh{ text-align:right }

  .desc .ditto{ display:inline } .ditto{ color:inherit } /* pelkkä » */
  .dash{ text-align:center } /* sateettomuusviivojen keskitys */

  .err{ color:#ff6b6b; white-space:pre-wrap }
</style>

<!-- Otsakerivi: (tyhjä time header) | ( ) | ( ) | SADE | TUULI -->
<div class="klohdr">
  <div></div><div></div><div></div>
  <div class="caps">SADE</div>
  <div class="caps">TUULI</div>
</div>
<div class="list" id="out" aria-live="polite"></div>

<script>
/* Lähteet:
   - t0–t2: Sade MET Nowcast 2.0 (/complete). t0 lämpö & tuuli FMI-havainnoista (t2m, ws_10min, wg_10min) jos saatavilla.
   - t3→: FMI HARMONIE (temperature, precipitation1h, windspeedms, gustspeedms, SmartSymbol).
   - t1–t2 tuuli: FMI windspeedms (harmaa) ja puuska MET Nowcast gust (harmaa), jos saatavilla.
   Debug: lisää ?dbg=1 → näyttää sateen/tuulen lähdetagit (NC / HRM / OBS / HRM-prev).
*/

const q = new URLSearchParams(location.search);
const LAT = parseFloat(q.get('lat'));
const LON = parseFloat(q.get('lon'));
const TZ  = 'Europe/Helsinki';
const out = document.getElementById('out');

const DBG = q.has('dbg');
function tag(s){ return DBG ? ` <span class="soft" style="font-size:12px">${s}</span>` : ''; }

/* Aikaformatit */
const hmFi = new Intl.DateTimeFormat('fi-FI',{hour:'2-digit',minute:'2-digit',hour12:false,timeZone:TZ,hourCycle:'h23'});
function fmtHM(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}:${ps.find(p=>p.type==='minute')?.value||'00'}`; }
function fmtH(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}`; }

/* SmartSymbol – tiivis sanakirja (voit vaihtaa omaasi myöhemmin) */
const SS_TEXT = {
  1:'Selkeää', 2:'Enimmäkseen selkeää', 4:'Puolipilvistä', 6:'Enimmäkseen pilvistä', 7:'Pilvistä', 9:'Sumua',
  71:'Yksittäisiä ukkoskuuroja', 74:'Paikoin ukkoskuuroja', 77:'Ukkoskuuroja',
  21:'Yksittäisiä sadekuuroja', 24:'Paikoin sadekuuroja', 27:'Sadekuuroja',
  31:'Heikkoa sadetta', 38:'Kohtalaista vesisadetta', 39:'Voimakasta vesisadetta',
  11:'Tihkusadetta', 14:'Jäätävää tihkua', 17:'Jäätävää sadetta'
};
const ssText = c => (c==null?'':(SS_TEXT[Number(c)%100]||''));

/* FMI WFS */
function buildWfsForecast(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::forecast::harmonie::surface::point::timevaluepair';
  const params='temperature,precipitation1h,windspeedms,gustspeedms,SmartSymbol';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-2); e.setHours(e.getHours()+24);
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=60`;
}
function buildWfsObs(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::observations::weather::timevaluepair';
  const params='t2m,ws_10min,wg_10min';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-3);
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=10`;
}

/* XML → sarjat */
const parseXML = txt => {
  const x = new DOMParser().parseFromString(txt,'application/xml');
  const ex = x.querySelector('Exception, ows\\:Exception');
  if (ex){ const t=x.querySelector('ExceptionText, ows\\:ExceptionText'); throw new Error('FMI virhe: '+(t?t.textContent:'Tuntematon virhe')); }
  return x;
};
const extractSeries = x => {
  const get=(e,n)=>e.getElementsByTagNameNS('*',n)[0];
  const all=x.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTimeseries');
  const o={};
  for (const s of all){
    const id=(s.getAttribute('gml:id')||'').toLowerCase();
    let k='';
    if (id.includes('temperature')) k='temperature';
    else if (id.includes('precipitation1h')) k='precipitation1h';
    else if (id.includes('windspeedms')) k='windspeedms';
    else if (id.includes('gustspeedms')) k='gustspeedms';
    else if (id.includes('smartsymbol')) k='SmartSymbol';
    else if (id.includes('t2m')) k='t2m';
    else if (id.includes('ws_10min')) k='ws_10min';
    else if (id.includes('wg_10min')) k='wg_10min';
    if (!k) continue;
    const map=new Map();
    const pts=s.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTVP');
    for (const p of pts){
      const t=get(p,'time')?.textContent;
      const v=get(p,'value')?.textContent;
      if (!t) continue;
      const num = v!=null ? Number(v) : null;
      map.set(t, isNaN(num)?null:num);
    }
    o[k]=map;
  }
  return o;
};

/* MET Nowcast 2.0 complete → tuo myös tuulen ja puuskan */
async function fetchNowcastForHour(lat, lon, dUTC){
  try{
    const url = `https://api.met.no/weatherapi/nowcast/2.0/complete?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&altitude=0`;
    const res = await fetch(url, { cache:'no-store', headers: { 'Accept': 'application/json' } });
    if (!res.ok) return { val:null, meta:`NC!${res.status}` };
    const js = await res.json();
    const ts = js?.properties?.timeseries;
    if (!Array.isArray(ts) || !ts.length) return { val:null, meta:'NC!empty' };

    const targetUTC = dUTC.getTime();

    let best = ts.find(it => new Date(it.time).getTime() === targetUTC);
    if (!best){
      const fut = ts.map(it=>({t:new Date(it.time).getTime(), it})).filter(x=>x.t>=targetUTC).sort((a,b)=>a.t-b.t)[0];
      if (fut && (fut.t - targetUTC) <= 30*60*1000) best = fut.it;
    }
    if (!best){
      let cand=null, diff=1e12;
      for (const it of ts){ const dt=Math.abs(new Date(it.time).getTime()-targetUTC); if (dt<diff){diff=dt; cand=it;} }
      if (cand && diff <= 20*60*1000) best = cand;
    }
    if (!best) return { val:null, meta:'NC!miss' };

    const acc = best?.data?.next_1_hours?.details?.precipitation_amount;
    const pr  = best?.data?.instant?.details?.precipitation_rate;
    const wind= best?.data?.instant?.details?.wind_speed;
    const gust= best?.data?.instant?.details?.wind_speed_of_gust;

    let p = null;
    if (typeof acc === 'number') p = acc;
    else if (typeof pr === 'number') p = pr;

    return { val: (typeof p==='number'?p:null), meta:'NC', wind: (typeof wind==='number'?wind:null), gust:(typeof gust==='number'?gust:null) };
  }catch{ return { val:null, meta:'NC!err' }; }
}

/* Lähin havainto hetkeen (obs) */
function nearestObs(mapUTC, targetLocalDate, maxDiffMin=20){
  if (!mapUTC) return null;
  const targetUTC = new Date(Date.UTC(
    targetLocalDate.getFullYear(), targetLocalDate.getMonth(), targetLocalDate.getDate(),
    targetLocalDate.getHours(), targetLocalDate.getMinutes(), 0
  ));
  let bestKey=null, bestDiff=1e12;
  for (const k of mapUTC.keys()){
    const d=new Date(k);
    const diff=Math.abs(d - targetUTC)/60000;
    if (diff < bestDiff){ bestDiff=diff; bestKey=k; }
  }
  if (bestKey && bestDiff <= maxDiffMin) return mapUTC.get(bestKey);
  return null;
}

/* Sade-solun muotoilu */
function rainCell(val, {markGrey=false, centerDash=false}={}){
  if (val==null || isNaN(Number(val))) return { text:'–', cls:'soft' };
  const n = Number(val);
  if (n === 0){
    return { text:'—', cls: (markGrey ? 'soft dash' : 'dash') };
  }
  return { text:n.toFixed(1) + ' mm', cls:(markGrey ? 'soft' : '') };
}

/* Tuulisolun muotoilu: perus "x.x m/s" + " (puuska y.y)" jos gust >= mean+5 */
function windCell(mean, gust, {markGrey=false, src='' }={}){
  let txt = (mean!=null ? Number(mean).toFixed(1)+' m/s' : '–');
  if (gust!=null && mean!=null && Number(gust) >= Number(mean)+5){
    txt += ` (puuska ${Number(gust).toFixed(1)})`;
  }
  const cls = markGrey ? 'soft' : '';
  return { text: txt + (DBG && src? tag(src):''), cls };
}

(async function(){
  scrollTo(0,1); setTimeout(()=>scrollTo(0,1),150);
  if (!LAT || !LON || isNaN(LAT) || isNaN(LON)){
    out.innerHTML = `<div class="err">Puuttuvat tai virheelliset koordinaatit. Käytä osoitetta:<br><code>?lat=60.1699&lon=24.9384</code></div>`;
    return;
  }

  try{
    const [fRes, oRes] = await Promise.all([
      fetch(buildWfsForecast(LAT,LON), {cache:'no-store'}),
      fetch(buildWfsObs(LAT,LON), {cache:'no-store'})
    ]);
    const [fTxt, oTxt] = await Promise.all([fRes.text(), oRes.text()]);
    if (!fRes.ok) throw new Error(`FMI ennuste HTTP ${fRes.status}\n${fTxt.slice(0,200)}`);
    if (!oRes.ok) throw new Error(`FMI havainnot HTTP ${oRes.status}\n${oTxt.slice(0,200)}`);

    const forecast = extractSeries(parseXML(fTxt));
    const obs      = extractSeries(parseXML(oTxt));

    const now = new Date();
    const thisHourLocal  = new Date(new Date(now).setMinutes(0,0,0));

    /* Nouki 13 tuntia alkaen tästä tasatunnista */
    const fKeys = Array.from(forecast.temperature?.keys?.()||[]).sort();
    const pickKeys = [];
    for (const k of fKeys){
      const d = new Date(k);
      if (d >= thisHourLocal){ pickKeys.push(k); if (pickKeys.length>=13) break; }
    }
    if (!pickKeys.length){ out.innerHTML = `<div class="muted">Ei rivejä tälle ikkunalle.</div>`; return; }

    /* Nowcast t0–t2 */
    const d0 = pickKeys[0] ? new Date(pickKeys[0]) : null;
    const d1 = pickKeys[1] ? new Date(pickKeys[1]) : null;
    const d2 = pickKeys[2] ? new Date(pickKeys[2]) : null;
    const [nc0, nc1, nc2] = await Promise.all([
      d0 ? fetchNowcastForHour(LAT, LON, d0) : Promise.resolve({val:null, meta:'NC!skip'}),
      d1 ? fetchNowcastForHour(LAT, LON, d1) : Promise.resolve({val:null, meta:'NC!skip'}),
      d2 ? fetchNowcastForHour(LAT, LON, d2) : Promise.resolve({val:null, meta:'NC!skip'})
    ]);

    let html = '';
    let prevDesc = null;

    /* t0 (nyt) */
    {
      const key = pickKeys[0];
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fGust = forecast.gustspeedms?.get?.(key);
      const fSS   = forecast.SmartSymbol?.get(key);

      const oTemp = nearestObs(obs.t2m, now, 20);
      const oWind = nearestObs(obs.ws_10min, now, 20);
      const oGust = nearestObs(obs.wg_10min, now, 20);

      const tempStr = (oTemp!=null ? Math.round(oTemp)+'°C' : (fTemp!=null?Math.round(fTemp)+'°C':'–'));
      const tempCls = (oTemp!=null?'':'soft');

      // Sade: NC
      let rainObj;
      if (nc0 && typeof nc0.val === 'number'){
        // nolla → harmaa ja keskitetty dash
        if (nc0.val === 0) rainObj = rainCell(0, { markGrey:true, centerDash:true });
        else rainObj = rainCell(nc0.val);
      }else{
        // fallback: malli edellisestä tasatunnista harmaana
        const prev = new Date(thisHourLocal); prev.setHours(prev.getHours()-1);
        const prevKey = new Date(Date.UTC(prev.getFullYear(),prev.getMonth(),prev.getDate(),prev.getHours(),0,0)).toISOString().replace(/\.\d{3}Z$/,'Z');
        const fPrevRain = forecast.precipitation1h?.get(prevKey);
        if (fPrevRain!=null && fPrevRain>0){
          rainObj = rainCell(fPrevRain, { markGrey:true });
        }else{
          rainObj = { text:'—', cls:'soft dash' };
        }
      }

      // Tuuli: havainnot jos saatavilla; puuska suluissa jos ≥ +5
      const wind = windCell(
        (oWind!=null ? oWind : (fWind!=null?fWind:null)),
        (oGust!=null ? oGust : (fGust!=null?fGust:null)),
        { markGrey: (oWind==null), src: (oWind!=null?'OBS':'HRM') }
      );

      const desc = ssText(fSS) || '–';

      html += `<div class="row">
        <div class="t">${fmtHM(now)}</div>
        <div class="${tempCls}">${tempStr}</div>
        <div class="desc soft">${desc}</div>
        <div class="${rainObj.cls||''}">${rainObj.text}${tag('NC')}</div>
        <div class="${wind.cls||''}">${wind.text}</div>
      </div>`;
      prevDesc = desc;
    }

    /* t+1h */
    if (pickKeys.length >= 2){
      const key = pickKeys[1];
      const dUtc = new Date(key);
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fGust = forecast.gustspeedms?.get?.(key);
      const fRain = forecast.precipitation1h?.get(key);
      const fSS   = forecast.SmartSymbol?.get(key);

      const tempStr = (fTemp!=null?Math.round(fTemp)+'°C':'–');

      // Sade: NC ensisijainen; nolla → harmaa dash keskitettynä
      let rainObj, rainSrc='NC';
      if (nc1 && typeof nc1.val === 'number'){
        if (nc1.val === 0) rainObj = rainCell(0, { markGrey:true, centerDash:true });
        else rainObj = rainCell(nc1.val, { markGrey:false });
      } else {
        // HRM harmaana
        rainSrc='HRM';
        if (fRain == null) { rainObj = { text:'–', cls:'soft' }; }
        else if (Number(fRain)===0) { rainObj = { text:'—', cls:'soft dash' }; }
        else { rainObj = rainCell(fRain, { markGrey:true }); }
      }

      // Tuuli: keskituuli HRM (harmaa), puuska NC-gust jos saatavilla (harmaa)
      const mean = (fWind!=null?fWind:null);
      const gust = (nc1 && typeof nc1.gust==='number') ? nc1.gust : (fGust!=null?fGust:null);
      const wind = windCell(mean, gust, { markGrey:true, src: (nc1 && nc1.gust!=null?'NC-gust':'HRM') });

      const desc = ssText(fSS) || '–';
      const shownDesc = (desc === prevDesc && desc !== '–')
        ? '<span class="ditto" aria-label="sama kuin edellä" title="sama kuin edellä">&raquo;</span>'
        : desc;

      html += `<div class="row">
        <div class="t soft">${fmtHM(dUtc)}</div>
        <div class="soft">${tempStr}</div>
        <div class="desc soft">${shownDesc}</div>
        <div class="${rainObj.cls||''}">${rainObj.text}${tag(rainSrc)}</div>
        <div class="${wind.cls||''}">${wind.text}</div>
      </div>`;
      prevDesc = desc;
    }

    /* t+2h */
    if (pickKeys.length >= 3){
      const key = pickKeys[2];
      const dUtc = new Date(key);
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fGust = forecast.gustspeedms?.get?.(key);
      const fRain = forecast.precipitation1h?.get(key);
      const fSS   = forecast.SmartSymbol?.get(key);

      const tempStr = (fTemp!=null?Math.round(fTemp)+'°C':'–');

      let rainObj, rainSrc='NC';
      if (nc2 && typeof nc2.val === 'number'){
        if (nc2.val === 0) rainObj = rainCell(0, { markGrey:true, centerDash:true });
        else rainObj = rainCell(nc2.val);
      } else {
        rainSrc='HRM';
        if (fRain == null) { rainObj = { text:'–', cls:'soft' }; }
        else if (Number(fRain)===0) { rainObj = { text:'—', cls:'soft dash' }; }
        else { rainObj = rainCell(fRain, { markGrey:true }); }
      }

      const mean = (fWind!=null?fWind:null);
      const gust = (nc2 && typeof nc2.gust==='number') ? nc2.gust : (fGust!=null?fGust:null);
      const wind = windCell(mean, gust, { markGrey:true, src: (nc2 && nc2.gust!=null?'NC-gust':'HRM') });

      const desc = ssText(fSS) || '–';
      const shownDesc = (desc === prevDesc && desc !== '–')
        ? '<span class="ditto" aria-label="sama kuin edellä" title="sama kuin edellä">&raquo;</span>'
        : desc;

      html += `<div class="row">
        <div class="t soft">${fmtHM(dUtc)}</div>
        <div class="soft">${tempStr}</div>
        <div class="desc soft">${shownDesc}</div>
        <div class="${rainObj.cls||''}">${rainObj.text}${tag(rainSrc)}</div>
        <div class="${wind.cls||''}">${wind.text}</div>
      </div>`;
      prevDesc = desc;
    }

    /* 10 ennusteriviä */
    let written = 0;
    for (let i=3; i<pickKeys.length && written<10; i++, written++){
      const key = pickKeys[i];
      const dUtc = new Date(key);
      const temp = forecast.temperature?.get(key);
      const rainVal = forecast.precipitation1h?.get(key);
      const wind = forecast.windspeedms?.get(key);
      const gust = forecast.gustspeedms?.get?.(key);
      const ss   = forecast.SmartSymbol?.get(key);
      const desc = ssText(ss) || '–';

      let rainObj;
      if (rainVal==null){ rainObj = { text:'–', cls:'soft' }; }
      else if (Number(rainVal)===0){ rainObj = { text:'—', cls:'dash' }; }  /* ennusteriveillä nolla valkoisena ja keskitettynä */
      else { rainObj = rainCell(rainVal); }

      const shownDesc = (desc === prevDesc && desc !== '–')
        ? '<span class="ditto" aria-label="sama kuin edellä" title="sama kuin edellä">&raquo;</span>'
        : desc;
      prevDesc = desc;

      const windObj = windCell(wind, gust, { markGrey:false, src:'HRM' });

      html += `<div class="row">
        <div class="t hh"><span class="mini">klo&nbsp;</span>${fmtH(dUtc)}</div>
        <div>${temp!=null?Math.round(temp)+'°C':'–'}</div>
        <div class="desc">${shownDesc}</div>
        <div class="${rainObj.cls||''}">${rainObj.text}${tag('HRM')}</div>
        <div class="${windObj.cls||''}">${windObj.text}</div>
      </div>`;
    }

    out.innerHTML = html || `<div class="muted">Ei rivejä tälle ikkunalle.</div>`;
  }catch(e){
    out.innerHTML = `<div class="err">${String(e.message||e)}</div>`;
  }
})();
</script>
