<!doctype html>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="noindex">
<title>SÄÄ SEURAAVAT 12 h (FMI)</title>
<style>
  :root { color-scheme: dark; }
  html,body{height:100%}
  body{
    margin:0; padding:28px 14px 24px; background:#000; color:#e8e8e8;
    font:17px/1.5 Arial,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility
  }
  .list{ border-top:1px solid #2a2a2a; margin-top:6px; }
  .klohdr{
    color:#5d676f; font-size:12px; letter-spacing:.3px; margin:6px 0 4px 0;
    display:grid; grid-template-columns:54px 64px 1fr 70px 64px;
  }
  .klohdr > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px; }
  .klohdr > div:not(:first-child){ visibility:hidden; }

  .row{
    display:grid; grid-template-columns:54px 64px 1fr 70px 64px;
    gap:8px; padding:6px 0; border-bottom:1px solid #1c1c1c;
  }
  .row > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px; }

  /* vielä himmeämmät harmaat */
  .muted{ color:#515a62 }
  .soft{  color:#515a62 }

  /* kellonajan kohdistus: oletuksena vasen; ennusteriveillä oikea */
  .t{ text-align:left }
  .t.hh{ text-align:right }

  /* ditto vasempaan laitaan */
  .desc .ditto{ display:inline }
  .ditto{ color:inherit }

  .err{ color:#ff6b6b; white-space:pre-wrap }
</style>

<div class="klohdr"><div>klo</div><div></div><div></div><div></div><div></div></div>
<div class="list" id="out" aria-live="polite"></div>

<script>
/* Sade-lähteet:
   - t0 (nyt): tutka RR (WMS GetFeatureInfo). Jos puuttuu → “erikoisfallback”:
       * katso edellisen tasatunnin (thisHour-1) HARMONIE-ennuste: jos >0 → näytä harmaana n.nn mm,
         muuten harmaa em dash.
       * samalla t1 ja t2 sateet: harmaat em dashit (ei numeroita).
   - t1, t2: yritä NOWCAST-sadetta (TODO: kytke oikea endpoint). Jos puuttuu → HARMONIE numero harmaana, 0 → valkoinen em dash.
   - t3..: HARMONIE normaalisti; 0 → valkoinen em dash; >0 → valkoinen numero.

   HUOM: Tämä tiedosto ei vielä kytke oikeaa nowcast-endpointtia (FMI-PPN tms.), vaan
   fetchNowcast() palauttaa null → t1/t2 näyttävät HARMONIE-sateen harmaana. Kun nowcast-API
   tiedossa, täytä fetchNowcast().

   Muut sarakkeet kuten ennen: t0 lämpö/tuuli havainnoista jos saatavilla, muutoin malli (soft).
   t1/t2 lämpö/tuuli mallista (soft). SS: t0–t2 soft, loput valkoisena; ditto-merkki kuvaussarakkeessa.
*/

const q = new URLSearchParams(location.search);
const LAT = parseFloat(q.get('lat'));
const LON = parseFloat(q.get('lon'));
const TZ  = 'Europe/Helsinki';
const out = document.getElementById('out');

/* Aikaformatit */
const hmFi = new Intl.DateTimeFormat('fi-FI',{hour:'2-digit',minute:'2-digit',hour12:false,timeZone:TZ,hourCycle:'h23'});
function fmtHM(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}:${ps.find(p=>p.type==='minute')?.value||'00'}`; }
function fmtH(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}`; }
const partsFmt = new Intl.DateTimeFormat('en-GB',{timeZone:TZ,year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit',hourCycle:'h23'});
function parts(d){ const ps=partsFmt.formatToParts(d); const g=t=>Number(ps.find(p=>p.type===t)?.value); return {y:g('year'),m:g('month'),d:g('day'),h:g('hour'),min:g('minute')}; }
const idOf = p => ((p.y*100+p.m)*100+p.d)*100 + p.h;

/* SmartSymbol-sanakirja (suppea, riittää demoihin — sinulla on täydellinen lista) */
const SS_TEXT = {
  1:'Selkeää', 2:'Enimmäkseen selkeää', 4:'Puolipilvistä', 6:'Enimmäkseen pilvistä', 7:'Pilvistä', 9:'Sumua',
  71:'Yksittäisiä ukkoskuuroja', 74:'Paikoin ukkoskuuroja', 77:'Ukkoskuuroja',
  21:'Yksittäisiä sadekuuroja', 24:'Paikoin sadekuuroja', 27:'Sadekuuroja',
  14:'Jäätävää tihkua', 17:'Jäätävää sadetta', 11:'Tihkusadetta',
  31:'Puolipilvistä ja ajoittain heikkoa vesisadetta', 34:'Enimmäkseen pilvistä ja ajoittain heikkoa vesisadetta', 37:'Heikkoa vesisadetta',
  32:'Puolipilvistä ja ajoittain kohtalaista vesisadetta', 35:'Enimmäkseen pilvistä ja ajoittain kohtalaista vesisadetta', 38:'Kohtalaista vesisadetta',
  33:'Puolipilvistä ja ajoittain voimakasta vesisadetta', 36:'Enimmäkseen pilvistä ja ajoittain voimakasta vesisadetta', 39:'Voimakasta vesisadetta'
};
const ssText = c => (c==null?'':(SS_TEXT[Number(c)%100]||''));

/* FMI HARMONIE (malli) */
function buildWfsForecast(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::forecast::harmonie::surface::point::timevaluepair';
  const params='temperature,precipitation1h,windspeedms,SmartSymbol';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-2); e.setHours(e.getHours()+24);
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=60`;
}

/* FMI havainnot (t2m, ws_10min) */
function buildWfsObs(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::observations::weather::timevaluepair';
  const params='t2m,ws_10min';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-3);
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=10`;
}

/* XML → sarjat */
const parseXML = txt => {
  const x = new DOMParser().parseFromString(txt,'application/xml');
  const ex = x.querySelector('Exception, ows\\:Exception');
  if (ex){ const t=x.querySelector('ExceptionText, ows\\:ExceptionText'); throw new Error('FMI virhe: '+(t?t.textContent:'Tuntematon virhe')); }
  return x;
};
const extractSeries = x => {
  const get=(e,n)=>e.getElementsByTagNameNS('*',n)[0];
  const all=x.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTimeseries');
  const o={};
  for (const s of all){
    const id=(s.getAttribute('gml:id')||'').toLowerCase();
    let k='';
    if (id.includes('temperature')) k='temperature';
    else if (id.includes('precipitation1h')) k='precipitation1h';
    else if (id.includes('windspeedms')) k='windspeedms';
    else if (id.includes('smartsymbol')) k='SmartSymbol';
    else if (id.includes('t2m')) k='t2m';
    else if (id.includes('ws_10min')) k='ws_10min';
    if (!k) continue;
    const map=new Map();
    const pts=s.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTVP');
    for (const p of pts){
      const t=get(p,'time')?.textContent;
      const v=get(p,'value')?.textContent;
      if (!t) continue;
      const num = v!=null ? Number(v) : null;
      map.set(t, isNaN(num)?null:num);
    }
    o[k]=map;
  }
  return o;
};

/* Tutka RR: WMS GetFeatureInfo (keskipikseli, TIME=latest) */
function wmsRRUrl(lat, lon){
  const service='https://opendata.fmi.fi/wms';
  const L='radar:composite:rr';
  const pad=0.1, minLat=lat-pad, maxLat=lat+pad, minLon=lon-pad, maxLon=lon+pad;
  const WIDTH=101, HEIGHT=101, I=50, J=50;
  const qs = new URLSearchParams({
    service:'WMS', request:'GetFeatureInfo', version:'1.3.0',
    layers:L, query_layers:L, styles:'',
    crs:'EPSG:4326',
    bbox:`${minLat},${minLon},${maxLat},${maxLon}`,
    width:String(WIDTH), height:String(HEIGHT),
    i:String(I), j:String(J),
    info_format:'text/plain',
    time:'latest'
  });
  return `${service}?${qs.toString()}`;
}
async function fetchRadarRR(lat, lon, timeoutMs=6000){
  try{
    const ctrl=new AbortController(); const t=setTimeout(()=>ctrl.abort(),timeoutMs);
    const res=await fetch(wmsRRUrl(lat,lon),{cache:'no-store',signal:ctrl.signal});
    clearTimeout(t);
    const txt=await res.text();
    if (!res.ok) throw new Error(`WMS ${res.status}`);
    const m = txt.match(/([-+]?\d+(?:\.\d+)?)/);
    if (m){ const v=Number(m[1]); return isNaN(v)?null:v; }
    return null;
  }catch(_e){ return null; }
}

/* NOWCAST-sade (TODO: kytke oikeaan endpointtiin; nyt palauttaa null → fallback HARMONIEen t1/t2) */
async function fetchNowcast(lat, lon, hoursAhead /* 1 tai 2 */){
  // Tähän kun liität FMI-PPN / muun nowcast-API:n, palauta mm/h (numero) tai null.
  return null;
}

/* Lähin havainto hetkeen */
function nearestObs(mapUTC, targetLocalDate, maxDiffMin=20){
  if (!mapUTC) return null;
  const targetUTC = new Date(Date.UTC(
    targetLocalDate.getFullYear(), targetLocalDate.getMonth(), targetLocalDate.getDate(),
    targetLocalDate.getHours(), targetLocalDate.getMinutes(), 0
  ));
  let bestKey=null, bestDiff=1e12;
  for (const k of mapUTC.keys()){
    const d=new Date(k);
    const diff=Math.abs(d - targetUTC)/60000;
    if (diff < bestDiff){ bestDiff=diff; bestKey=k; }
  }
  if (bestKey && bestDiff <= maxDiffMin) return mapUTC.get(bestKey);
  return null;
}

/* Sade-solun muotoilu:
   - null/undefined → '–' (harmaana)
   - 0 → pitkä ajatusviiva — (valkoisena) [paitsi erikoisfallback t0/t1/t2, jossa harmaa]
   - >0 → n.mm (valkoisena), tai harmaana jos markGrey=true
*/
function rainCell(val, {markGrey=false, forceGreyDash=false}={}){
  if (val==null || isNaN(Number(val))) return { text:'–', cls:'soft' };
  const n = Number(val);
  if (n === 0){
    return { text:'—', cls: (forceGreyDash ? 'soft' : '') };
  }
  return { text:n.toFixed(1) + ' mm', cls:(markGrey ? 'soft' : '') };
}

(async function(){
  scrollTo(0,1); setTimeout(()=>scrollTo(0,1),150);
  if (!LAT || !LON || isNaN(LAT) || isNaN(LON)){
    out.innerHTML = `<div class="err">Puuttuvat tai virheelliset koordinaatit. Käytä osoitetta:<br><code>?lat=60.1699&lon=24.9384</code></div>`;
    return;
  }

  try{
    // Hae malli + havainnot rinnakkain
    const [fRes, oRes] = await Promise.all([
      fetch(buildWfsForecast(LAT,LON), {cache:'no-store'}),
      fetch(buildWfsObs(LAT,LON), {cache:'no-store'})
    ]);
    const [fTxt, oTxt] = await Promise.all([fRes.text(), oRes.text()]);
    if (!fRes.ok) throw new Error(`FMI ennuste HTTP ${fRes.status}\n${fTxt.slice(0,200)}`);
    if (!oRes.ok) throw new Error(`FMI havainnot HTTP ${oRes.status}\n${oTxt.slice(0,200)}`);

    const forecast = extractSeries(parseXML(fTxt));
    const obs      = extractSeries(parseXML(oTxt));

    // ennusteen tasatunnit alkaen kuluvasta tasatunnista
    const now = new Date();
    const thisHourLocal  = new Date(new Date(now).setMinutes(0,0,0));   // HH:00
    const fKeys = Array.from(forecast.temperature?.keys?.()||[]).sort();

    // valitaan thisHour, +1h, +2h, ja lisäksi 10 lisää (yht. 13 riviä)
    const pickKeys = [];
    for (const k of fKeys){
      const d = new Date(k);
      if (d >= thisHourLocal){ pickKeys.push(k); if (pickKeys.length>=13) break; }
    }
    if (!pickKeys.length){ out.innerHTML = `<div class="muted">Ei rivejä tälle ikkunalle.</div>`; return; }

    // Tutkan RR (t0). Jos puuttuu → erikoisfallback vaikuttaa myös t1/t2 sateen soluihin.
    const rrNow = await fetchRadarRR(LAT, LON);
    const noRadarFallback = (rrNow == null);

    // Hae mahdolliset nowcastit t1/t2 (palautuu nykytilassa null)
    const nc1 = await fetchNowcast(LAT, LON, 1); // t+1h
    const nc2 = await fetchNowcast(LAT, LON, 2); // t+2h

    let html = '';
    let prevDesc = null;

    // --- 1) NYT (HH:MM) — bucket = pickKeys[0], kellonaika = now
    {
      const key = pickKeys[0];
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fSS   = forecast.SmartSymbol?.get(key);
      const fRainThis = forecast.precipitation1h?.get(key);

      const oTemp = nearestObs(obs.t2m, now, 20);
      const oWind = nearestObs(obs.ws_10min, now, 20);

      const tempStr = (oTemp!=null ? Math.round(oTemp)+'°C' : (fTemp!=null?Math.round(fTemp)+'°C':'–'));
      const windStr = (oWind!=null ? oWind.toFixed(1)+' m/s' : (fWind!=null?fWind.toFixed(1)+' m/s':'–'));
      const tempCls = (oTemp!=null?'':'soft');
      const windCls = (oWind!=null?'':'soft');

      let rainObj;
      if (!noRadarFallback){
        rainObj = rainCell(rrNow);
      }else{
        // erikoisfallback: katso edellinen tasatunti (thisHour-1) HARMONIE
        const prevHourUTCKey = (()=>{
          const prev = new Date(thisHourLocal); prev.setHours(prev.getHours()-1);
          // muodostetaan kello-UTC-ISO avain
          const iso = new Date(Date.UTC(prev.getFullYear(),prev.getMonth(),prev.getDate(),prev.getHours(),0,0))
                       .toISOString().replace(/\.\d{3}Z$/,'Z');
          return iso;
        })();
        const fPrevRain = forecast.precipitation1h?.get(prevHourUTCKey);
        if (fPrevRain!=null && fPrevRain>0){
          rainObj = rainCell(fPrevRain, {markGrey:true});
        }else{
          rainObj = { text:'—', cls:'soft' }; // harmaa em dash
        }
      }

      const desc = ssText(fSS) || '–';

      html += `<div class="row">
        <div class="t">${fmtHM(now)}</div>
        <div class="${tempCls}">${tempStr}</div>
        <div class="desc soft">${desc}</div>
        <div class="${rainObj.cls}">${rainObj.text}</div>
        <div class="${windCls}">${windStr}</div>
      </div>`;
      prevDesc = desc;
    }

    // --- 2) t+1h (HH:MM) — pickKeys[1]; sade = nowcast (jos ei → HARMONIE harmaana; erikoisfallbackissa harmaa em dash)
    if (pickKeys.length >= 2){
      const key = pickKeys[1];
      const dUtc = new Date(key);
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fRain = forecast.precipitation1h?.get(key);
      const fSS   = forecast.SmartSymbol?.get(key);

      const tempStr = (fTemp!=null?Math.round(fTemp)+'°C':'–');
      const windStr = (fWind!=null?fWind.toFixed(1)+' m/s':'–');

      let rainObj;
      if (noRadarFallback){
        // koko t0–t2 erikoisfallback: harmaat em dashit t1/t2
        rainObj = { text:'—', cls:'soft' };
      }else{
        if (nc1!=null){
          rainObj = rainCell(nc1); // nowcast → valkoisena
        }else{
          // ei nowcastia → käytä HARMONIEa harmaana
          if (fRain==null) rainObj = { text:'–', cls:'soft' };
          else if (Number(fRain)===0) rainObj = { text:'—', cls:'' };
          else rainObj = rainCell(fRain, {markGrey:true});
        }
      }

      const desc = ssText(fSS) || '–';
      const shownDesc = (desc === prevDesc && desc !== '–')
        ? '<span class="ditto" aria-label="sama kuin edellä" title="sama kuin edellä">–»–</span>'
        : desc;

      html += `<div class="row">
        <div class="t">${fmtHM(dUtc)}</div>
        <div class="soft">${tempStr}</div>
        <div class="desc soft">${shownDesc}</div>
        <div class="${rainObj.cls}">${rainObj.text}</div>
        <div class="soft">${windStr}</div>
      </div>`;
      prevDesc = desc;
    }

    // --- 3) t+2h (HH:MM) — pickKeys[2]; sama logiikka kuin t+1h
    if (pickKeys.length >= 3){
      const key = pickKeys[2];
      const dUtc = new Date(key);
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fRain = forecast.precipitation1h?.get(key);
      const fSS   = forecast.SmartSymbol?.get(key);

      const tempStr = (fTemp!=null?Math.round(fTemp)+'°C':'–');
      const windStr = (fWind!=null?fWind.toFixed(1)+' m/s':'–');

      let rainObj;
      if (noRadarFallback){
        rainObj = { text:'—', cls:'soft' };
      }else{
        if (nc2!=null){
          rainObj = rainCell(nc2);
        }else{
          if (fRain==null) rainObj = { text:'–', cls:'soft' };
          else if (Number(fRain)===0) rainObj = { text:'—', cls:'' };
          else rainObj = rainCell(fRain, {markGrey:true});
        }
      }

      const desc = ssText(fSS) || '–';
      const shownDesc = (desc === prevDesc && desc !== '–')
        ? '<span class="ditto" aria-label="sama kuin edellä" title="sama kuin edellä">–»–</span>'
        : desc;

      html += `<div class="row">
        <div class="t">${fmtHM(dUtc)}</div>
        <div class="soft">${tempStr}</div>
        <div class="desc soft">${shownDesc}</div>
        <div class="${rainObj.cls}">${rainObj.text}</div>
        <div class="soft">${windStr}</div>
      </div>`;
      prevDesc = desc;
    }

    // --- 4) Ennusterivit: aloita pickKeys[3] → ota vielä 10 riviä (jos riittää)
    let written = 0;
    for (let i=3; i<pickKeys.length && written<10; i++, written++){
      const key = pickKeys[i];
      const dUtc = new Date(key);
      const temp = forecast.temperature?.get(key);
      const rainVal = forecast.precipitation1h?.get(key);
      const wind = forecast.windspeedms?.get(key);
      const ss   = forecast.SmartSymbol?.get(key);
      const desc = ssText(ss) || '–';

      let rainObj;
      if (rainVal==null) rainObj = { text:'–', cls:'soft' };
      else if (Number(rainVal)===0) rainObj = { text:'—', cls:'' };
      else rainObj = rainCell(rainVal);

      const shownDesc = (desc === prevDesc && desc !== '–')
        ? '<span class="ditto" aria-label="sama kuin edellä" title="sama kuin edellä">–»–</span>'
        : desc;
      prevDesc = desc;

      html += `<div class="row">
        <div class="t hh">${fmtH(dUtc)}</div>
        <div>${temp!=null?Math.round(temp)+'°C':'–'}</div>
        <div class="desc">${shownDesc}</div>
        <div class="${rainObj.cls}">${rainObj.text}</div>
        <div>${wind!=null?wind.toFixed(1)+' m/s':'–'}</div>
      </div>`;
    }

    out.innerHTML = html || `<div class="muted">Ei rivejä tälle ikkunalle.</div>`;
  }catch(e){
    out.innerHTML = `<div class="err">${String(e.message||e)}</div>`;
  }
})();
</script>
