<!doctype html>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="noindex">
<title>TUSINASÄÄ 12</title>
<style>
  :root { color-scheme: dark; }
  html,body{height:100%}
  body{
    margin:0; padding:22px 14px 24px; background:#000; color:#e8e8e8;
    font:17px/1.5 Arial,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility
  }
  .pageTitle{ font-weight:700; font-size:15px; letter-spacing:.4px; color:#9aa6b0;
    text-transform:uppercase; margin:0 0 4px 0 }
  .mini{ color:#7a858e; font-size:12px; letter-spacing:.3px; line-height:1.2 }
  .miniW{ color:#e8e8e8; font-size:12px; letter-spacing:.3px; line-height:1.2 }
  .miniTag{ text-transform:uppercase; font-style:normal !important; color:#9aa6b0 }
  .caps{ text-transform:uppercase; letter-spacing:.5px }
  .list{ border-top:1px solid #2a2a2a; margin-top:6px; }
  .hdr{
    color:#6b7580; font-size:12px; letter-spacing:.3px; margin:6px 0 4px 0;
    display:grid; grid-template-columns:54px 56px 1fr 70px 76px; align-items:end; justify-items:center;
  }
  .hdr div:nth-child(-n+3){ justify-self:start; text-align:left }
  .hdr div:nth-child(4), .hdr div:nth-child(5){ text-align:center }
  .row{
    display:grid; grid-template-columns:54px 56px 1fr 70px 76px;
    gap:8px; padding:6px 0; border-bottom:1px solid #1c1c1c; align-items:center;
  }
  .row > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px }
  .muted{ color:#74808a } .soft{ color:#7f8a93 }
  .t{ text-align:left } .t.hh{ text-align:right }
  .row > div:nth-child(4){ text-align:center }
  .desc .ditto{ display:inline } .ditto{ color:inherit }
  .dash{ text-align:center }
  .windDir{ display:block; margin-top:2px }
  .err{ color:#ff6b6b; white-space:pre-wrap; font-size:14px; margin-top:8px }
  em{ font-style:italic }
</style>

<h1 id="pageTitle" class="pageTitle" style="display:none"></h1>

<div class="hdr">
  <div></div><div></div><div></div>
  <div class="caps">SADE</div>
  <div class="caps">TUULEE</div>
</div>
<div class="list" id="out" aria-live="polite"></div>

<script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.min.js"></script>
<script>
/* ---------- perusinfra ---------- */
const out = document.getElementById('out');
window.addEventListener('error', e => {
  const msg = (e && e.message) ? e.message : String(e);
  const where = (e && e.filename) ? `\n@ ${e.filename}:${e.lineno||''}:${e.colno||''}` : '';
  out.innerHTML = `<div class="err">Virhe: ${msg}${where}</div>` + out.innerHTML;
});

/* ---------- parametrit ---------- */
const q = new URLSearchParams(location.search);
const LAT_STR = q.get('lat'); const LON_STR = q.get('lon');
const LAT = parseFloat(LAT_STR); const LON = parseFloat(LON_STR);
const TZ  = 'Europe/Helsinki';
const DBG = q.has('dbg');
const tag = s => DBG ? ` <span class="soft" style="font-size:12px">${s}</span>` : '';

/* ---------- otsikot erikoiskoordinaateille ---------- */
const pageTitle = document.getElementById('pageTitle');
if (LAT_STR === '60.3281' && LON_STR === '25.0551'){ pageTitle.textContent = 'Korso'; pageTitle.style.display='block'; }
if (LAT_STR === '60.1562' && LON_STR === '24.7767'){ pageTitle.textContent = 'MERIKOTO'; pageTitle.style.display='block'; }

/* ---------- apurit ---------- */
const fmt = (d, opts) => d.toLocaleString('fi-FI', {timeZone:TZ, ...opts});
const fmtH  = d => fmt(d, {hour:'numeric'});
const fmtHM = d => fmt(d, {hour:'numeric', minute:'2-digit'});

const ncBase = s => (s||'').split('_')[0]; // esim. partlycloudy_day → partlycloudy
const isNcClear = s => ['clearsky','fair','partlycloudy'].includes(ncBase(s));

/* -- MET symboli → sinun tekstit (normalisoidaan _day/_night pois) -- */
function ncSymbolText(sym){
  if (!sym) return null;
  const b = ncBase(sym);
  const MAP = {
    clearsky: "sinistä",
    fair: "sangen sinistä",
    partlycloudy: "siniharmaata",
    cloudy: "harmaata",
    lightrainshowers: "Jokunen kuuro.",
    heavyrainshowers: "Äänekästä kuuroa.",
    rainshowersandthunder: "Sepon välisuihkut.",
    thunderstorm: "Seppo riehuu.",
    heavyrain: "Saavista kaatuu.",
    lightrain: "Ripsii.",
    sleet: "Räntää.",
    lightsleetshowers_and_thunder: "Sepon tiskivuoro.",
    snowshowers_and_thunder: "Lumiukkonen.",
    snow: "Lunta.",
    heavysnow: "Pyryttää.",
    fog: "MIST!"
  };
  return MAP[b] || null;
}

/* ---------- Sun/twilight ---------- */
const sunriseCache = new Map();
async function fetchSunriseDay(dl, lat, lon){
  const k = `${dl.getFullYear()}-${dl.getMonth()+1}-${dl.getDate()}`;
  if (sunriseCache.has(k)) return sunriseCache.get(k);
  // SunCalc fallback suoraan (riittää meille)
  const d = new Date(dl); d.setHours(12,0,0,0);
  const times = SunCalc.getTimes(d, lat, lon);
  const wrap = t => t ? new Date(t) : null;
  const obj = {
    sunrise: wrap(times.sunrise),
    sunset: wrap(times.sunset),
    dawn: wrap(times.dawn),
    dusk: wrap(times.dusk),
    nauticalDawn: wrap(times.nauticalDawn),
    nauticalDusk: wrap(times.nauticalDusk),
    nightEnd: wrap(times.nightEnd),
    night: wrap(times.night)
  };
  sunriseCache.set(k, obj);
  return obj;
}
function phaseLabel(phase){
  switch(phase){
    case 'civil': return 'porvarillinen hämärä';
    case 'nautical': return 'nauttinen hämärä';
    case 'astronomical': return 'astronominen hämärä';
    case 'night': return 'säkkipimeää';
    default: return null;
  }
}
function nextLabelFor(to){
  if (to==='civil') return 'porvarillinen alkaa';
  if (to==='nautical') return 'nauttinen alkaa';
  if (to==='astronomical') return 'astronominen alkaa';
  if (to==='night') return 'säkkipimeä alkaa';
  return null;
}
function analyzeTwilightForHour(dLocal, day){
  const rise = day.sunrise, set = day.sunset;
  const civStart = day.dawn, civEnd = day.dusk;
  const nautStart = day.nauticalDawn, nautEnd = day.nauticalDusk;
  const astroStart = day.nightEnd, astroEnd = day.night;

  const t0 = new Date(dLocal); t0.setMinutes(0,0,0);
  const t1 = new Date(t0); t1.setHours(t1.getHours()+1);

  function where(t){
    if (astroStart && t<astroStart) return 'night';
    if (astroStart && nautStart && t>=astroStart && t<nautStart) return 'astronomical';
    if (nautStart && civStart && t>=nautStart && t<civStart) return 'nautical';
    if (civStart && rise && t>=civStart && t<rise) return 'civil';
    if (rise && set && t>=rise && t<set) return 'day';
    if (set && civEnd && t>=set && t<civEnd) return 'civil';
    if (civEnd && nautEnd && t>=civEnd && t<nautEnd) return 'nautical';
    if (nautEnd && astroEnd && t>=nautEnd && t<astroEnd) return 'astronomical';
    if (astroEnd && t>=astroEnd) return 'night';
    return null;
  }
  const phase = where(t0);

  let withinChange=null, sunEvent=null;
  if (rise && rise>=t0 && rise<t1) sunEvent={type:'rise',at:rise};
  if (set  && set >=t0 && set <t1) sunEvent={type:'set', at:set};

  if (!sunEvent){
    const cands=[civStart,civEnd,nautStart,nautEnd,astroStart,astroEnd].filter(t=>t&&t>=t0&&t<t1).sort((a,b)=>a-b);
    const at=cands[0]||null;
    if (at){
      const to=where(new Date(at.getTime()+1));
      if (to) withinChange={to,at};
    }
  }
  return {phase, withinChange, sunEvent, sunrise:rise, sunset:set};
}
function minutesBetween(a,b){ return (b.getTime()-a.getTime())/60000; }
function shouldMarkGolden({start, rise, set, descIsClear}){
  if (!descIsClear) return false;
  let ok = false;
  if (rise){ const d=minutesBetween(start,rise); if (Math.abs(d)<=15) ok=true; }
  if (set){ const d=minutesBetween(start,set); if (d>=30 && d<=70) ok=true; }
  return ok;
}

/* ---------- solut ---------- */
function rainCell(val, {markGrey=false}={}){
  if (val==null || isNaN(Number(val))) return { text:'–', cls:'soft', num:null };
  const n = Number(val);
  if (n === 0) return { text:'—', cls:'soft dash', num:0 };
  return { text:n.toFixed(1)+' mm', cls:(markGrey?'soft':''), num:n };
}
function windCell(mean, gust, dirDeg, {baseGrey=true}={}){
  const mOk = (mean!=null && !isNaN(Number(mean)));
  const gOk = (gust!=null && !isNaN(Number(gust)));
  const m = mOk ? Number(mean) : null;
  const g = gOk ? Number(gust) : null;

  let txt = (mOk ? m.toFixed(1)+' m/s' : '–');
  let gustTxt = '', gustWhite=false;
  if (gOk && g>=15){ gustTxt = ` (<em style="color:#e8e8e8">${g.toFixed(1)}</em>)`; gustWhite=true; }
  const meanWhite = (mOk && m>=10);
  const cls = (meanWhite || gustWhite) ? '' : (baseGrey?'soft':'');

  return {
    html:`<div class="${cls}">${txt}${gustTxt}<span class="windDir">${dirText(dirDeg)}</span></div>`,
    val:m
  };
}
function dirText(deg){
  if (deg==null || isNaN(Number(deg))) return '';
  const d = Number(deg);
  const dirs = ['pohjoisesta','koillisesta','idästä','kaakosta','etelästä','lounaasta','lännestä','luoteesta','pohjoisesta'];
  return dirs[Math.round(d/45)];
}
function tempCell(v){
  if (v==null || isNaN(Number(v))) return '–';
  const n = Number(v);
  const cls = (n>25 || n<-15) ? '' : 'soft';
  return `<span class="${cls}">${n.toFixed(0)}&nbsp;°</span>`;
}

/* ---------- rivin tulostus + ditto ---------- */
function pushRow(htmlArr, {timeHtml, temp, descHtml, descWhite, rainObj, rainTag, windObj, prevKeyRef}){
  const desc = (descHtml||'').trim();
  const useDitto = (prevKeyRef.val === desc && desc !== '');
  htmlArr.push(
`<div class="row">
  <div class="t hh">${timeHtml}</div>
  <div class="t">${tempCell(temp)}</div>
  <div class="desc ${descWhite?'':'soft'}">${useDitto ? '<span class="ditto">”</span>' : desc}</div>
  <div class="${rainObj.cls}">${rainObj.text}${tag(rainTag)}</div>
  ${windObj.html}
</div>`);
  if (!useDitto) prevKeyRef.val = desc;
}

/* ---------- pää ---------- */
(async () => {
  try{
    if (!LAT_STR || !LON_STR){ out.innerHTML = `<div class="muted">Anna koordinaatit: ?lat=60.1699&lon=24.9384</div>`; return; }
    out.innerHTML = `<div class="muted">Ladataan…</div>`;

    // MET Norwayn ennuste + nowcast
    const [fRes,ncRes] = await Promise.all([
      fetch(`https://api.met.no/weatherapi/locationforecast/2.0/complete?lat=${LAT}&lon=${LON}`),
      fetch(`https://api.met.no/weatherapi/nowcast/2.0/complete?lat=${LAT}&lon=${LON}`)
    ]);
    if (!fRes.ok) throw new Error(`Ennuste: HTTP ${fRes.status}`);
    const fJson = await fRes.json();
    const ncJson = ncRes.ok ? await ncRes.json() : null;

    // Rakennetaan series-mapit MET-avaimilla
    const ts = fJson?.properties?.timeseries || [];
    const forecast = {
      air_temperature: new Map(),
      wind_speed: new Map(),
      wind_from_direction: new Map(),
      precipitation_amount: new Map(),
      SmartSymbol: new Map()
    };
    for (const it of ts){
      const t = it.time;
      const inst = it.data?.instant?.details || {};
      if (inst.air_temperature!=null) forecast.air_temperature.set(t, inst.air_temperature);
      if (inst.wind_speed!=null) forecast.wind_speed.set(t, inst.wind_speed);
      if (inst.wind_from_direction!=null) forecast.wind_from_direction.set(t, inst.wind_from_direction);

      const n1 = it.data?.next_1_hours;
      if (n1){
        const det = n1.details || {};
        if (det.precipitation_amount!=null) forecast.precipitation_amount.set(t, det.precipitation_amount);
        const sym = n1.summary?.symbol_code; if (sym) forecast.SmartSymbol.set(t, sym);
      }
    }

    // Tuntivalinnat
    const now = new Date();
    const keys = Array.from(forecast.air_temperature.keys()).filter(k => {
      const d = new Date(k);
      // alkaen tästä tasatunnista
      const start = new Date(now); start.setMinutes(0,0,0);
      return d >= start;
    }).slice(0,13); // t0…t+12

    // Nowcast poiminta
    const ncTs = ncJson?.properties?.timeseries || [];
    const findNc = iso => ncTs.find(x => x.time === iso) || null;
    const ncPacks = keys.slice(0,3).map(k => {
      const it = findNc(k);
      if (!it) return null;
      return {
        val: it.data?.next_1_hours?.details?.precipitation_amount ?? null,
        sym: it.data?.next_1_hours?.summary?.symbol_code ?? null,
        gust: it.data?.instant?.details?.wind_speed_of_gust ?? null
      };
    });

    // Päivän auringonajat cacheen (SunCalc)
    const dayObjs = new Map();
    async function dayObjFor(d){
      const y=d.getFullYear(), m=d.getMonth(), da=d.getDate();
      const key = `${y}-${m}-${da}`;
      if (dayObjs.has(key)) return dayObjs.get(key);
      const obj = await fetchSunriseDay(new Date(y,m,da,12,0,0), LAT, LON);
      dayObjs.set(key,obj); return obj;
    }

    const html = [];
    const prevDescRef = { val:null };

    function timeCell(d, opts){
      if (opts?.now) return fmtHM(new Date());
      if (opts?.futureNc) return `<span class="soft">${fmtHM(d)}</span>`;
      return `<span class="mini">klo&nbsp;</span>${fmtH(d)}`;
    }

    async function renderHour(idx){
      const key = keys[idx]; if (!key) return;
      const dUtc = new Date(key);
      const dLoc = new Date(dUtc.toLocaleString('en-CA',{timeZone:TZ}));

      const T = forecast.air_temperature.get(key);
      const W = forecast.wind_speed.get(key);
      const WD = forecast.wind_from_direction.get(key);
      const R = forecast.precipitation_amount.get(key);
      const SYM = forecast.SmartSymbol.get(key);

      const isNow = (idx===0);
      const isFutureNc = (idx===1 || idx===2);

      // sade
      let rObj, rTag, usedRain = null;
      if (isNow || isFutureNc){
        const pack = ncPacks[idx] || null;
        const val = (pack && typeof pack.val==='number') ? pack.val : null;
        if (val!=null && val<0.1){ rObj={text:'—',cls:'soft dash',num:0}; }
        else rObj = rainCell(val);
        rTag='NC'; usedRain = (typeof val==='number'?val:null);
      } else {
        rObj = rainCell(R);
        usedRain = (typeof R==='number'?R:null);
        rTag='HRM';
        // heikko sade <0.3 → harmaaksi (poikkeusluokat jätetään valkoisiksi: thunder/kuurot tms.)
        if (usedRain>0 && usedRain<0.3){
          const b = ncBase(SYM||'');
          const except = ['thunderstorm','rainshowers','sleetshowers','snowshowers','heavyrainshowers'];
          if (!except.includes(b)) rObj.cls = 'soft';
        }
      }

      // tuuli (puuska vain t0 nowcastista)
      const gust = isNow ? (ncPacks[0]?.gust ?? null) : null;
      const windObj = windCell(W, gust, WD, {baseGrey:true});

      // kuvaus: NC t0–t2 jos saatavilla muuten SYM; hämärä/kultainen tunti -logiikka
      const day = await dayObjFor(dLoc);
      const tw = analyzeTwilightForHour(dLoc, day);
      const phase = phaseLabel(tw.phase);

      const descIsClear = (isNow||isFutureNc) ? isNcClear(ncPacks[idx]?.sym) : isNcClear(SYM);
      const golden = (!usedRain || usedRain<0.1) && shouldMarkGolden({start:dLoc, rise:day.sunrise, set:day.sunset, descIsClear});

      let main = null, italic=false, white=false;
      const symText = (isNow||isFutureNc) ? (ncSymbolText(ncPacks[idx]?.sym) || ncSymbolText(SYM)) : (ncSymbolText(SYM));

      if (golden){
        main = 'kultainen tunti'; italic=true;
      } else if (!usedRain || usedRain<0.1){
        if (phase && phase!=='porvarillinen hämärä'){ main = phase; italic=true; }
        else { main = symText || '–'; }
      } else {
        main = symText || '–';
        white = true; // sadetekstit valkoisena
      }

      // tunnisteet (KAPSEILLA, ilman sulkeita)
      const tags = [];
      if (tw.sunEvent){
        tags.push(`${tw.sunEvent.type==='set'?'auringonlasku':'auringonnousu'} ${fmtHM(tw.sunEvent.at)}`);
      } else if (tw.withinChange){
        const lbl = nextLabelFor(tw.withinChange.to);
        if (lbl) tags.push(`${lbl} ${fmtHM(tw.withinChange.at)}`);
      } else if (phase){
        // jos porvarillinen, näytetään vain tunnisteena (ei pääviestinä)
        if (phase==='porvarillinen hämärä') tags.push(phase);
      }
      const descHtml = (italic ? `<em>${main}</em>` : main) + (tags.length? ' '+tags.map(t=>`<span class="miniTag">${t}</span>`).join(' ') : '');

      // aika
      const timeHtml = isNow ? timeCell(dLoc,{now:true})
        : isFutureNc ? timeCell(dLoc,{futureNc:true})
        : timeCell(dLoc,{});

      pushRow(html, { timeHtml, temp:T, descHtml, descWhite:white, rainObj:rObj, rainTag:rTag, windObj:windObj, prevKeyRef:prevDescRef });
    }

    const html = [];
    const prevDescRef = { val:null };
    for (let i=0;i<keys.length && i<13;i++) await renderHour(i);

    out.innerHTML = html.join('') || `<div class="muted">Ei rivejä tälle ikkunalle.</div>`;
  }catch(e){
    out.innerHTML = `<div class="err">${String(e.message||e)}</div>`;
  }
})();
</script>
