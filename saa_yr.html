<!doctype html>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="noindex">
<title>SÄÄ SEURAAVAT 12 h (FMI)</title>
<style>
  :root { color-scheme: dark; }
  html,body{height:100%}
  body{
    margin:0; padding:28px 14px 24px; background:#000; color:#e8e8e8;
    font:17px/1.5 Arial,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility
  }
  .list{ border-top:1px solid #2a2a2a; margin-top:6px; }
  .klohdr{
    color:#5d676f; font-size:12px; letter-spacing:.3px; margin:6px 0 4px 0;
    display:grid; grid-template-columns:54px 64px 1fr 70px 64px;
  }
  .klohdr > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px; }
  .klohdr > div:not(:first-child){ visibility:hidden; }

  .row{
    display:grid; grid-template-columns:54px 64px 1fr 70px 64px;
    gap:8px; padding:6px 0; border-bottom:1px solid #1c1c1c;
  }
  .row > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px; }

  .muted{ color:#515a62 }
  .soft{  color:#515a62 }

  .t{ text-align:left }      /* t0–t2 vasen */
  .t.hh{ text-align:right }  /* ennusterivit oikea */

  .desc .ditto{ display:inline }
  .ditto{ color:inherit }

  .err{ color:#ff6b6b; white-space:pre-wrap }
</style>

<div class="klohdr"><div>klo</div><div></div><div></div><div></div><div></div></div>
<div class="list" id="out" aria-live="polite"></div>

<script>
/* Sade-lähteet:
   - t0: FMI-tutka RR (openwms geoserver, GFI). Jos puuttuu → erikoisfallback (HARMONIE edellisestä tasatunnista, tai harmaa em dash).
   - t1/t2: MET Norway Nowcast 2.0 (api.met.no). Jos puuttuu → HARMONIE harmaana; 0 → “—”.
   - t3→: HARMONIE; 0 → “—”.
   Debug: lisää ?dbg=1 → näyttää lähdetagit (RR / NC / HRM / HRM-prev) sateen solussa.
*/

const q = new URLSearchParams(location.search);
const LAT = parseFloat(q.get('lat'));
const LON = parseFloat(q.get('lon'));
const TZ  = 'Europe/Helsinki';
const out = document.getElementById('out');

const DBG = q.has('dbg');
function srcTag(s){ return DBG ? ` <span class="soft" style="font-size:12px">${s}</span>` : ''; }

/* Aikaformatit */
const hmFi = new Intl.DateTimeFormat('fi-FI',{hour:'2-digit',minute:'2-digit',hour12:false,timeZone:TZ,hourCycle:'h23'});
function fmtHM(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}:${ps.find(p=>p.type==='minute')?.value||'00'}`; }
function fmtH(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}`; }
const partsFmt = new Intl.DateTimeFormat('en-GB',{timeZone:TZ,year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit',hourCycle:'h23'});
function parts(d){ const ps=partsFmt.formatToParts(d); const g=t=>Number(ps.find(p=>p.type===t)?.value); return {y:g('year'),m:g('month'),d:g('day'),h:g('hour'),min:g('minute')}; }

/* SmartSymbol (demo; voit vaihtaa omaan täydelliseen sanakirjaasi) */
const SS_TEXT = {
  1:'Selkeää', 2:'Enimmäkseen selkeää', 4:'Puolipilvistä', 6:'Enimmäkseen pilvistä', 7:'Pilvistä', 9:'Sumua',
  71:'Yksittäisiä ukkoskuuroja', 74:'Paikoin ukkoskuuroja', 77:'Ukkoskuuroja',
  21:'Yksittäisiä sadekuuroja', 24:'Paikoin sadekuuroja', 27:'Sadekuuroja',
  14:'Jäätävää tihkua', 17:'Jäätävää sadetta', 11:'Tihkusadetta',
  31:'Puolipilvistä ja ajoittain heikkoa vesisadetta', 34:'Enimmäkseen pilvistä ja ajoittain heikkoa vesisadetta', 37:'Heikkoa vesisadetta',
  32:'Puolipilvistä ja ajoittain kohtalaista vesisadetta', 35:'Enimmäkseen pilvistä ja ajoittain kohtalaista vesisadetta', 38:'Kohtalaista vesisadetta',
  33:'Puolipilvistä ja ajoittain voimakasta vesisadetta', 36:'Enimmäkseen pilvistä ja ajoittain voimakasta vesisadetta', 39:'Voimakasta vesisadetta'
};
const ssText = c => (c==null?'':(SS_TEXT[Number(c)%100]||''));

/* FMI HARMONIE (malli) */
function buildWfsForecast(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::forecast::harmonie::surface::point::timevaluepair';
  const params='temperature,precipitation1h,windspeedms,SmartSymbol';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-2); e.setHours(e.getHours()+24);
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=60`;
}

/* FMI havainnot (t2m, ws_10min) */
function buildWfsObs(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::observations::weather::timevaluepair';
  const params='t2m,ws_10min';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-3);
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=10`;
}

/* XML → sarjat */
const parseXML = txt => {
  const x = new DOMParser().parseFromString(txt,'application/xml');
  const ex = x.querySelector('Exception, ows\\:Exception');
  if (ex){ const t=x.querySelector('ExceptionText, ows\\:ExceptionText'); throw new Error('FMI virhe: '+(t?t.textContent:'Tuntematon virhe')); }
  return x;
};
const extractSeries = x => {
  const get=(e,n)=>e.getElementsByTagNameNS('*',n)[0];
  const all=x.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTimeseries');
  const o={};
  for (const s of all){
    const id=(s.getAttribute('gml:id')||'').toLowerCase();
    let k='';
    if (id.includes('temperature')) k='temperature';
    else if (id.includes('precipitation1h')) k='precipitation1h';
    else if (id.includes('windspeedms')) k='windspeedms';
    else if (id.includes('smartsymbol')) k='SmartSymbol';
    else if (id.includes('t2m')) k='t2m';
    else if (id.includes('ws_10min')) k='ws_10min';
    if (!k) continue;
    const map=new Map();
    const pts=s.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTVP');
    for (const p of pts){
      const t=get(p,'time')?.textContent;
      const v=get(p,'value')?.textContent;
      if (!t) continue;
      const num = v!=null ? Number(v) : null;
      map.set(t, isNaN(num)?null:num);
    }
    o[k]=map;
  }
  return o;
};

/* Tutka RR (FMI openwms geoserver → WMS GetFeatureInfo) */
function wmsRRUrl(lat, lon, pad=0.2){
  const service='https://openwms.fmi.fi/geoserver/Radar/wms';
  const L='radar:composite:rr';
  const minLat=lat-pad, maxLat=lat+pad, minLon=lon-pad, maxLon=lon+pad;
  const WIDTH=121, HEIGHT=121, I=60, J=60;
  const qs = new URLSearchParams({
    service:'WMS', request:'GetFeatureInfo', version:'1.3.0',
    layers:L, query_layers:L, styles:'',
    crs:'EPSG:4326',
    bbox:`${minLat},${minLon},${maxLat},${maxLon}`,
    width:String(WIDTH), height:String(HEIGHT),
    i:String(I), j:String(J),
    info_format:'text/plain',
    time:'latest'
  });
  return `${service}?${qs.toString()}`;
}
async function fetchRadarRR(lat, lon, timeoutMs=9000){
  async function once(pad){
    const ctrl=new AbortController();
    const t=setTimeout(()=>ctrl.abort(),timeoutMs);
    try{
      const res=await fetch(wmsRRUrl(lat,lon,pad),{cache:'no-store',signal:ctrl.signal});
      const txt=await res.text();
      clearTimeout(t);
      if (!res.ok) return { val:null, meta:`RR!${res.status}` };
      if (/nan|none|nodata/i.test(txt)) return { val:null, meta:'RR!nodata' };
      const m = txt.match(/([-+]?\d+(?:\.\d+)?)/);
      if (!m) return { val:null, meta:'RR!parse' };
      const v = Number(m[1]);
      return isNaN(v) ? { val:null, meta:'RR!nan' } : { val:v, meta:'RR' };
    }catch{ clearTimeout(t); return { val:null, meta:'RR!err' }; }
  }
  const a = await once(0.2);
  if (a.val!=null) return a;
  return await once(0.3);
}

/* NOWCAST (api.met.no/weatherapi/nowcast/2.0) — sateen rate mm/h 0–2 h, 5 min välein.
   Palauttaa pyydetylle tasatunnille lähimmän aikaleiman arvon, jos etäisyys ≤ 10 min. */
async function fetchNowcastForHour(lat, lon, dLocal){
  try{
    const url = `https://api.met.no/weatherapi/nowcast/2.0?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}`;
    const res = await fetch(url, { cache:'no-store', headers: { 'Accept': 'application/json' } });
    if (!res.ok) return { val:null, meta:`NC!${res.status}` };
    const js = await res.json();
    const ts = js?.properties?.timeseries;
    if (!Array.isArray(ts) || !ts.length) return { val:null, meta:'NC!empty' };

    const targetUTC = new Date(Date.UTC(
      dLocal.getFullYear(), dLocal.getMonth(), dLocal.getDate(), dLocal.getHours(), 0, 0
    ));
    let best=null, bestDiff=1e15;
    for (const it of ts){
      const t = new Date(it.time);
      const diff = Math.abs(t - targetUTC);
      if (diff < bestDiff){ bestDiff = diff; best = it; }
    }
    if (!best || bestDiff > 10*60*1000) return { val:null, meta:'NC!miss' };

    const pr = best?.data?.instant?.details?.precipitation_rate;
    if (typeof pr === 'number') return { val:pr, meta:'NC' };

    const acc = best?.data?.next_1_hours?.details?.precipitation_amount;
    if (typeof acc === 'number') return { val:acc, meta:'NC' };

    return { val:null, meta:'NC!nodata' };
  }catch{ return { val:null, meta:'NC!err' }; }
}

/* Lähin havainto hetkeen (obs) */
function nearestObs(mapUTC, targetLocalDate, maxDiffMin=20){
  if (!mapUTC) return null;
  const targetUTC = new Date(Date.UTC(
    targetLocalDate.getFullYear(), targetLocalDate.getMonth(), targetLocalDate.getDate(),
    targetLocalDate.getHours(), targetLocalDate.getMinutes(), 0
  ));
  let bestKey=null, bestDiff=1e12;
  for (const k of mapUTC.keys()){
    const d=new Date(k);
    const diff=Math.abs(d - targetUTC)/60000;
    if (diff < bestDiff){ bestDiff=diff; bestKey=k; }
  }
  if (bestKey && bestDiff <= maxDiffMin) return mapUTC.get(bestKey);
  return null;
}

/* Sade-solun muotoilu:
   - null/undefined → '–' (harmaa)
   - 0 → em dash — (valkoinen)
   - >0 → n.mm (valkoinen), tai harmaana jos markGrey=true
*/
function rainCell(val, {markGrey=false, forceGreyDash=false}={}){
  if (val==null || isNaN(Number(val))) return { text:'–', cls:'soft' };
  const n = Number(val);
  if (n === 0){
    return { text:'—', cls: (forceGreyDash ? 'soft' : '') };
  }
  return { text:n.toFixed(1) + ' mm', cls:(markGrey ? 'soft' : '') };
}

(async function(){
  scrollTo(0,1); setTimeout(()=>scrollTo(0,1),150);
  if (!LAT || !LON || isNaN(LAT) || isNaN(LON)){
    out.innerHTML = `<div class="err">Puuttuvat tai virheelliset koordinaatit. Käytä osoitetta:<br><code>?lat=60.1699&lon=24.9384</code></div>`;
    return;
  }

  try{
    const [fRes, oRes] = await Promise.all([
      fetch(buildWfsForecast(LAT,LON), {cache:'no-store'}),
      fetch(buildWfsObs(LAT,LON), {cache:'no-store'})
    ]);
    const [fTxt, oTxt] = await Promise.all([fRes.text(), oRes.text()]);
    if (!fRes.ok) throw new Error(`FMI ennuste HTTP ${fRes.status}\n${fTxt.slice(0,200)}`);
    if (!oRes.ok) throw new Error(`FMI havainnot HTTP ${oRes.status}\n${oTxt.slice(0,200)}`);

    const forecast = extractSeries(parseXML(fTxt));
    const obs      = extractSeries(parseXML(oTxt));

    const now = new Date();
    const thisHourLocal  = new Date(new Date(now).setMinutes(0,0,0));
    const fKeys = Array.from(forecast.temperature?.keys?.()||[]).sort();

    const pickKeys = [];
    for (const k of fKeys){
      const d = new Date(k);
      if (d >= thisHourLocal){ pickKeys.push(k); if (pickKeys.length>=13) break; }
    }
    if (!pickKeys.length){ out.innerHTML = `<div class="muted">Ei rivejä tälle ikkunalle.</div>`; return; }

    /* Tutka t0 */
    const rrHit = await fetchRadarRR(LAT, LON);
    const rrNow = rrHit.val;
    const rrMeta = rrHit.meta;
    const noRadarFallback = (rrNow == null);

    /* Nowcast t1/t2 */
    const d1 = pickKeys[1] ? new Date(pickKeys[1]) : null;
    const d2 = pickKeys[2] ? new Date(pickKeys[2]) : null;
    const [nc1, nc2] = await Promise.all([
      d1 ? fetchNowcastForHour(LAT, LON, d1) : Promise.resolve({val:null, meta:'NC!skip'}),
      d2 ? fetchNowcastForHour(LAT, LON, d2) : Promise.resolve({val:null, meta:'NC!skip'})
    ]);

    let html = '';
    let prevDesc = null;

    /* t0 (nyt) */
    {
      const key = pickKeys[0];
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fSS   = forecast.SmartSymbol?.get(key);

      const oTemp = nearestObs(obs.t2m, now, 20);
      const oWind = nearestObs(obs.ws_10min, now, 20);

      const tempStr = (oTemp!=null ? Math.round(oTemp)+'°C' : (fTemp!=null?Math.round(fTemp)+'°C':'–'));
      const windStr = (oWind!=null ? oWind.toFixed(1)+' m/s' : (fWind!=null?fWind.toFixed(1)+' m/s':'–'));
      const tempCls = (oTemp!=null?'':'soft');
      const windCls = (oWind!=null?'':'soft');

      let rainObj, rainHtml;
      if (!noRadarFallback){
        rainObj = rainCell(rrNow);
        rainHtml = `${rainObj.text}${srcTag(rrMeta || 'RR')}`;
      }else{
        // Edellinen tasatunti HRM tai harmaa viiva
        const prev = new Date(thisHourLocal); prev.setHours(prev.getHours()-1);
        const prevKey = new Date(Date.UTC(prev.getFullYear(),prev.getMonth(),prev.getDate(),prev.getHours(),0,0)).toISOString().replace(/\.\d{3}Z$/,'Z');
        const fPrevRain = forecast.precipitation1h?.get(prevKey);
        if (fPrevRain!=null && fPrevRain>0){
          rainObj = rainCell(fPrevRain, {markGrey:true});
          rainHtml = `${rainObj.text}${srcTag('HRM-prev')}`;
        }else{
          rainObj = { text:'—', cls:'soft' };
          rainHtml = `${rainObj.text}${srcTag('HRM-prev')}`;
        }
      }

      const desc = ssText(fSS) || '–';

      html += `<div class="row">
        <div class="t">${fmtHM(now)}</div>
        <div class="${tempCls}">${tempStr}</div>
        <div class="desc soft">${desc}</div>
        <div class="${rainObj.cls}">${rainHtml}</div>
        <div class="${windCls}">${windStr}</div>
      </div>`;
      prevDesc = desc;
    }

    /* t+1h */
    if (pickKeys.length >= 2){
      const key = pickKeys[1];
      const dUtc = new Date(key);
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fRain = forecast.precipitation1h?.get(key);
      const fSS   = forecast.SmartSymbol?.get(key);

      const tempStr = (fTemp!=null?Math.round(fTemp)+'°C':'–');
      const windStr = (fWind!=null?fWind.toFixed(1)+' m/s':'–');

      let rainObj, rainHtml;
      if (noRadarFallback){
        // t0 ei saanut tutkaa → t1: harmaa em dash
        rainObj = { text:'—', cls:'soft' };
        rainHtml = `${rainObj.text}${srcTag('HRM-prev')}`;
      } else if (nc1 && nc1.val != null){
        // nowcast osui
        rainObj = rainCell(nc1.val);
        rainHtml = `${rainObj.text}${srcTag('NC')}`;
      } else {
        // nowcast puuttuu → käytä HRM:ää, ja TAGI = HRM (näytä debugissa syy)
        if (fRain == null) {
          rainObj = { text:'–', cls:'soft' };
        } else if (Number(fRain) === 0) {
          // 0 → harmaa em dash HRM-fallbackissa
          rainObj = { text:'—', cls:'soft' };
        } else {
          // >0 → harmaana numero
          rainObj = rainCell(fRain, { markGrey:true });
        }
        const reason = (nc1 && nc1.meta && nc1.meta.startsWith('NC!')) ? ` (${nc1.meta})` : '';
        rainHtml = `${rainObj.text}${srcTag('HRM' + reason)}`;
      }


      const desc = ssText(fSS) || '–';
      const shownDesc = (desc === prevDesc && desc !== '–')
        ? '<span class="ditto" aria-label="sama kuin edellä" title="sama kuin edellä">–»–</span>'
        : desc;

      html += `<div class="row">
        <div class="t">${fmtHM(dUtc)}</div>
        <div class="soft">${tempStr}</div>
        <div class="desc soft">${shownDesc}</div>
        <div class="${rainObj.cls}">${rainHtml}</div>
        <div class="soft">${windStr}</div>
      </div>`;
      prevDesc = desc;
    }

    /* t+2h */
    if (pickKeys.length >= 3){
      const key = pickKeys[2];
      const dUtc = new Date(key);
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fRain = forecast.precipitation1h?.get(key);
      const fSS   = forecast.SmartSymbol?.get(key);

      const tempStr = (fTemp!=null?Math.round(fTemp)+'°C':'–');
      const windStr = (fWind!=null?fWind.toFixed(1)+' m/s':'–');

      let rainObj, rainHtml;
      if (noRadarFallback){
        rainObj = { text:'—', cls:'soft' };
        rainHtml = `${rainObj.text}${srcTag('HRM-prev')}`;
      } else if (nc2 && nc2.val != null){
        rainObj = rainCell(nc2.val);
        rainHtml = `${rainObj.text}${srcTag('NC')}`;
      } else {
        if (fRain == null) {
          rainObj = { text:'–', cls:'soft' };
        } else if (Number(fRain) === 0) {
          // 0 → harmaa em dash HRM-fallbackissa
          rainObj = { text:'—', cls:'soft' };
        } else {
          rainObj = rainCell(fRain, { markGrey:true });
        }
        const reason = (nc2 && nc2.meta && nc2.meta.startsWith('NC!')) ? ` (${nc2.meta})` : '';
        rainHtml = `${rainObj.text}${srcTag('HRM' + reason)}`;
      }


      const desc = ssText(fSS) || '–';
      const shownDesc = (desc === prevDesc && desc !== '–')
        ? '<span class="ditto" aria-label="sama kuin edellä" title="sama kuin edellä">–»–</span>'
        : desc;

      html += `<div class="row">
        <div class="t">${fmtHM(dUtc)}</div>
        <div class="soft">${tempStr}</div>
        <div class="desc soft">${shownDesc}</div>
        <div class="${rainObj.cls}">${rainHtml}</div>
        <div class="soft">${windStr}</div>
      </div>`;
      prevDesc = desc;
    }

    /* 10 ennusteriviä */
    let written = 0;
    for (let i=3; i<pickKeys.length && written<10; i++, written++){
      const key = pickKeys[i];
      const dUtc = new Date(key);
      const temp = forecast.temperature?.get(key);
      const rainVal = forecast.precipitation1h?.get(key);
      const wind = forecast.windspeedms?.get(key);
      const ss   = forecast.SmartSymbol?.get(key);
      const desc = ssText(ss) || '–';

      let rainObj, rainHtml;
      if (rainVal==null){ 
        rainObj = { text:'–', cls:'soft' }; 
        rainHtml = `${rainObj.text}${srcTag('HRM')}`;
      } else if (Number(rainVal)===0){ 
        rainObj = { text:'—', cls:'' }; 
        rainHtml = `${rainObj.text}${srcTag('HRM')}`;
      } else { 
        rainObj = rainCell(rainVal); 
        rainHtml = `${rainObj.text}${srcTag('HRM')}`;
      }

      const shownDesc = (desc === prevDesc && desc !== '–')
        ? '<span class="ditto" aria-label="sama kuin edellä" title="sama kuin edellä">–»–</span>'
        : desc;
      prevDesc = desc;

      html += `<div class="row">
        <div class="t hh">${fmtH(dUtc)}</div>
        <div>${temp!=null?Math.round(temp)+'°C':'–'}</div>
        <div class="desc">${shownDesc}</div>
        <div class="${rainObj.cls}">${rainHtml}</div>
        <div>${wind!=null?wind.toFixed(1)+' m/s':'–'}</div>
      </div>`;
    }

    out.innerHTML = html || `<div class="muted">Ei rivejä tälle ikkunalle.</div>`;
  }catch(e){
    out.innerHTML = `<div class="err">${String(e.message||e)}</div>`;
  }
})();
</script>
