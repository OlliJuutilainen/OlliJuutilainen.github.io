<!doctype html>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="noindex">
<title>SÄÄ SEURAAVAT 12 h</title>
<style>
  :root { color-scheme: dark; }
  html,body{height:100%}
  body{
    margin:0; padding:28px 14px 24px; background:#000; color:#e8e8e8;
    font:17px/1.5 Arial,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility
  }
  .mini{ color:#5d676f; font-size:12px; letter-spacing:.3px }
  .caps{ text-transform:uppercase; letter-spacing:.5px }
  .list{ border-top:1px solid #2a2a2a; margin-top:6px; }

  /* Grid: [time | temp | desc | rain | wind] */
  .klohdr{
    color:#5d676f; font-size:12px; letter-spacing:.3px; margin:6px 0 4px 0;
    display:grid; grid-template-columns:54px 64px 1fr 70px 64px; align-items:end;
  }
  .klohdr > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px; }
  .klohdr > div:nth-child(2), .klohdr > div:nth-child(3){ visibility:hidden } /* ei otsikoita näille */

  .row{
    display:grid; grid-template-columns:54px 64px 1fr 70px 64px;
    gap:8px; padding:6px 0; border-bottom:1px solid #1c1c1c; align-items:center;
  }
  .row > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px; }

  .muted{ color:#515a62 } .soft{ color:#515a62 }
  .t{ text-align:left } .t.hh{ text-align:right }
  .desc .ditto{ display:inline } .ditto{ color:inherit }
  .err{ color:#ff6b6b; white-space:pre-wrap }
</style>

<!-- Otsakerivi: klo | ( ) | ( ) | SADE | TUULI -->
<div class="klohdr">
  <div>klo</div><div></div><div></div>
  <div class="caps">SADE</div>
  <div class="caps">TUULI</div>
</div>
<div class="list" id="out" aria-live="polite"></div>

<script>
/* Lähteet:
   - t0, t+1h, t+2h: MET Norway Nowcast 2.0 (/complete) → sade (mm/h kertymä: next_1_hours.amount, muuten instant rate).
   - t3→t12: FMI HARMONIE (temperature, precipitation1h, windspeedms, SmartSymbol).
   - Havainto (FMI): t0 lämpötila & tuuli, jos tarjolla (t2m, ws_10min).
   Debug: lisää ?dbg=1 → näyttää sateen lähdetagin (NC / HRM / HRM-prev).
*/

const q = new URLSearchParams(location.search);
const LAT = parseFloat(q.get('lat'));
const LON = parseFloat(q.get('lon'));
const TZ  = 'Europe/Helsinki';
const out = document.getElementById('out');

const DBG = q.has('dbg');
function srcTag(s){ return DBG ? ` <span class="soft" style="font-size:12px">${s}</span>` : ''; }

/* Aikaformatit */
const hmFi = new Intl.DateTimeFormat('fi-FI',{hour:'2-digit',minute:'2-digit',hour12:false,timeZone:TZ,hourCycle:'h23'});
function fmtHM(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}:${ps.find(p=>p.type==='minute')?.value||'00'}`; }
function fmtH(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}`; }

/* SmartSymbol – suppea demosanakirja (voit vaihtaa omaasi myöhemmin) */
const SS_TEXT = {
  1:'Selkeää', 2:'Enimmäkseen selkeää', 4:'Puolipilvistä', 6:'Enimmäkseen pilvistä', 7:'Pilvistä', 9:'Sumua',
  71:'Yksittäisiä ukkoskuuroja', 74:'Paikoin ukkoskuuroja', 77:'Ukkoskuuroja',
  21:'Yksittäisiä sadekuuroja', 24:'Paikoin sadekuuroja', 27:'Sadekuuroja',
  14:'Jäätävää tihkua', 17:'Jäätävää sadetta', 11:'Tihkusadetta',
  31:'Puolipilvistä ja ajoittain heikkoa vesisadetta', 34:'Enimmäkseen pilvistä ja ajoittain heikkoa vesisadetta', 37:'Heikkoa vesisadetta',
  32:'Puolipilvistä ja ajoittain kohtalaista vesisadetta', 35:'Enimmäkseen pilvistä ja ajoittain kohtalaista vesisadetta', 38:'Kohtalaista vesisadetta',
  33:'Puolipilvistä ja ajoittain voimakasta vesisadetta', 36:'Enimmäkseen pilvistä ja ajoittain voimakasta vesisadetta', 39:'Voimakasta vesisadetta'
};
const ssText = c => (c==null?'':(SS_TEXT[Number(c)%100]||''));

/* FMI WFS rakennus */
function buildWfsForecast(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::forecast::harmonie::surface::point::timevaluepair';
  const params='temperature,precipitation1h,windspeedms,SmartSymbol';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-2); e.setHours(e.getHours()+24);
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=60`;
}
function buildWfsObs(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::observations::weather::timevaluepair';
  const params='t2m,ws_10min';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-3);
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=10`;
}

/* XML → sarjat */
const parseXML = txt => {
  const x = new DOMParser().parseFromString(txt,'application/xml');
  const ex = x.querySelector('Exception, ows\\:Exception');
  if (ex){ const t=x.querySelector('ExceptionText, ows\\:ExceptionText'); throw new Error('FMI virhe: '+(t?t.textContent:'Tuntematon virhe')); }
  return x;
};
const extractSeries = x => {
  const get=(e,n)=>e.getElementsByTagNameNS('*',n)[0];
  const all=x.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTimeseries');
  const o={};
  for (const s of all){
    const id=(s.getAttribute('gml:id')||'').toLowerCase();
    let k='';
    if (id.includes('temperature')) k='temperature';
    else if (id.includes('precipitation1h')) k='precipitation1h';
    else if (id.includes('windspeedms')) k='windspeedms';
    else if (id.includes('smartsymbol')) k='SmartSymbol';
    else if (id.includes('t2m')) k='t2m';
    else if (id.includes('ws_10min')) k='ws_10min';
    if (!k) continue;
    const map=new Map();
    const pts=s.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTVP');
    for (const p of pts){
      const t=get(p,'time')?.textContent;
      const v=get(p,'value')?.textContent;
      if (!t) continue;
      const num = v!=null ? Number(v) : null;
      map.set(t, isNaN(num)?null:num);
    }
    o[k]=map;
  }
  return o;
};

/* MET Nowcast 2.0 complete → valitse rivi, joka kattaa tavoitetunnin */
async function fetchNowcastForHour(lat, lon, dUTC){
  try{
    const url = `https://api.met.no/weatherapi/nowcast/2.0/complete?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&altitude=0`;
    const res = await fetch(url, { cache:'no-store', headers: { 'Accept': 'application/json' } });
    if (!res.ok) return { val:null, meta:`NC!${res.status}` };
    const js = await res.json();
    const ts = js?.properties?.timeseries;
    if (!Array.isArray(ts) || !ts.length) return { val:null, meta:'NC!empty' };

    const targetUTC = dUTC.getTime();

    let best = ts.find(it => new Date(it.time).getTime() === targetUTC);
    if (!best){
      const fut = ts.map(it=>({t:new Date(it.time).getTime(), it})).filter(x=>x.t>=targetUTC).sort((a,b)=>a.t-b.t)[0];
      if (fut && (fut.t - targetUTC) <= 30*60*1000) best = fut.it;
    }
    if (!best){
      let cand=null, diff=1e12;
      for (const it of ts){ const dt=Math.abs(new Date(it.time).getTime()-targetUTC); if (dt<diff){diff=dt; cand=it;} }
      if (cand && diff <= 20*60*1000) best = cand;
    }
    if (!best) return { val:null, meta:'NC!miss' };

    const acc = best?.data?.next_1_hours?.details?.precipitation_amount;
    if (typeof acc === 'number') return { val:acc, meta:'NC' };
    const pr = best?.data?.instant?.details?.precipitation_rate;
    if (typeof pr === 'number') return { val:pr, meta:'NC' };
    return { val:null, meta:'NC!nodata' };
  }catch{ return { val:null, meta:'NC!err' }; }
}

/* Havainto lähimmästä ajasta (°C ja m/s) */
function nearestObs(mapUTC, targetLocalDate, maxDiffMin=20){
  if (!mapUTC) return null;
  const targetUTC = new Date(Date.UTC(
    targetLocalDate.getFullYear(), targetLocalDate.getMonth(), targetLocalDate.getDate(),
    targetLocalDate.getHours(), targetLocalDate.getMinutes(), 0
  ));
  let bestKey=null, best=1e12;
  for (const k of mapUTC.keys()){
    const d=new Date(k);
    const diff=Math.abs(d - targetUTC)/60000;
    if (diff<best){best=diff; bestKey=k;}
  }
  if (bestKey && best <= maxDiffMin) return mapUTC.get(bestKey);
  return null;
}

/* Sade-solun muotoilu */
function rainCell(val, {markGrey=false}={}){
  if (val==null || isNaN(Number(val))) return { text:'–', cls:'soft' };
  const n = Number(val);
  if (n === 0) return { text:'—', cls: (markGrey ? 'soft' : '') };
  return { text:n.toFixed(1) + ' mm', cls:(markGrey ? 'soft' : '') };
}

(async function(){
  scrollTo(0,1); setTimeout(()=>scrollTo(0,1),150);
  if (!LAT || !LON || isNaN(LAT) || isNaN(LON)){
    out.innerHTML = `<div class="err">Puuttuvat tai virheelliset koordinaatit. Käytä osoitetta:<br><code>?lat=60.1699&lon=24.9384</code></div>`;
    return;
  }

  try{
    const [fRes, oRes] = await Promise.all([
      fetch(buildWfsForecast(LAT,LON), {cache:'no-store'}),
      fetch(buildWfsObs(LAT,LON), {cache:'no-store'})
    ]);
    const [fTxt, oTxt] = await Promise.all([fRes.text(), oRes.text()]);
    if (!fRes.ok) throw new Error(`FMI ennuste HTTP ${fRes.status}\n${fTxt.slice(0,200)}`);
    if (!oRes.ok) throw new Error(`FMI havainnot HTTP ${oRes.status}\n${oTxt.slice(0,200)}`);

    const forecast = extractSeries(parseXML(fTxt));
    const obs      = extractSeries(parseXML(oTxt));

    const now = new Date();
    const thisHourLocal  = new Date(new Date(now).setMinutes(0,0,0));

    /* Nouki 13 tuntia alkaen tästä tasatunnista */
    const fKeys = Array.from(forecast.temperature?.keys?.()||[]).sort();
    const pickKeys = [];
    for (const k of fKeys){
      const d = new Date(k);
      if (d >= thisHourLocal){ pickKeys.push(k); if (pickKeys.length>=13) break; }
    }
    if (!pickKeys.length){ out.innerHTML = `<div class="muted">Ei rivejä tälle ikkunalle.</div>`; return; }

    /* Nowcast t0/t1/t2 (t0 käyttää samaa tuntiavainta kuin mallissa, lähin periodi valitaan funktiossa) */
    const d0 = pickKeys[0] ? new Date(pickKeys[0]) : null;
    const d1 = pickKeys[1] ? new Date(pickKeys[1]) : null;
    const d2 = pickKeys[2] ? new Date(pickKeys[2]) : null;
    const [nc0, nc1, nc2] = await Promise.all([
      d0 ? fetchNowcastForHour(LAT, LON, d0) : Promise.resolve({val:null, meta:'NC!skip'}),
      d1 ? fetchNowcastForHour(LAT, LON, d1) : Promise.resolve({val:null, meta:'NC!skip'}),
      d2 ? fetchNowcastForHour(LAT, LON, d2) : Promise.resolve({val:null, meta:'NC!skip'})
    ]);

    let html = '';
    let prevDesc = null;

    /* t0 (nyt) – sade NC; lämpö & tuuli havainnoista jos mahdollista */
    {
      const key = pickKeys[0];
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fSS   = forecast.SmartSymbol?.get(key);

      const oTemp = nearestObs(obs.t2m, now, 20);
      const oWind = nearestObs(obs.ws_10min, now, 20);

      const tempStr = (oTemp!=null ? Math.round(oTemp)+'°C' : (fTemp!=null?Math.round(fTemp)+'°C':'–'));
      const windStr = (oWind!=null ? oWind.toFixed(1)+' m/s' : (fWind!=null?fWind.toFixed(1)+' m/s':'–'));
      const tempCls = (oTemp!=null?'':'soft');
      const windCls = (oWind!=null?'':'soft');

      let rainObj, rainHtml;
      if (nc0 && typeof nc0.val === 'number'){
        rainObj = rainCell(nc0.val);
        rainHtml = `${rainObj.text}${srcTag('NC')}`;
      }else{
        // fallback: edellinen tasatunti mallista
        const prev = new Date(thisHourLocal); prev.setHours(prev.getHours()-1);
        const prevKey = new Date(Date.UTC(prev.getFullYear(),prev.getMonth(),prev.getDate(),prev.getHours(),0,0)).toISOString().replace(/\.\d{3}Z$/,'Z');
        const fPrevRain = forecast.precipitation1h?.get(prevKey);
        if (fPrevRain!=null && fPrevRain>0){
          rainObj = rainCell(fPrevRain, { markGrey:true });
          rainHtml = `${rainObj.text}${srcTag('HRM-prev')}`;
        }else{
          rainObj = { text:'—', cls:'soft' };
          rainHtml = `${rainObj.text}${srcTag('HRM-prev')}`;
        }
      }

      const desc = ssText(fSS) || '–';

      html += `<div class="row">
        <div class="t">${fmtHM(now)}</div>
        <div class="${tempCls}">${tempStr}</div>
        <div class="desc soft">${desc}</div>
        <div class="${rainObj.cls}">${rainHtml}</div>
        <div class="${windCls}">${windStr}</div>
      </div>`;
      prevDesc = desc;
    }

    /* t+1h */
    if (pickKeys.length >= 2){
      const key = pickKeys[1];
      const dUtc = new Date(key);
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fRain = forecast.precipitation1h?.get(key);
      const fSS   = forecast.SmartSymbol?.get(key);

      const tempStr = (fTemp!=null?Math.round(fTemp)+'°C':'–');
      const windStr = (fWind!=null?fWind.toFixed(1)+' m/s':'–');

      let rainObj, rainHtml;
      if (nc1 && typeof nc1.val === 'number'){
        rainObj = rainCell(nc1.val);
        rainHtml = `${rainObj.text}${srcTag('NC')}`;
      } else {
        if (fRain == null) { rainObj = { text:'–', cls:'soft' }; }
        else if (Number(fRain)===0) { rainObj = { text:'—', cls:'soft' }; }
        else { rainObj = rainCell(fRain, { markGrey:true }); }
        const reason = (nc1 && nc1.meta && nc1.meta.startsWith('NC!')) ? ` (${nc1.meta})` : '';
        rainHtml = `${rainObj.text}${srcTag('HRM'+reason)}`;
      }

      const desc = ssText(fSS) || '–';
      const shownDesc = (desc === prevDesc && desc !== '–')
        ? '<span class="ditto" aria-label="sama kuin edellä" title="sama kuin edellä">–»–</span>'
        : desc;

      html += `<div class="row">
        <div class="t">${fmtHM(dUtc)}</div>
        <div class="soft">${tempStr}</div>
        <div class="desc soft">${shownDesc}</div>
        <div class="${rainObj.cls}">${rainHtml}</div>
        <div class="soft">${windStr}</div>
      </div>`;
      prevDesc = desc;
    }

    /* t+2h */
    if (pickKeys.length >= 3){
      const key = pickKeys[2];
      const dUtc = new Date(key);
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fRain = forecast.precipitation1h?.get(key);
      const fSS   = forecast.SmartSymbol?.get(key);

      const tempStr = (fTemp!=null?Math.round(fTemp)+'°C':'–');
      const windStr = (fWind!=null?fWind.toFixed(1)+' m/s':'–');

      let rainObj, rainHtml;
      if (nc2 && typeof nc2.val === 'number'){
        rainObj = rainCell(nc2.val);
        rainHtml = `${rainObj.text}${srcTag('NC')}`;
      } else {
        if (fRain == null) { rainObj = { text:'–', cls:'soft' }; }
        else if (Number(fRain)===0) { rainObj = { text:'—', cls:'soft' }; }
        else { rainObj = rainCell(fRain, { markGrey:true }); }
        const reason = (nc2 && nc2.meta && nc2.meta.startsWith('NC!')) ? ` (${nc2.meta})` : '';
        rainHtml = `${rainObj.text}${srcTag('HRM'+reason)}`;
      }

      const desc = ssText(fSS) || '–';
      const shownDesc = (desc === prevDesc && desc !== '–')
        ? '<span class="ditto" aria-label="sama kuin edellä" title="sama kuin edellä">–»–</span>'
        : desc;

      html += `<div class="row">
        <div class="t">${fmtHM(dUtc)}</div>
        <div class="soft">${tempStr}</div>
        <div class="desc soft">${shownDesc}</div>
        <div class="${rainObj.cls}">${rainHtml}</div>
        <div class="soft">${windStr}</div>
      </div>`;
      prevDesc = desc;
    }

    /* 10 ennusteriviä: HH + "klo" mini-teksti ennen tuntia; sateessa HRM */
    let written = 0;
    for (let i=3; i<pickKeys.length && written<10; i++, written++){
      const key = pickKeys[i];
      const dUtc = new Date(key);
      const temp = forecast.temperature?.get(key);
      const rainVal = forecast.precipitation1h?.get(key);
      const wind = forecast.windspeedms?.get(key);
      const ss   = forecast.SmartSymbol?.get(key);
      const desc = ssText(ss) || '–';

      let rainObj;
      if (rainVal==null){ rainObj = { text:'–', cls:'soft' }; }
      else if (Number(rainVal)===0){ rainObj = { text:'—', cls:'' }; }
      else { rainObj = rainCell(rainVal); }

      const shownDesc = (desc === prevDesc && desc !== '–')
        ? '<span class="ditto" aria-label="sama kuin edellä" title="sama kuin edellä">–»–</span>'
        : desc;
      prevDesc = desc;

      html += `<div class="row">
        <div class="t hh"><span class="mini">klo&nbsp;</span>${fmtH(dUtc)}</div>
        <div>${temp!=null?Math.round(temp)+'°C':'–'}</div>
        <div class="desc">${shownDesc}</div>
        <div class="${rainObj.cls}">${rainObj.text}${srcTag('HRM')}</div>
        <div>${wind!=null?wind.toFixed(1)+' m/s':'–'}</div>
      </div>`;
    }

    out.innerHTML = html || `<div class="muted">Ei rivejä tälle ikkunalle.</div>`;
  }catch(e){
    out.innerHTML = `<div class="err">${String(e.message||e)}</div>`;
  }
})();
</script>
