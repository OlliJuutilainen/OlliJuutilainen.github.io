<!doctype html>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="noindex">
<title>SÄÄ SEURAAVAT 12 h (FMI)</title>
<style>
  :root { color-scheme: dark; }
  html,body{height:100%}
  body{
    margin:0; padding:28px 14px 24px; background:#000; color:#e8e8e8;
    font:17px/1.5 Arial,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility
  }
  .row{
    display:grid; grid-template-columns:54px 64px 1fr 70px 64px;
    gap:8px; padding:6px 0; border-bottom:1px solid #1c1c1c;
  }
  .muted{ color:#95a0aa }
  .err{ color:#ff6b6b; white-space:pre-wrap }
</style>

<div id="out" aria-live="polite"></div>

<script>
/* FMI super-min: seuraavat 12 h
   - Aika HH:MM (pakotettu kaksoispiste)
   - Peräkkäiset samat kuvaukset piilotetaan
   - Koordinaatit vain URL:sta (?lat=...&lon=...)
*/
const q = new URLSearchParams(location.search);
const LAT = q.get('lat');
const LON = q.get('lon');
const TZ  = 'Europe/Helsinki';

const out = document.getElementById('out');

// Aika: pakota aina HH:MM kaksoispisteellä
const tFmt = new Intl.DateTimeFormat('fi-FI', {
  hour:'2-digit', minute:'2-digit', hour12:false, timeZone:TZ, hourCycle:'h23'
});
function fmtHM(d){
  const parts = tFmt.formatToParts(d);
  const hh = parts.find(p=>p.type==='hour')?.value ?? '00';
  const mm = parts.find(p=>p.type==='minute')?.value ?? '00';
  return `${hh}:${mm}`;
}

// Weathersymbol3 → lyhyt FI-teksti (pidetään entisellään)
const sym = code => ({
  1:'selkeää', 2:'hattaraa', 3:'pilvistä',
  21:'sumua', 22:'utua',
  41:'kuurohkoja', 42:'kuuroja', 43:'isokuuroja',
  61:'ripsii', 62:'sataa', 63:'esteriltä',
  71:'hiutaloi', 72:'lunta', 73:'pyryttää',
  80:'ukkosta', 95:'ukkoskuuroja'
})[code] || '';

// Pyyntö FMI:lle (12 h ikkuna)
function buildUrl(lat, lon){
  const base = 'https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq   = 'fmi::forecast::harmonie::surface::point::timevaluepair';
  const params = 'temperature,precipitation1h,windspeedms,Weathersymbol3';
  const now = new Date(), end = new Date(now); end.setHours(end.getHours()+12);
  const iso = d => d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(now))}&endtime=${encodeURIComponent(iso(end))}&timestep=60`;
}

const parseXML = txt => {
  const x = new DOMParser().parseFromString(txt, 'application/xml');
  const ex = x.querySelector('Exception, ows\\:Exception');
  if (ex) {
    const t = x.querySelector('ExceptionText, ows\\:ExceptionText');
    throw new Error('FMI virhe: ' + (t ? t.textContent : 'Tuntematon virhe'));
  }
  return x;
};

const extract = x => {
  const get = (e,n)=>e.getElementsByTagNameNS('*',n)[0];
  const all = x.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTimeseries');
  const o = {};
  for (const s of all) {
    const id = (s.getAttribute('gml:id') || '').toLowerCase();
    let k = '';
    if      (id.includes('temperature'))      k = 'temperature';
    else if (id.includes('precipitation1h'))  k = 'precipitation1h';
    else if (id.includes('windspeedms'))      k = 'windspeedms';
    else if (id.includes('weathersymbol3'))   k = 'Weathersymbol3';
    if (!k) continue;
    const map = new Map();
    for (const p of s.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTVP')){
      const t = get(p,'time')?.textContent;
      const v = get(p,'value')?.textContent;
      if (!t) continue;
      const num = v!=null ? Number(v) : null;
      map.set(t, isNaN(num) ? null : num);
    }
    o[k] = map;
  }
  return o;
};

function fetchWithTimeout(ms=9000){
  const ctrl = new AbortController();
  const t = setTimeout(()=>ctrl.abort(), ms);
  return { signal: ctrl.signal, clear: ()=>clearTimeout(t) };
}

(async () => {
  // pikkutemppu: koita pudottaa osoitepalkki heti
  scrollTo(0,1); setTimeout(()=>scrollTo(0,1), 150);

  if (!LAT || !LON) {
    out.innerHTML = `<div class="err">Puuttuvat koordinaatit. Käytä osoitetta muodossa:<br>
<code>?lat=60.1699&lon=24.9384</code></div>`;
    return;
  }

  try{
    const t = fetchWithTimeout(9000);
    const res = await fetch(buildUrl(LAT, LON), { cache:'no-store', signal: t.signal });
    t.clear();
    const txt = await res.text();
    if (!res.ok) throw new Error(`HTTP ${res.status}\n${txt.slice(0,200)}`);

    const ser = extract(parseXML(txt));

    const now = new Date(), end = new Date(now); end.setHours(end.getHours()+12);

    let html = '';
    let prevDesc = null; // peräkkäisten kuvausten piilottamiseen

    for (let d = new Date(now); d <= end; d.setHours(d.getHours()+1)) {
      // Muodosta FMI:n UTC-ISO ilman millisekunteja
      const utc = new Date(Date.UTC(
        d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours()
      )).toISOString().replace(/\.\d{3}Z$/,'Z');

      const temp = ser.temperature?.get(utc);
      const rain = ser.precipitation1h?.get(utc);
      const wind = ser.windspeedms?.get(utc);
      const wsym = ser.Weathersymbol3?.get(utc);

      const desc = sym(wsym) || '';
      const shownDesc = (desc === prevDesc) ? '' : desc;
      prevDesc = desc;

      html += `<div class="row">
        <div>${fmtHM(new Date(d))}</div>
        <div>${temp!=null ? Math.round(temp) + '°C' : '–'}</div>
        <div>${shownDesc}</div>
        <div>${rain!=null ? rain.toFixed(1) + ' mm' : '–'}</div>
        <div>${wind!=null ? wind.toFixed(1) + ' m/s' : '–'}</div>
      </div>`;
    }

    out.innerHTML = html || `<div class="muted">Ei rivejä tälle ajalle.</div>`;
  } catch (e) {
    out.innerHTML = `<div class="err">${String(e.message || e)}</div>`;
  }
})();
</script>
