<!doctype html>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="noindex">
<title>SÄÄ SEURAAVAT 12 TUNTIA (FMI)</title>
<style>
  :root { color-scheme: dark; }
  html,body{height:100%}
  body{
    margin:0; padding:28px 14px 24px; background:#000; color:#e8e8e8;
    font:17px/1.5 Arial,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility
  }
  .list{ border-top:1px solid #2a2a2a; margin-top:6px; }
  .klohdr{
    color:#9aa; font-size:12px; letter-spacing:.3px; margin:6px 0 4px 0;
    display:grid; grid-template-columns:54px 64px 1fr 70px 64px;
  }
  .klohdr > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px; }
  .klohdr > div:not(:first-child){ visibility:hidden; }
  .row{
    display:grid; grid-template-columns:54px 64px 1fr 70px 64px;
    gap:8px; padding:6px 0; border-bottom:1px solid #1c1c1c;
  }
  .row > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px; }
  .muted{ color:#95a0aa } .err{ color:#ff6b6b; white-space:pre-wrap }
  .soft{ color:#9aa }               /* harmaannus malliarvoille a/b/c-riveillä */
  .desc .ditto{ display:block; text-align:center; }
  .ditto{ color:#9aa }              /* jos käytät –»– -dittoa jossain kohtaa */
</style>

<div class="klohdr"><div>klo</div><div></div><div></div><div></div><div></div></div>
<div class="list" id="out" aria-live="polite"></div>

<script>
/* Sekoitusmalli:
   a) prevHour HH:00 → RR (tutka), T/tuuli havainnoista, kuvaus SS harmaana
   b) nyt HH:MM → RR (tutka), T/tuuli havainnoista, kuvaus SS harmaana
   c) nextHour HH:00 → RR (persist nyt), T/tuuli mallista (harmaana), kuvaus SS harmaana
   d) loput tasatunnein mallista normaalisti (valkoisena)
   Ei WS3:aa, ei sade-fallbackia; SS-tekstit sinun sanakirjasta.
*/

const q = new URLSearchParams(location.search);
const LAT = parseFloat(q.get('lat'));
const LON = parseFloat(q.get('lon'));
const TZ  = 'Europe/Helsinki';
const out = document.getElementById('out');

/* Aikaformatit */
const hmFi = new Intl.DateTimeFormat('fi-FI',{hour:'2-digit',minute:'2-digit',hour12:false,timeZone:TZ,hourCycle:'h23'});
function fmtHM(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}:${ps.find(p=>p.type==='minute')?.value||'00'}`; }
const partsFmt = new Intl.DateTimeFormat('en-GB',{timeZone:TZ,year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit',hourCycle:'h23'});
function parts(d){ const ps=partsFmt.formatToParts(d); const g=t=>Number(ps.find(p=>p.type===t)?.value); return {y:g('year'),m:g('month'),d:g('day'),h:g('hour'),min:g('minute')}; }
const idOf = p => ((p.y*100+p.m)*100+p.d)*100 + p.h;

/* SmartSymbol-sanakirja (tiivistetty tähän – käytä aiempaa täydellistä listaa tarvittaessa) */
const SS_TEXT = {
  1:'Selkeää', 2:'Enimmäkseen selkeää', 4:'Puolipilvistä', 6:'Enimmäkseen pilvistä', 7:'Pilvistä', 9:'Sumua',
  71:'Yksittäisiä ukkoskuuroja', 74:'Paikoin ukkoskuuroja', 77:'Ukkoskuuroja',
  21:'Yksittäisiä sadekuuroja', 24:'Paikoin sadekuuroja', 27:'Sadekuuroja',
  14:'Jäätävää tihkua', 17:'Jäätävää sadetta', 11:'Tihkusadetta',
  31:'Puolipilvistä ja ajoittain heikkoa vesisadetta', 34:'Enimmäkseen pilvistä ja ajoittain heikkoa vesisadetta', 37:'Heikkoa vesisadetta',
  32:'Puolipilvistä ja ajoittain kohtalaista vesisadetta', 35:'Enimmäkseen pilvistä ja ajoittain kohtalaista vesisadetta', 38:'Kohtalaista vesisadetta',
  33:'Puolipilvistä ja ajoittain voimakasta vesisadetta', 36:'Enimmäkseen pilvistä ja ajoittain voimakasta vesisadetta', 39:'Voimakasta vesisadetta',
  41:'Puolipilvistä ja ajoittain heikkoa räntäsadetta tai räntäkuuroja', 44:'Enimmäkseen pilvistä ja ajoittain heikkoa räntäsadetta tai räntäkuuroja', 47:'Heikkoa räntäsadetta',
  42:'Puolipilvistä ja ajoittain kohtalaista räntäsadetta tai räntäkuuroja', 45:'Enimmäkseen pilvistä ja ajoittain kohtalaista räntäsadetta tai räntäkuuroja', 48:'Kohtalaista räntäsadetta',
  43:'Puolipilvistä ja ajoittain voimakasta räntäsadetta tai räntäkuuroja', 46:'Enimmäkseen pilvistä ja ajoittain voimakasta räntäsadetta tai räntäkuuroja', 49:'Voimakasta räntäsadetta',
  51:'Puolipilvistä ja ajoittain heikkoa lumisadetta tai lumikuuroja', 54:'Enimmäkseen pilvistä ja ajoittain heikkoa lumisadetta tai lumikuuroja', 57:'Heikkoa lumisadetta',
  52:'Puolipilvistä ja ajoittain kohtalaista lumisadetta tai lumikuuroja', 55:'Enimmäkseen pilvistä ja ajoittain kohtalaista lumisadetta tai lumikuuroja', 58:'Kohtalaista lumisadetta',
  53:'Puolipilvistä ja ajoittain sakeaa lumisadetta tai lumikuuroja', 56:'Enimmäkseen pilvistä ja ajoittain sakeaa lumisadetta tai lumikuuroja', 59:'Runsasta lumisadetta',
  61:'Yksittäisiä raekuuroja', 64:'Paikoin raekuuroja', 67:'Raekuuroja'
};
const ssText = c => (c==null?'':(SS_TEXT[Number(c)%100]||''));

/* FMI HARMONIE (malli) */
function buildWfsForecast(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::forecast::harmonie::surface::point::timevaluepair';
  const params='temperature,precipitation1h,windspeedms,SmartSymbol';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-2); e.setHours(e.getHours()+24);
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=60`;
}

/* FMI havainnot (t2m, ws_10min) – lähin kohta lat/lonissa */
function buildWfsObs(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::observations::weather::timevaluepair';
  const params='t2m,ws_10min';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-3); // 3h taakse, löytyy prevHour ja nyt
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=10`;
}

/* XML parsiminen (Forecast & Obs) */
const parseXML = txt => {
  const x = new DOMParser().parseFromString(txt,'application/xml');
  const ex = x.querySelector('Exception, ows\\:Exception');
  if (ex){ const t=x.querySelector('ExceptionText, ows\\:ExceptionText'); throw new Error('FMI virhe: '+(t?t.textContent:'Tuntematon virhe')); }
  return x;
};
const extractSeries = x => {
  const get=(e,n)=>e.getElementsByTagNameNS('*',n)[0];
  const all=x.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTimeseries');
  const o={};
  for (const s of all){
    const id=(s.getAttribute('gml:id')||'').toLowerCase();
    let k='';
    if (id.includes('temperature')) k='temperature';
    else if (id.includes('precipitation1h')) k='precipitation1h';
    else if (id.includes('windspeedms')) k='windspeedms';
    else if (id.includes('smartsymbol')) k='SmartSymbol';
    else if (id.includes('t2m')) k='t2m';
    else if (id.includes('ws_10min')) k='ws_10min';
    if (!k) continue;
    const map=new Map();
    const pts=s.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTVP');
    for (const p of pts){
      const t=get(p,'time')?.textContent;
      const v=get(p,'value')?.textContent;
      if (!t) continue;
      const num = v!=null ? Number(v) : null;
      map.set(t, isNaN(num)?null:num);
    }
    o[k]=map;
  }
  return o;
};

/* Tutka RR: WMS GetFeatureInfo keskikohdasta */
function wmsRRUrl(lat, lon){
  const service='https://opendata.fmi.fi/wms';
  const L='radar:composite:rr';
  const pad=0.1, minLat=lat-pad, maxLat=lat+pad, minLon=lon-pad, maxLon=lon+pad;
  const WIDTH=101, HEIGHT=101, I=50, J=50;
  const qs = new URLSearchParams({
    service:'WMS', request:'GetFeatureInfo', version:'1.3.0',
    layers:L, query_layers:L, styles:'',
    crs:'EPSG:4326',
    bbox:`${minLat},${minLon},${maxLat},${maxLon}`,
    width:String(WIDTH), height:String(HEIGHT),
    i:String(I), j:String(J),
    info_format:'text/plain',
    time:'latest'
  });
  return `${service}?${qs.toString()}`;
}
async function fetchRadarRR(lat, lon, timeoutMs=6000){
  try{
    const ctrl=new AbortController(); const t=setTimeout(()=>ctrl.abort(),timeoutMs);
    const res=await fetch(wmsRRUrl(lat,lon),{cache:'no-store',signal:ctrl.signal});
    clearTimeout(t);
    const txt=await res.text();
    if (!res.ok) throw new Error(`WMS ${res.status}`);
    const m = txt.match(/([-+]?\d+(?:\.\d+)?)/);
    if (m){ const v=Number(m[1]); return isNaN(v)?null:v; }
    return null;
  }catch(_e){ return null; }
}

/* Apu: hae lähin havaintohetki annetulle paikalliselle minuutille (t0 = now, a = prevHour) */
function nearestObs(mapUTC, targetLocalDate, maxDiffMin=20){
  if (!mapUTC) return null;
  // etsi lähin aikaleima (UTC), vertaamalla targetLocalDate (TZ) muutettuna UTC:ksi
  const targetUTC = new Date(Date.UTC(
    targetLocalDate.getFullYear(), targetLocalDate.getMonth(), targetLocalDate.getDate(),
    targetLocalDate.getHours(), targetLocalDate.getMinutes(), 0
  ));
  let bestKey=null, bestDiff=1e12;
  for (const k of mapUTC.keys()){
    const d=new Date(k);
    const diff=Math.abs(d - targetUTC)/60000; // min
    if (diff < bestDiff){ bestDiff=diff; bestKey=k; }
  }
  if (bestKey && bestDiff <= maxDiffMin) return mapUTC.get(bestKey);
  return null;
}

(async function(){
  scrollTo(0,1); setTimeout(()=>scrollTo(0,1),150);
  if (!LAT || !LON || isNaN(LAT) || isNaN(LON)){
    out.innerHTML = `<div class="err">Puuttuvat tai virheelliset koordinaatit. Käytä osoitetta:<br><code>?lat=60.1699&lon=24.9384</code></div>`;
    return;
  }

  try{
    // Hae malli + havainnot + tutka
    const [fRes, oRes] = await Promise.all([
      fetch(buildWfsForecast(LAT,LON), {cache:'no-store'}),
      fetch(buildWfsObs(LAT,LON), {cache:'no-store'})
    ]);
    const [fTxt, oTxt] = await Promise.all([fRes.text(), oRes.text()]);
    if (!fRes.ok) throw new Error(`FMI ennuste HTTP ${fRes.status}\n${fTxt.slice(0,200)}`);
    if (!oRes.ok) throw new Error(`FMI havainnot HTTP ${oRes.status}\n${oTxt.slice(0,200)}`);

    const forecast = extractSeries(parseXML(fTxt));
    const obs      = extractSeries(parseXML(oTxt));

    const now = new Date();
    const pN  = parts(now);
    const prevHourLocal = new Date(new Date(now).setMinutes(0,0,0));       // floor HH:00
    const nextHourLocal = new Date(new Date(prevHourLocal).setHours(prevHourLocal.getHours()+1));

    // Luo listat ennustekeyt: alkaen prevHour → seuraavat (otetaan riittävästi)
    const fKeys = Array.from(forecast.temperature?.keys?.()||[]).sort();
    const pickKeys = [];
    const startId = idOf({y:pN.y,m:pN.m,d:pN.d,h:prevHourLocal.getHours(),min:0});
    for (const k of fKeys){
      const pid = idOf(parts(new Date(k)));
      if (pid >= startId){ pickKeys.push(k); if (pickKeys.length>=14) break; } // prevHour + 13 lisää
    }
    if (!pickKeys.length){ out.innerHTML = `<div class="muted">Ei rivejä tälle ikkunalle.</div>`; return; }

    // Tutkan RR (mm/h) – käytetään a,b,c
    const rr = await fetchRadarRR(LAT, LON); // voi olla null

    let html = '';
    let prevDesc = null;

    // --- a) prevHour HH:00 (käytä pickKeys[0])
    {
      const key = pickKeys[0];
      const dUtc = new Date(key);
      // Malli
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fRain = forecast.precipitation1h?.get(key);
      const fSS   = forecast.SmartSymbol?.get(key);
      // Havainnot (lähin prevHourLocal)
      const oTemp = nearestObs(obs.t2m, prevHourLocal, 30);      // t2m 10 min välein
      const oWind = nearestObs(obs.ws_10min, prevHourLocal, 30); // m/s 10 min välein
      const tempStr = (oTemp!=null ? Math.round(oTemp)+'°C' : (fTemp!=null?Math.round(fTemp)+'°C':'–'));
      const windStr = (oWind!=null ? oWind.toFixed(1)+' m/s' : (fWind!=null?fWind.toFixed(1)+' m/s':'–'));
      const tempCls = (oTemp!=null?'':'soft');
      const windCls = (oWind!=null?'':'soft');

      const rainVal = (rr!=null ? rr : fRain);
      const rainStr = (rainVal!=null ? rainVal.toFixed(1)+' mm' : '–');
      const desc    = ssText(fSS) || '–';

      html += `<div class="row">
        <div>${fmtHM(prevHourLocal)}</div>
        <div class="${tempCls}">${tempStr}</div>
        <div class="desc soft">${desc}</div>
        <div>${rainStr}</div>
        <div class="${windCls}">${windStr}</div>
      </div>`;
      prevDesc = desc;
    }

    // --- b) nyt HH:MM (käytä mallin nykyistä tasatuntia, mutta aika = nyt)
    {
      const key = pickKeys[0]; // sama tunnin “bucket”
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fSS   = forecast.SmartSymbol?.get(key);

      const oTemp = nearestObs(obs.t2m, now, 20);
      const oWind = nearestObs(obs.ws_10min, now, 20);
      const tempStr = (oTemp!=null ? Math.round(oTemp)+'°C' : (fTemp!=null?Math.round(fTemp)+'°C':'–'));
      const windStr = (oWind!=null ? oWind.toFixed(1)+' m/s' : (fWind!=null?fWind.toFixed(1)+' m/s':'–'));
      const tempCls = (oTemp!=null?'':'soft');
      const windCls = (oWind!=null?'':'soft');

      const rainVal = (rr!=null ? rr : forecast.precipitation1h?.get(key));
      const rainStr = (rainVal!=null ? rainVal.toFixed(1)+' mm' : '–');
      const desc    = ssText(fSS) || '–';

      html += `<div class="row">
        <div>${fmtHM(now)}</div>
        <div class="${tempCls}">${tempStr}</div>
        <div class="desc soft">${desc}</div>
        <div>${rainStr}</div>
        <div class="${windCls}">${windStr}</div>
      </div>`;
      prevDesc = desc;
    }

    // --- c) nextHour HH:00 (pickKeys[1]); sade = rr persist, T/tuuli mallista (harmaana)
    if (pickKeys.length >= 2){
      const key = pickKeys[1];
      const dUtc = new Date(key);
      const fTemp = forecast.temperature?.get(key);
      const fWind = forecast.windspeedms?.get(key);
      const fRain = forecast.precipitation1h?.get(key);
      const fSS   = forecast.SmartSymbol?.get(key);

      const tempStr = (fTemp!=null?Math.round(fTemp)+'°C':'–');
      const windStr = (fWind!=null?fWind.toFixed(1)+' m/s':'–');
      const rainVal = (rr!=null ? rr : fRain);
      const rainStr = (rainVal!=null ? rainVal.toFixed(1)+' mm' : '–');
      const desc    = ssText(fSS) || '–';

      html += `<div class="row">
        <div>${fmtHM(dUtc)}</div>
        <div class="soft">${tempStr}</div>
        <div class="desc soft">${desc}</div>
        <div>${rainStr}</div>
        <div class="soft">${windStr}</div>
      </div>`;
      prevDesc = desc;
    }

    // --- d) loput ennusterivit (jatka pickKeys[2..] → otetaan yhteensä 13 riviä)
    for (let i=2; i<pickKeys.length && (i<=12); i++){
      const key = pickKeys[i];
      const dUtc = new Date(key);
      const temp = forecast.temperature?.get(key);
      const rain = forecast.precipitation1h?.get(key);
      const wind = forecast.windspeedms?.get(key);
      const ss   = forecast.SmartSymbol?.get(key);
      const desc = ssText(ss) || '–';

      // dedup (älä piilota ‘–’)
      const shownDesc = (desc === prevDesc && desc !== '–') ? '' : desc;
      prevDesc = desc;

      html += `<div class="row">
        <div>${fmtHM(dUtc)}</div>
        <div>${temp!=null?Math.round(temp)+'°C':'–'}</div>
        <div class="desc">${shownDesc}</div>
        <div>${rain!=null?rain.toFixed(1)+' mm':'–'}</div>
        <div>${wind!=null?wind.toFixed(1)+' m/s':'–'}</div>
      </div>`;
    }

    out.innerHTML = html || `<div class="muted">Ei rivejä tälle ikkunalle.</div>`;
  }catch(e){
    out.innerHTML = `<div class="err">${String(e.message||e)}</div>`;
  }
})();
</script>
