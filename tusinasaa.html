<!doctype html>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="noindex">
<title>TUSINASÄÄ 12</title>
<style>
  :root { color-scheme: dark; }
  html,body{height:100%}
  body{
    margin:0; padding:22px 14px 24px; background:#000; color:#e8e8e8;
    font:17px/1.5 Arial,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility
  }

  /* Sivun näkyvä otsikko (näytetään vain Asola-koordinaateilla) */
  .pageTitle{
    font-weight:700; font-size:15px; letter-spacing:.4px; color:#9aa6b0;
    text-transform:uppercase; margin:0 0 4px 0
  }

  .mini{ color:#7a858e; font-size:12px; letter-spacing:.3px; line-height:1.2 }
  .miniW{ color:#e8e8e8; font-size:12px; letter-spacing:.3px; line-height:1.2 }
  .caps{ text-transform:uppercase; letter-spacing:.5px }
  .list{ border-top:1px solid #2a2a2a; margin-top:6px; }

  /* Grid: [time | temp | desc | rain | wind] */
  .hdr{
    color:#6b7580; font-size:12px; letter-spacing:.3px; margin:6px 0 4px 0;
    display:grid; grid-template-columns:54px 56px 1fr 70px 76px; align-items:end;
    justify-items: center;
  }
  .hdr div:nth-child(-n+3){ justify-self: start; text-align: left; }
  .hdr div:nth-child(4), .hdr div:nth-child(5){ text-align:center }

  .row{
    display:grid; grid-template-columns:54px 56px 1fr 70px 76px;
    gap:8px; padding:6px 0; border-bottom:1px solid #1c1c1c; align-items:center;
  }
  .row > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px; }

  .muted{ color:#74808a } .soft{ color:#7f8a93 }
  .t{ text-align:left } .t.hh{ text-align:right }
  .row > div:nth-child(4){ text-align:center } /* sade-sarake keskelle */

  .desc .ditto{ display:inline } .ditto{ color:inherit } /* pelkkä » */
  .dash{ text-align:center } /* 0-sade keskelle */

  .windDir{ display:block; margin-top:2px }  /* tuulensuunta pienellä rivillä */
  .err{ color:#ff6b6b; white-space:pre-wrap }
</style>

<!-- Näkyvä sivuotsikko: näytetään vain Asola-koordinaateilla -->
<h1 id="pageTitle" class="pageTitle" style="display:none"></h1>

<div class="hdr">
  <div></div><div></div><div></div>
  <div class="caps">SADE</div>
  <div class="caps">TUULI</div>
</div>
<div class="list" id="out" aria-live="polite"></div>

<script>
/* NC symboli vain t0 (nyt). t1–t2 kuvaus HRM:stä (sulut, kursiivi, ?);
   valkoinen vain jos NC-sade > 0.
   Tuulen suunta (FMI winddirection) näytetään pienellä rivillä: pohjoinen, koillinen, itä, kaakko, etelä, lounas, länsi, luode.
   Keskituuli korostuu valkoisena jo ≥10 m/s; puuska kursiivina suluissa, jos ≥15 m/s. */

const q = new URLSearchParams(location.search);
const LAT_STR = q.get('lat');
const LON_STR = q.get('lon');
const LAT = parseFloat(LAT_STR);
const LON = parseFloat(LON_STR);
const TZ  = 'Europe/Helsinki';
const DBG = q.has('dbg');
const out = document.getElementById('out');
const pageTitle = document.getElementById('pageTitle');

if (LAT_STR === '60.3281' && LON_STR === '25.0551'){
  pageTitle.textContent = 'TUSINASÄÄ 12 · ASOLA';
  pageTitle.style.display = '';
}

const tag = s => DBG ? ` <span class="soft" style="font-size:12px">${s}</span>` : '';

/* Aikaformatit */
const hmFi = new Intl.DateTimeFormat('fi-FI',{hour:'2-digit',minute:'2-digit',hour12:false,timeZone:TZ,hourCycle:'h23'});
function fmtHM(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}:${ps.find(p=>p.type==='minute')?.value||'00'}`; }
function fmtH(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}`; }

/* SmartSymbol – käyttäjän sanasto */
const SS_TEXT = {
  1:'sinistä', 2:'sangen sinistä', 4:'siniharmaata', 6:'sangen harmaata', 7:'harmaata',
  9:'MIST!',
  71:'seppoa kutittaa.', 74:'seppoa ärsyttää.', 77:'seppo on vihainen.',
  21:'kuuro jossain.', 24:'kuuroja.', 27:'kuuroja sakeana.',
  11:'tihkuu.', 14:'kryotihkua.', 17:'kryosadetta.',
  31:'siniharmaasta ripsii.', 34:'sangen harmaasta ripsii.', 37:'ripsii.',
  32:'siniharmaasta satelee.', 35:'sangen harmaasta satelee.', 38:'satelee.',
  33:'siniharmaasta kaatosadettakin.', 36:'sangen harmaasta myös kaatosadettakin.', 39:'kaatosadetta.',
  41:'siniharmaasta märkä hiutale.', 44:'sangen harmaasta märkä hiutale.', 47:'märkä hiutale.',
  42:'siniharmaasta räntää.', 45:'sangen harmaasta räntää.', 48:'räntää.',
  43:'siniharmaasta tiskirättiä.', 46:'sangen harmaasta tiskirättiä.', 49:'tiskirättiä.',
  51:'sinihirmaasta kevyt hiutale.', 54:'sangen harmaasta kevyt hiutale.', 57:'kevyt hiutale.',
  52:'siniharmaasta lunta.', 55:'sangen harmaasta lunta.', 58:'lunta.',
  53:'siniharmaasta pyryä.', 56:'sangen harmaasta pyryä.', 59:'pyryttää.',
  61:'rakeita jossain.', 64:'rakeita.', 67:'rakeiden tulitus.'
};
const ssText = c => { if (c==null) return ''; const key=Number(c)%100; return SS_TEXT[key]||''; };
const PRECIP_CODES = new Set([
  11,14,17,21,24,27,31,32,33,34,35,36,37,38,39,41,42,43,44,45,46,47,48,49,
  51,52,53,54,55,56,57,58,59,61,64,67,71,74,77
]);

/* Nowcast symbol_code sanasto – normalisoitu (_day/_night pois) */
const NC_SYMBOL = {
  'clearsky': "sinistä",
  'fair': "sangen sinistä",
  'partlycloudy': "siniharmaata",
  'cloudy': "harmaata",
  'lightrainshowers': "jokunen kuuro.",
  'heavyrainshowers': "äänekästä kuuroa.",
  'rainshowersandthunder': "sepon välisuihkut.",
  'thunderstorm': "seppo riehuu.",
  'heavyrain': "saavista kaatuu.",
  'lightrain': "ripsii.",
  'sleet': "räntää.",
  'lightsleetshowers_and_thunder': "sepon tiskivuoro.",
  'snowshowers_and_thunder': "lumiukkonen.",
  'snow': "lunta.",
  'heavysnow': "pyryttää.",
  'fog': "MIST!"
};
const ncBase = code => code ? code.replace(/_(day|night)$/,'') : '';
const ncSymbolText = code => (NC_SYMBOL[ncBase(code)] || '');
const ncIsPrecip = code => !!({
  lightrain:1, heavyrain:1, lightrainshowers:1, heavyrainshowers:1,
  rainshowersandthunder:1, sleet:1, lightsleetshowers_and_thunder:1,
  snow:1, heavysnow:1, snowshowers_and_thunder:1
}[ncBase(code)]);

/* Pilvisyys-downgrade sateisista ilmaisuista (HRM-tekstit) */
function downgradeToCloudiness(descRaw){
  if (!descRaw) return 'pilvistä';
  const s = descRaw.toLowerCase();
  if (s.includes('siniharmaasta') || s.includes('sinihirmaasta')) return 'siniharmaata';
  if (s.includes('sangen harmaasta')) return 'sangen harmaata';
  return 'pilvistä';
}
/* Pisteellinen virke → pienennä 1. kirjain */
function lowerFirstIfPeriod(s){
  if (!s) return s;
  const t = s.trim();
  if (!/[.!?]$/.test(t)) return t;
  return t.charAt(0).toLowerCase() + t.slice(1);
}

/* Suuntanimet 8-ilmansuunnalle – pitkät nimet */
function dir8(deg){
  if (deg==null || isNaN(deg)) return '';
  const d = ((deg%360)+360)%360;
  if (d>=337.5 || d<22.5)   return 'pohjoinen';
  if (d<67.5)               return 'koillinen';
  if (d<112.5)              return 'itä';
  if (d<157.5)              return 'kaakko';
  if (d<202.5)              return 'etelä';
  if (d<247.5)              return 'lounas';
  if (d<292.5)              return 'länsi';
  return 'luode';
}

/* FMI WFS */
function buildWfsForecast(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::forecast::harmonie::surface::point::timevaluepair';
  const params='temperature,precipitation1h,windspeedms,winddirection,SmartSymbol';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-2); e.setHours(e.getHours()+24);
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=60`;
}

/* XML → sarjat */
const parseXML = txt => {
  const x = new DOMParser().parseFromString(txt,'application/xml');
  const ex = x.querySelector('Exception, ows\\:Exception');
  if (ex){ const t=x.querySelector('ExceptionText, ows\\:ExceptionText'); throw new Error('FMI virhe: '+(t?t.textContent:'Tuntematon virhe')); }
  return x;
};
const extractSeries = x => {
  const get=(e,n)=>e.getElementsByTagNameNS('*',n)[0];
  const all=x.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTimeseries');
  const o={};
  for (const s of all){
    const id=(s.getAttribute('gml:id')||'').toLowerCase();
    let k='';
    if (id.includes('temperature')) k='temperature';
    else if (id.includes('precipitation1h')) k='precipitation1h';
    else if (id.includes('windspeedms')) k='windspeedms';
    else if (id.includes('winddirection')) k='winddirection';
    else if (id.includes('smartsymbol')) k='SmartSymbol';
    if (!k) continue;
    const map=new Map();
    const pts=s.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTVP');
    for (const p of pts){
      const t=get(p,'time')?.textContent;
      const v=get(p,'value')?.textContent;
      if (!t) continue;
      const num = v!=null ? Number(v) : null;
      map.set(t, isNaN(num)?null:num);
    }
    o[k]=map;
  }
  return o;
};

/* Nowcast – sade + puuska + symbol_code (symboli käytössä vain t0:ssa) */
async function fetchNowcastForHour(lat, lon, dUTC){
  try{
    const url = `https://api.met.no/weatherapi/nowcast/2.0/complete?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&altitude=0`;
    const res = await fetch(url, { cache:'no-store', headers: { 'Accept': 'application/json' } });
    if (!res.ok) return { val:null, meta:`NC!${res.status}` };
    const js = await res.json();
    const ts = js?.properties?.timeseries;
    if (!Array.isArray(ts) || !ts.length) return { val:null, meta:'NC!empty' };

    const targetUTC = dUTC.getTime();
    let future=null,fDiff=Infinity,past=null,pDiff=Infinity;
    for (const it of ts){
      const t=new Date(it.time).getTime(), diff=t-targetUTC, ad=Math.abs(diff);
      if (diff>=0 && ad<fDiff){fDiff=ad; future=it;}
      if (diff<0  && ad<pDiff){pDiff=ad; past=it;}
    }
    let best=null;
    if (future && fDiff<=60*60000) best=future;
    else if (past && pDiff<=60*60000) best=past;
    if (!best) return { val:null, meta:'NC!miss' };

    const acc  = best?.data?.next_1_hours?.details?.precipitation_amount;
    const pr   = best?.data?.instant?.details?.precipitation_rate;
    const gust = best?.data?.instant?.details?.wind_speed_of_gust;
    const sym  = best?.data?.next_1_hours?.summary?.symbol_code || null;

    let p = null;
    if (typeof acc === 'number') p = acc;
    else if (typeof pr === 'number') p = pr;

    return { val:(typeof p==='number'?p:null), meta:'NC', gust:(typeof gust==='number'?gust:null), sym };
  }catch{
    return { val:null, meta:'NC!err' };
  }
}

/* Solut */
function rainCell(val, {markGrey=false}={}){
  if (val==null || isNaN(Number(val))) return { text:'–', cls:'soft', num:null };
  const n = Number(val);
  if (n === 0) return { text:'—', cls:'soft dash', num:0 };
  return { text:n.toFixed(1)+' mm', cls:(markGrey?'soft':''), num:n };
}
function windCell(mean, gust, dirDeg, {baseGrey=true}={}){
  const mOk = (mean!=null && !isNaN(Number(mean)));
  const gOk = (gust!=null && !isNaN(Number(gust)));
  const meanV = mOk ? Number(mean) : null;
  const gustV = gOk ? Number(gust) : null;

  let txt = (mOk ? meanV.toFixed(1)+' m/s' : '–');

  // puuska kursiivilla, valkoisena, jos ≥15 m/s
  let gustTxt = '', gustWhite = false;
  if (gOk && gustV >= 15){
    gustTxt = ` (<em style="color:#e8e8e8">${gustV.toFixed(1)}</em>)`;
    gustWhite = true;
  }

  // keskituuli ≥10 → valkoinen
  const meanWhite = (mOk && meanV >= 10);

  const cls = (meanWhite || gustWhite) ? '' : (baseGrey ? 'soft' : '');

  const dirTxt = dir8(dirDeg);
  const dirHtml = dirTxt ? `<span class="${cls? 'mini' : 'miniW'} windDir">${dirTxt}</span>` : '';

  return { text: txt + gustTxt + dirHtml, cls };
}

/* Taulukon teko */
(async function(){
  scrollTo(0,1); setTimeout(()=>scrollTo(0,1),150);
  if (!LAT || !LON || isNaN(LAT) || isNaN(LON)){
    out.innerHTML = `<div class="err">Puuttuvat tai virheelliset koordinaatit. Käytä:<br><code>?lat=60.1699&lon=24.9384</code></div>`;
    return;
  }

  try{
    const fRes = await fetch(buildWfsForecast(LAT,LON), {cache:'no-store'});
    const fTxt = await fRes.text();
    if (!fRes.ok){ out.innerHTML = `<div class="err">FMI ennuste HTTP ${fRes.status}\n${fTxt.slice(0,400)}</div>`; return; }
    const forecast = extractSeries(parseXML(fTxt));

    const now = new Date();
    const thisHourLocal  = new Date(new Date(now).setMinutes(0,0,0));

    const fKeys = Array.from(forecast.temperature?.keys?.()||[]).sort();
    const pickKeys = [];
    for (const k of fKeys){
      const d = new Date(k);
      if (d >= thisHourLocal){ pickKeys.push(k); if (pickKeys.length>=13) break; }
    }
    if (!pickKeys.length){ out.innerHTML = `<div class="muted">Ei rivejä tälle ikkunalle.</div>`; return; }

    const d0 = new Date(pickKeys[0]);
    const d1 = pickKeys[1] ? new Date(pickKeys[1]) : null;
    const d2 = pickKeys[2] ? new Date(pickKeys[2]) : null;
    const [nc0, nc1, nc2] = await Promise.all([
      fetchNowcastForHour(LAT, LON, d0),
      d1 ? fetchNowcastForHour(LAT, LON, d1) : Promise.resolve({val:null, meta:'NC!skip'}),
      d2 ? fetchNowcastForHour(LAT, LON, d2) : Promise.resolve({val:null, meta:'NC!skip'})
    ]);

    let html = '';
    let prevShownText = null;

    function normalizedDittoKey(s){
      return s.toLowerCase().replace(/[()[\]{}?.,\s]+/g,' ').trim();
    }
    function showRow(timeHtml, temp, descHtml, descWhite, rainObj, rainTag, windObj){
      const plain = descHtml.replace(/<[^>]*>/g,'').trim();
      let displayDesc = descHtml;

      if (plain && prevShownText && normalizedDittoKey(plain) === normalizedDittoKey(prevShownText)){
        displayDesc = '<span class="ditto" title="sama kuin edellä">&raquo;</span>';
      } else {
        prevShownText = plain || null;
      }

      const rainTagHtml = (rainObj.text==='—') ? '' : tag(rainTag||'');

      html += `<div class="row">
        <div class="${(rainObj.num!=null && rainObj.num>0) ? 't' : 't soft'}">${timeHtml}</div>
        <div class="${descWhite?'':'soft'}">${temp!=null?Math.round(temp)+'°':'–'}</div>
        <div class="desc ${descWhite?'':'soft'}">${displayDesc}</div>
        <div class="${rainObj.cls||''}">${rainObj.text}${rainTagHtml}</div>
        <div class="${windObj.cls||''}">${windObj.text}</div>
      </div>`;
    }

    /* t0 (nyt) — NC symboli käytössä */
    {
      const key = pickKeys[0];
      const temp = forecast.temperature?.get(key);
      const wind = forecast.windspeedms?.get(key);
      const wdir = forecast.winddirection?.get(key);
      const ss   = forecast.SmartSymbol?.get(key);
      const rainVal0 = (nc0 && typeof nc0.val==='number') ? nc0.val : null;

      const rObj = (rainVal0!=null && rainVal0<0.1) ? {text:'—', cls:'soft dash', num:0} : rainCell(rainVal0);
      const wObj = windCell(wind, (nc0 && typeof nc0.gust==='number' ? nc0.gust : null), wdir, { baseGrey:true });

      let descRaw = ncSymbolText(nc0?.sym);
      if (!descRaw){
        let hrm = ssText(ss) || '–';
        if ((rainVal0!=null && rainVal0<0.1) && (ss!=null) && PRECIP_CODES.has(Number(ss)%100)){
          hrm = downgradeToCloudiness(hrm);
        }
        descRaw = hrm;
      }
      descRaw = lowerFirstIfPeriod(descRaw);
      const descIsWhite = ( (rObj.num!=null && rObj.num>=0.1) && ncIsPrecip(nc0?.sym) );

      const src = nc0?.sym ? ncBase(nc0.sym) : 'HRM';
      showRow(fmtHM(now), temp, `${descRaw}${DBG?` <span class="soft" style="font-size:12px">[${src}]</span>`:''}`, descIsWhite, rObj, 'NC', wObj);
    }

    /* t+1h — HRM kuvaus (sulut, kursiivi, ?); valkea vain jos NC-sade > 0 */
    if (pickKeys.length >= 2){
      const key = pickKeys[1], dUtc = new Date(key);
      const temp = forecast.temperature?.get(key);
      const wind = forecast.windspeedms?.get(key);
      const wdir = forecast.winddirection?.get(key);
      const rain = forecast.precipitation1h?.get(key);
      const ss   = forecast.SmartSymbol?.get(key);

      let rObj, rTag='NC', rainUsed=null;
      if (nc1 && typeof nc1.val==='number'){
        rObj = (nc1.val<0.1) ? {text:'—', cls:'soft dash', num:0} : rainCell(nc1.val);
        rainUsed = (nc1.val<0.1) ? 0 : nc1.val;
      } else {
        rObj = rainCell(rain, {markGrey:true}); rTag='HRM'; rainUsed=(typeof rain==='number'?rain:null);
      }
      const wObj = windCell(wind, (nc1 && typeof nc1.gust==='number' ? nc1.gust : null), wdir, { baseGrey:true });

      let hrm = ssText(ss) || '–';
      hrm = lowerFirstIfPeriod(hrm);
      const descWrapped = hrm==='–' ? '–' : `(<em>${hrm.replace(/[.?]+$/,'')}?</em>)`;
      const descWhite = (rainUsed!=null && rainUsed>=0.1);

      showRow(fmtHM(dUtc), temp, `${descWrapped}${DBG?` <span class="soft" style="font-size:12px">[HRM]</span>`:''}`, descWhite, rObj, rTag, wObj);
    }

    /* t+2h — sama kuin t+1h */
    if (pickKeys.length >= 3){
      const key = pickKeys[2], dUtc = new Date(key);
      const temp = forecast.temperature?.get(key);
      const wind = forecast.windspeedms?.get(key);
      const wdir = forecast.winddirection?.get(key);
      const rain = forecast.precipitation1h?.get(key);
      const ss   = forecast.SmartSymbol?.get(key);

      let rObj, rTag='NC', rainUsed=null;
      if (nc2 && typeof nc2.val==='number'){
        rObj = (nc2.val<0.1) ? {text:'—', cls:'soft dash', num:0} : rainCell(nc2.val);
        rainUsed = (nc2.val<0.1) ? 0 : nc2.val;
      } else {
        rObj = rainCell(rain, {markGrey:true}); rTag='HRM'; rainUsed=(typeof rain==='number'?rain:null);
      }
      const wObj = windCell(wind, (nc2 && typeof nc2.gust==='number' ? nc2.gust : null), wdir, { baseGrey:true });

      let hrm = ssText(ss) || '–';
      hrm = lowerFirstIfPeriod(hrm);
      const descWrapped = hrm==='–' ? '–' : `(<em>${hrm.replace(/[.?]+$/,'')}?</em>)`;
      const descWhite = (rainUsed!=null && rainUsed>=0.1);

      showRow(fmtHM(dUtc), temp, `${descWrapped}${DBG?` <span class="soft" style="font-size:12px">[HRM]</span>`:''}`, descWhite, rObj, rTag, wObj);
    }

    /* t+3…t+12 – perussäännöt */
    const drizzleCodes = new Set([11,31,34,37,41,44,47,51,54,57]); // + yö %100
    for (let i=3; i<pickKeys.length; i++){
      const key = pickKeys[i], dUtc = new Date(key);
      const temp = forecast.temperature?.get(key);
      const rain = forecast.precipitation1h?.get(key);
      const wind = forecast.windspeedms?.get(key);
      const wdir = forecast.winddirection?.get(key);
      const ss   = forecast.SmartSymbol?.get(key);
      const ssDay = (ss!=null) ? (Number(ss)%100) : null;

      const tmp = rainCell(rain);
      const wet  = (tmp.num!=null && tmp.num > 0);
      const forceGrey = (wet && tmp.num < 0.3 && drizzleCodes.has(ssDay));
      const rObj = forceGrey ? rainCell(rain, {markGrey:true}) : rainCell(rain);

      let descRaw = ssText(ss) || '–';
      descRaw = lowerFirstIfPeriod(descRaw);

      const wObj = windCell(wind, null, wdir, { baseGrey:true });
      const highlight = wet && !forceGrey;

      const timeHtml = `<span class="${highlight?'miniW':'mini'}">klo&nbsp;</span>${fmtH(dUtc)}`;
      showRow(timeHtml, temp, descRaw, highlight, rObj, 'HRM', wObj);
    }

    out.innerHTML = html || `<div class="muted">Ei rivejä tälle ikkunalle.</div>`;
  }catch(e){
    out.innerHTML = `<div class="err">${String(e.message||e)}</div>`;
  }
})();
</script>
