<!doctype html>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="noindex">
<title>TUSINASÄÄ 12</title>
<style>
  :root { color-scheme: dark; }
  html,body{height:100%}
  body{
    margin:0; padding:22px 14px 24px; background:#000; color:#e8e8e8;
    font:17px/1.5 Arial,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility
  }
  .pageTitle{ font-weight:700; font-size:15px; letter-spacing:.4px; color:#9aa6b0;
    text-transform:uppercase; margin:0 0 4px 0 }
  .mini{ color:#7a858e; font-size:12px; letter-spacing:.3px; line-height:1.2 }
  .miniW{ color:#e8e8e8; font-size:12px; letter-spacing:.3px; line-height:1.2 }
  .caps{ text-transform:uppercase; letter-spacing:.5px }
  .list{ border-top:1px solid #2a2a2a; margin-top:6px; }
  .hdr{
    color:#6b7580; font-size:12px; letter-spacing:.3px; margin:6px 0 4px 0;
    display:grid; grid-template-columns:54px 56px 1fr 70px 76px; align-items:end; justify-items:center;
  }
  .hdr div:nth-child(-n+3){ justify-self:start; text-align:left }
  .hdr div:nth-child(4), .hdr div:nth-child(5){ text-align:center }
  .row{
    display:grid; grid-template-columns:54px 56px 1fr 70px 76px;
    gap:8px; padding:6px 0; border-bottom:1px solid #1c1c1c; align-items:center;
  }
  .row > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px }
  .muted{ color:#74808a } .soft{ color:#7f8a93 }
  .t{ text-align:left } .t.hh{ text-align:right }
  .row > div:nth-child(4){ text-align:center }
  .desc .ditto{ display:inline } .ditto{ color:inherit }
  .dash{ text-align:center }
  .windDir{ display:block; margin-top:2px }
  .err{ color:#ff6b6b; white-space:pre-wrap }
</style>

<h1 id="pageTitle" class="pageTitle" style="display:none"></h1>

<div class="hdr">
  <div></div><div></div><div></div>
  <div class="caps">SADE</div>
  <div class="caps">TUULI</div>
</div>
<div class="list" id="out" aria-live="polite"></div>

<script>
/* ===== perusasetukset ===== */
const q = new URLSearchParams(location.search);
const LAT_STR = q.get('lat'); const LON_STR = q.get('lon');
const LAT = parseFloat(LAT_STR); const LON = parseFloat(LON_STR);
const TZ  = 'Europe/Helsinki';
const DBG = q.has('dbg');
const out = document.getElementById('out');
const pageTitle = document.getElementById('pageTitle');

if (LAT_STR === '60.3281' && LON_STR === '25.0551'){
  pageTitle.textContent = 'TUSINASÄÄ 12 · ASOLA'; pageTitle.style.display = '';
} else if (LAT_STR === '60.1562' && LON_STR === '24.7767'){
  pageTitle.textContent = 'TUSINASÄÄ 12 · RANTAKOTO'; pageTitle.style.display = '';
}

const tag = s => DBG ? ` <span class="soft" style="font-size:12px">${s}</span>` : '';

/* ===== aikaformaatit ===== */
const hmFi = new Intl.DateTimeFormat('fi-FI',{hour:'2-digit',minute:'2-digit',hour12:false,timeZone:TZ,hourCycle:'h23'});
function fmtHM(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}:${ps.find(p=>p.type==='minute')?.value||'00'}`; }
function fmtH(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}`; }

/* ===== sääkuvaukset (SmartSymbol + NC) – samat kuin aiemmin ===== */
const SS_TEXT = {
  1:'sinistä', 2:'sangen sinistä', 4:'siniharmaata', 6:'sangen harmaata', 7:'harmaata',
  9:'MIST!',
  71:'seppoa kutittaa.', 74:'seppoa ärsyttää.', 77:'seppo on vihainen.',
  21:'kuuro jossain.', 24:'kuuroja.', 27:'kuuroja sakeana.',
  11:'tihkuu.', 14:'kryotihkua.', 17:'kryosadetta.',
  31:'siniharmaasta ripsii.', 34:'sangen harmaasta ripsii.', 37:'ripsii.',
  32:'siniharmaasta satelee.', 35:'sangen harmaasta satelee.', 38:'satelee.',
  33:'siniharmaasta kaatosadettakin.', 36:'sangen harmaasta myös kaatosadettakin.', 39:'kaatosadetta.',
  41:'siniharmaasta märkä hiutale.', 44:'sangen harmaasta märkä hiutale.', 47:'märkä hiutale.',
  42:'siniharmaasta räntää.', 45:'sangen harmaasta räntää.', 48:'räntää.',
  43:'siniharmaasta tiskirättiä.', 46:'sangen harmaasta tiskirättiä.', 49:'tiskirättiä.',
  51:'sinihirmaasta kevyt hiutale.', 54:'sangen harmaasta kevyt hiutale.', 57:'kevyt hiutale.',
  52:'siniharmaasta lunta.', 55:'sangen harmaasta lunta.', 58:'lunta.',
  53:'siniharmaasta pyryä.', 56:'sangen harmaasta pyryä.', 59:'pyryttää.',
  61:'rakeita jossain.', 64:'rakeita.', 67:'rakeiden tulitus.'
};
const ssText = c => { if (c==null) return ''; const key=Number(c)%100; return SS_TEXT[key]||''; };

const SMALL_RAIN_EXCEPT = new Set([71,74,77,21,24,27,14,17,32,35,38,33,36,39,42,45,48,43,46,49,52,55,58,53,56,59,61,64,67]);

const NC_SYMBOL = {
  'clearsky': "sinistä", 'fair': "sangen sinistä", 'partlycloudy': "siniharmaata", 'cloudy': "harmaata",
  'lightrainshowers': "jokunen kuuro.", 'heavyrainshowers': "äänekästä kuuroa.",
  'rainshowersandthunder': "sepon välisuihkut.", 'thunderstorm': "seppo riehuu.",
  'heavyrain': "saavista kaatuu.", 'lightrain': "ripsii.", 'sleet': "räntää.",
  'lightsleetshowers_and_thunder': "sepon tiskivuoro.", 'snowshowers_and_thunder': "lumiukkonen.",
  'snow': "lunta.", 'heavysnow': "pyryttää.", 'fog': "MIST!"
};
const ncBase = code => code ? code.replace(/_(day|night)$/,'') : '';
const ncSymbolText = code => (NC_SYMBOL[ncBase(code)] || '');
const ncIsPrecip = code => !!({
  lightrain:1, heavyrain:1, lightrainshowers:1, heavyrainshowers:1,
  rainshowersandthunder:1, sleet:1, lightsleetshowers_and_thunder:1,
  snow:1, heavysnow:1, snowshowers_and_thunder:1, fog:1, thunderstorm:1
}[ncBase(code)]);

/* ===== tuulen suunta teksti ===== */
function dir8(deg){
  if (deg==null || isNaN(deg)) return '';
  const d = ((deg%360)+360)%360;
  if (d>=337.5 || d<22.5)   return 'pohjoisesta';
  if (d<67.5)               return 'koillisesta';
  if (d<112.5)              return 'idästä';
  if (d<157.5)              return 'kaakosta';
  if (d<202.5)              return 'etelästä';
  if (d<247.5)              return 'lounasta';
  if (d<292.5)              return 'lännestä';
  return 'luoteesta';
}

/* ===== FMI WFS (ei puuskaa tässä storedqueryssa) ===== */
function buildWfsForecast(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::forecast::harmonie::surface::point::timevaluepair';
  const params='temperature,precipitation1h,windspeedms,winddirection,SmartSymbol';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-2); e.setHours(e.getHours()+24);
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=60`;
}
const parseXML = txt => {
  const x = new DOMParser().parseFromString(txt,'application/xml');
  const ex = x.querySelector('Exception, ows\\:Exception');
  if (ex){ const t=x.querySelector('ExceptionText, ows\\:ExceptionText'); throw new Error('FMI virhe: '+(t?t.textContent:'Tuntematon virhe')); }
  return x;
};
const extractSeries = x => {
  const get=(e,n)=>e.getElementsByTagNameNS('*',n)[0];
  const all=x.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTimeseries');
  const o={};
  for (const s of all){
    const id=(s.getAttribute('gml:id')||'').toLowerCase();
    let k='';
    if (id.includes('temperature')) k='temperature';
    else if (id.includes('precipitation1h')) k='precipitation1h';
    else if (id.includes('windspeedms')) k='windspeedms';
    else if (id.includes('winddirection')) k='winddirection';
    else if (id.includes('smartsymbol')) k='SmartSymbol';
    if (!k) continue;
    const map=new Map();
    const pts=s.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTVP');
    for (const p of pts){
      const t=get(p,'time')?.textContent;
      const v=get(p,'value')?.textContent;
      if (!t) continue;
      const num = v!=null ? Number(v) : null;
      map.set(t, isNaN(num)?null:num);
    }
    o[k]=map;
  }
  return o;
};

/* ===== MET Nowcast (t0 sade+puuska+symboli; t1–t2 sade+symboli kun saatavilla) ===== */
async function fetchNowcastForHour(lat, lon, dUTC){
  try{
    const url = `https://api.met.no/weatherapi/nowcast/2.0/complete?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&altitude=0`;
    const res = await fetch(url, { cache:'no-store', headers: { 'Accept': 'application/json' } });
    if (!res.ok) return { val:null, meta:`NC!${res.status}` };
    const js = await res.json();
    const ts = js?.properties?.timeseries;
    if (!Array.isArray(ts) || !ts.length) return { val:null, meta:'NC!empty' };

    const targetUTC = dUTC.getTime();
    let future=null,fDiff=Infinity,past=null,pDiff=Infinity;
    for (const it of ts){
      const t=new Date(it.time).getTime(), diff=t-targetUTC, ad=Math.abs(diff);
      if (diff>=0 && ad<fDiff){fDiff=ad; future=it;}
      if (diff<0  && ad<pDiff){pDiff=ad; past=it;}
    }
    let best=null;
    if (future && fDiff<=60*60000) best=future; else if (past && pDiff<=60*60000) best=past;
    if (!best) return { val:null, meta:'NC!miss' };

    const acc  = best?.data?.next_1_hours?.details?.precipitation_amount;
    const pr   = best?.data?.instant?.details?.precipitation_rate;
    const gust = best?.data?.instant?.details?.wind_speed_of_gust;
    const sym  = best?.data?.next_1_hours?.summary?.symbol_code || null;

    let p = null; if (typeof acc === 'number') p = acc; else if (typeof pr === 'number') p = pr;
    return { val:(typeof p==='number'?p:null), meta:'NC', gust:(typeof gust==='number'?gust:null), sym };
  }catch{ return { val:null, meta:'NC!err' }; }
}

/* ===== solujen formatterit ===== */
function rainCell(val, {markGrey=false}={}){
  if (val==null || isNaN(Number(val))) return { text:'–', cls:'soft', num:null };
  const n = Number(val);
  if (n === 0) return { text:'—', cls:'soft dash', num:0 };
  return { text:n.toFixed(1)+' mm', cls:(markGrey?'soft':''), num:n };
}
function windCell(mean, gust, dirDeg, {baseGrey=true}={}){
  const mOk = (mean!=null && !isNaN(Number(mean)));
  const gOk = (gust!=null && !isNaN(Number(gust)));
  const meanV = mOk ? Number(mean) : null;
  const gustV = gOk ? Number(gust) : null;

  let txt = (mOk ? meanV.toFixed(1)+' m/s' : '–');

  let gustTxt = '', gustWhite = false;
  if (gOk && gustV >= 15){
    gustTxt = ` (<em style="color:#e8e8e8">${gustV.toFixed(1)}</em>)`;
    gustWhite = true;
  }
  const meanWhite = (mOk && meanV >= 10);
  const cls = (meanWhite || gustWhite) ? '' : (baseGrey ? 'soft' : '');

  const dirTxt = dir8(dirDeg);
  const dirHtml = dirTxt ? `<span class="${cls? 'mini' : 'miniW'} windDir">${dirTxt}</span>` : '';

  return { text: txt + gustTxt + dirHtml, cls };
}

/* ===== Ditto ===== */
function normalizedDittoKey(s){
  return s.toLowerCase().replace(/<[^>]*>/g,'').replace(/[()[\]{}?.,]/g,'').replace(/\s+/g,' ').trim();
}
function pushRow(htmlArr, {timeHtml, temp, descHtml, descWhite, rainObj, rainTag, windObj, prevKeyRef}){
  const plain = descHtml.replace(/<[^>]*>/g,'').trim();
  let displayDesc = descHtml;
  if (plain && prevKeyRef.val && normalizedDittoKey(plain) === normalizedDittoKey(prevKeyRef.val)){
    displayDesc = '<span class="ditto" title="sama kuin edellä">&raquo;</span>';
  } else {
    prevKeyRef.val = plain || null;
  }
  const rainTagHtml = (rainObj.text==='—') ? '' : tag(rainTag||'');
  htmlArr.push(
    `<div class="row">
      <div class="${(rainObj.num!=null && rainObj.num>0) ? 't' : 't soft'}">${timeHtml}</div>
      <div class="${descWhite?'':'soft'}">${temp!=null?Math.round(temp)+'°':'–'}</div>
      <div class="desc ${descWhite?'':'soft'}">${displayDesc}</div>
      <div class="${rainObj.cls||''}">${rainObj.text}${rainTagHtml}</div>
      <div class="${windObj.cls||''}">${windObj.text}</div>
    </div>`
  );
}

/* ===== HÄMÄRÄ – aurinkoaltitudi ja vaiheet ===== */

/* tz offset (min) Helsingin aikavyöhykkeellä annetulle Date:lle */
function tzOffsetMin(d, tz){
  const s = d.toLocaleString('en-CA',{timeZone:tz});
  const ld = new Date(s);
  return Math.round((ld - new Date(d.toISOString().slice(0,19))) / 60000);
}

/* NOAA-tyylinen aurinkoaltitudi (asteina). Riittävän tarkka minuutin sisällä. */
function sunAltitudeDeg(dateUTC, latDeg, lonDeg, tzName){
  const rad = Math.PI/180, deg = 180/Math.PI;
  const d = new Date(dateUTC);
  const tzMin = tzOffsetMin(d, tzName); // esim. 120 tai 180
  // Juliaaninen päivä
  const JD = (Date.UTC(d.getUTCFullYear(),d.getUTCMonth(),d.getUTCDate(),d.getUTCHours(),d.getUTCMinutes(),d.getUTCSeconds())/86400000) + 2440587.5;
  const T = (JD - 2451545.0)/36525.0;

  const L0 = (280.46646 + T*(36000.76983 + T*0.0003032)) % 360;
  const M  = 357.52911 + T*(35999.05029 - 0.0001537*T);
  const e  = 0.016708634 - T*(0.000042037 + 0.0000001267*T);
  const C  = (1.914602 - T*(0.004817 + 0.000014*T))*Math.sin(M*rad)
           + (0.019993 - 0.000101*T)*Math.sin(2*M*rad)
           + 0.000289*Math.sin(3*M*rad);
  const trueLong = L0 + C;
  const omega = 125.04 - 1934.136*T;
  const lambda = trueLong - 0.00569 - 0.00478*Math.sin(omega*rad);

  const epsilon0 = 23 + (26 + ((21.448 - T*(46.815 + T*(0.00059 - 0.001813*T))))/60)/60;
  const epsilon = epsilon0 + 0.00256*Math.cos(omega*rad);
  const delta = Math.asin(Math.sin(epsilon*rad)*Math.sin(lambda*rad)); // deklinaatio (rad)

  // Equation of time (min)
  const y = Math.tan((epsilon*rad)/2); const y2 = y*y;
  const Etime = 4*deg*( y2*Math.sin(2*L0*rad) - 2*e*Math.sin(M*rad)
    + 4*e*y2*Math.sin(M*rad)*Math.cos(2*L0*rad)
    - 0.5*y2*y2*Math.sin(4*L0*rad)
    - 1.25*e*e*Math.sin(2*M*rad) );

  // Tosi aurinkoaika (min)
  const minutes = d.getUTCHours()*60 + d.getUTCMinutes() + tzMin;
  let tst = (minutes + Etime + 4*lonDeg) % 1440;
  if (tst < 0) tst += 1440;
  let ha = (tst/4 < 0) ? (tst/4 + 180) : (tst/4 - 180); // tuntikulma (deg)

  // Altitudi
  const lat = latDeg*rad;
  const H = ha*rad;
  const alt = Math.asin( Math.sin(lat)*Math.sin(delta) + Math.cos(lat)*Math.cos(delta)*Math.cos(H) );
  return alt*deg;
}

const TW = { DAY:0, CIV:1, NAU:2, AST:3, DARK:4 };
function twPhaseFromAlt(altDeg){
  if (altDeg > 0) return TW.DAY;
  if (altDeg > -6) return TW.CIV;
  if (altDeg > -12) return TW.NAU;
  if (altDeg > -18) return TW.AST;
  return TW.DARK;
}
function twNameFI(phase){
  return (phase===TW.CIV)?'porvarillinen hämärä'
       : (phase===TW.NAU)?'nauttinen hämärä'
       : (phase===TW.AST)?'astronominen hämärä'
       : 'säkkipimeä';
}

/* Palauttaa vaiheen annetulla minuutilla sekä (jos osuu tunnille) raja-ajan ja tyypin */
function phaseInfoForHour(dUTC, lat, lon){
  const tzMin = tzOffsetMin(dUTC, TZ);
  const start = new Date(dUTC); start.setUTCMinutes(0,0,0);
  const end = new Date(start); end.setUTCHours(end.getUTCHours()+1);

  const a0 = sunAltitudeDeg(start, lat, lon, TZ);
  const a1 = sunAltitudeDeg(end,   lat, lon, TZ);
  const p0 = twPhaseFromAlt(a0), p1 = twPhaseFromAlt(a1);

  // Etsi mahdollinen raja binäärihaulla minuutin tarkkuuteen
  let change = null;
  if (p0 !== p1){
    let lo=0, hi=60;
    while (hi-lo>1){
      const mid = Math.floor((lo+hi)/2);
      const t = new Date(start); t.setUTCMinutes(mid);
      const a = sunAltitudeDeg(t, lat, lon, TZ);
      const pm = twPhaseFromAlt(a);
      if (pm===p0) lo=mid; else hi=mid;
    }
    change = { minute: hi, alt: sunAltitudeDeg(new Date(start.setUTCMinutes(hi)), lat, lon, TZ) };
  }

  // Auringon nousu/lasku jos altitudi ylittää 0 rajan
  let sunEvent = null;
  if ((a0>0 && a1<=0) || (a0<=0 && a1>0)){
    // binaari 0°:lle
    let lo=0, hi=60;
    while (hi-lo>1){
      const mid=Math.floor((lo+hi)/2);
      const t=new Date(new Date(start).setUTCMinutes(mid));
      const a=sunAltitudeDeg(t,lat,lon,TZ);
      if ((a0>0)?(a>0):(a<=0)) lo=mid; else hi=mid;
    }
    const t = new Date(new Date(start).setUTCMinutes(hi));
    sunEvent = { minute: hi, rising: a1>0 }; // jos tunnin lopussa >0 → nousi
  }

  return { phaseStart: p0, phaseEnd: p1, change, sunEvent, tzMin };
}

/* Pikkutagi-tekstit */
function miniTagForHour(info, isWet, isCivMain, isTopRow){
  // prioriteetti: aurinko → aloitus/vaihto → "nyt-vaihe" t0:lle
  const toHM = m => String(m).padStart(2,'0');
  const m2txt = m => `${toHM(Math.floor(m/60))}:${toHM(m%60)}`;

  if (info.sunEvent){
    const hhmm = m2txt(info.sunEvent.minute*60);
    return info.sunEvent.rising ? `aurinko nousee ${hhmm}` : `aurinko laskee ${hhmm}`;
  }
  if (info.change){
    // minkä suuntaan mennään
    const pTo = info.phaseEnd;
    const hhmm = m2txt(info.change.minute*60);
    if (isWet){
      // sateisella vain aloitus-tags
      if (pTo===TW.NAU) return `Nauttinen hämärä alkaa ${hhmm}`;
      if (pTo===TW.AST) return `Astronominen hämärä alkaa ${hhmm}`;
      if (pTo===TW.CIV && info.phaseStart===TW.DAY) return `Porvarillinen hämärä alkaa ${hhmm}`;
      if (pTo===TW.DARK) return `säkkipimeäksi ${hhmm}`;
      if (pTo===TW.DAY && info.phaseStart===TW.CIV) return `aurinko nousee ${hhmm}`;
      return null;
    } else {
      // kuiva: näytetään vaihto-muotoilu
      if (pTo===TW.NAU) return `vaihtuu nauttiseksi ${hhmm}`;
      if (pTo===TW.AST) return `vaihtuu astronomiseksi ${hhmm}`;
      if (pTo===TW.DARK) return `säkkipimeäksi ${hhmm}`;
      if (pTo===TW.CIV && info.phaseStart===TW.DAY) return `porvarillinen hämärä alkaa ${hhmm}`;
      if (pTo===TW.DAY && info.phaseStart===TW.CIV) return `aurinko nousee ${hhmm}`;
      return null;
    }
  }
  // t0: jos ollaan hämärässä/pimeässä eikä yllä mikään, kerro missä mennään
  if (isTopRow){
    if (info.phaseStart===TW.CIV) return 'porvarillinen hämärä';
    if (info.phaseStart===TW.NAU) return 'nauttinen hämärä';
    if (info.phaseStart===TW.AST) return 'astronominen hämärä';
    if (info.phaseStart===TW.DARK) return 'säkkipimeä';
  }
  return null;
}

/* ===== render ===== */
(async function(){
  scrollTo(0,1); setTimeout(()=>scrollTo(0,1),150);
  if (!LAT || !LON || isNaN(LAT) || isNaN(LON)){
    out.innerHTML = `<div class="err">Puuttuvat tai virheelliset koordinaatit. Käytä:<br><code>?lat=60.1699&lon=24.9384</code></div>`;
    return;
  }
  try{
    const fRes = await fetch(buildWfsForecast(LAT,LON), {cache:'no-store'});
    const fTxt = await fRes.text();
    if (!fRes.ok){ out.innerHTML = `<div class="err">FMI ennuste HTTP ${fRes.status}\n${fTxt.slice(0,400)}</div>`; return; }
    const forecast = extractSeries(parseXML(fTxt));

    const now = new Date();
    const thisHourLocal  = new Date(new Date(now).setMinutes(0,0,0));

    const fKeys = Array.from(forecast.temperature?.keys?.()||[]).sort();
    const pickKeys = [];
    for (const k of fKeys){
      const d = new Date(k);
      if (d >= thisHourLocal){ pickKeys.push(k); if (pickKeys.length>=13) break; }
    }
    if (!pickKeys.length){ out.innerHTML = `<div class="muted">Ei rivejä tälle ikkunalle.</div>`; return; }

    const d0 = new Date(pickKeys[0]);
    const d1 = pickKeys[1] ? new Date(pickKeys[1]) : null;
    const d2 = pickKeys[2] ? new Date(pickKeys[2]) : null;
    const [nc0, nc1, nc2] = await Promise.all([
      fetchNowcastForHour(LAT, LON, d0),
      d1 ? fetchNowcastForHour(LAT, LON, d1) : Promise.resolve({val:null, meta:'NC!skip'}),
      d2 ? fetchNowcastForHour(LAT, LON, d2) : Promise.resolve({val:null, meta:'NC!skip'})
    ]);

    const rows = [];
    const prevDescRef = { val: null };

    /* apu: päättää kuiva/märkä + palauttaa kuvauksen ja minitagit hämärän kanssa */
    function decorateDesc(baseMain, hourUTC, wetInfo, sourceHint, topRow, civAsMini=true){
      const info = phaseInfoForHour(hourUTC, LAT, LON);
      const isWet = wetInfo.isWet || wetInfo.isFogOrThunder;
      // pitäisikö hämärä nousta päätekstiksi?
      let main = baseMain, white = wetInfo.highlight;
      if (!isWet){
        if (info.phaseStart===TW.NAU || info.phaseStart===TW.AST || info.phaseStart===TW.DARK){
          main = twNameFI(info.phaseStart); white = false; // hämäräteksti harmaana, highlight säilyy sateelle erikseen
        } else if (info.phaseStart===TW.CIV && civAsMini){
          // porvarillinen vain minitagiin
        }
      }
      const mini = miniTagForHour(info, isWet, info.phaseStart===TW.CIV, topRow);
      const dbg = DBG ? ` <span class="soft mini">[${sourceHint}]</span>` : '';
      const miniHtml = mini ? `<br><span class="mini">${mini}</span>` : '';
      return { html: `${main}${dbg}${miniHtml}`, white };
    }

    /* t0 – NC sade + symboli ensisijainen */
    {
      const key = pickKeys[0];
      const temp = forecast.temperature?.get(key);
      const wind = forecast.windspeedms?.get(key);
      const wdir = forecast.winddirection?.get(key);
      const ss   = forecast.SmartSymbol?.get(key);

      const rainVal0 = (nc0 && typeof nc0.val==='number') ? nc0.val : null;
      const rObj = (rainVal0!=null && rainVal0<0.1) ? {text
