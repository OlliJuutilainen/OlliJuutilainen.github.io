<!doctype html>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="noindex">
<title>TUSINASÄÄ 12</title>
<style>
  :root { color-scheme: dark; }
  html,body{height:100%}
  body{
    margin:0; padding:28px 14px 24px; background:#000; color:#e8e8e8;
    font:17px/1.5 Arial,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility
  }
  .mini{ color:#7a858e; font-size:12px; letter-spacing:.3px }
  .miniW{ color:#e8e8e8; font-size:12px; letter-spacing:.3px }
  .caps{ text-transform:uppercase; letter-spacing:.5px }
  .list{ border-top:1px solid #2a2a2a; margin-top:6px; }

  /* Grid: [time | temp | desc | rain | wind] */
  .hdr{
    color:#6b7580; font-size:12px; letter-spacing:.3px; margin:6px 0 4px 0;
    display:grid; grid-template-columns:54px 64px 1fr 70px 64px; align-items:end;
    justify-items: center;
  }
  .hdr div:nth-child(-n+3){ justify-self: start; text-align: left; }
  .hdr div:nth-child(4){ position:relative; left:-2px; } /* hienosäätö keskelle viivoihin */
  .hdr div:nth-child(4), .hdr div:nth-child(5){ text-align:center }

  .row{
    display:grid; grid-template-columns:54px 64px 1fr 70px 64px;
    gap:8px; padding:6px 0; border-bottom:1px solid #1c1c1c; align-items:center;
  }
  .row > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px; }

  .muted{ color:#74808a } .soft{ color:#7f8a93 }
  .t{ text-align:left } .t.hh{ text-align:right }

  .desc .ditto{ display:inline } .ditto{ color:inherit } /* » vain */
  .dash{ text-align:center }                 /* 0-sade keskelle */
  .row > div:nth-child(4){ text-align:center } /* koko sade-sarake keskelle */

  .err{ color:#ff6b6b; white-space:pre-wrap }
</style>

<div class="hdr">
  <div></div><div></div><div></div>
  <div class="caps">SADE</div>
  <div class="caps">TUULI</div>
</div>
<div class="list" id="out" aria-live="polite"></div>

<script>
/* Lähteet:
   - Sade t0–t2: MET Nowcast 2.0 (/complete). Muut tunnit: FMI HARMONIE (precipitation1h).
   - Lämpötila: aina FMI HARMONIE (temperature).
   - Tuuli: aina FMI HARMONIE (windspeedms). Puuska t0–t2 Nowcastista (näytetään vain numerona, jos ≥15 m/s).
   - Kuvaus: t0–t2 ensisijaisesti Nowcast symbol_code (alla oleva sanakirja, yö/päivä normalisoitu). Fallback: HARMONIE SmartSymbol (yö %100).
     * Ukkonen SS-koodeista (71/74/77) lisätään t0–t2 aina lisäviitteenä sulkeissa: " (…?) ".
   - t3→: kuvaus SmartSymbol-sanakirjasta kuten ennen; force-grey sääntö säilyy.
   Debug: ?dbg=1 näyttää lähdetageja (NC / HRM).
*/

const q = new URLSearchParams(location.search);
const LAT = parseFloat(q.get('lat'));
const LON = parseFloat(q.get('lon'));
const TZ  = 'Europe/Helsinki';
const out = document.getElementById('out');
const DBG = q.has('dbg');
function tag(s){ return DBG ? ` <span class="soft" style="font-size:12px">${s}</span>` : ''; }

/* Aikaformatit */
const hmFi = new Intl.DateTimeFormat('fi-FI',{hour:'2-digit',minute:'2-digit',hour12:false,timeZone:TZ,hourCycle:'h23'});
function fmtHM(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}:${ps.find(p=>p.type==='minute')?.value||'00'}`; }
function fmtH(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}`; }

/* SmartSymbol – (päiväkoodit; yö %100) — sinun aiempi sanasto */
const SS_TEXT = {
  1:'sinistä', 2:'sangen sinistä', 4:'siniharmaata', 6:'sangen harmaata', 7:'harmaata',
  9:'MIST!',
  71:'Seppoa kutittaa.', 74:'Seppoa ärsyttää.', 77:'Seppo on vihainen.',
  21:'Kuuro jossain.', 24:'Kuuroja.', 27:'Kuuroja sakeana.',
  11:'Tihkuu.', 14:'Kryotihkua.', 17:'Kryosadetta.',
  31:'Siniharmaasta ripsii.', 34:'Sangen harmaasta ripsii.', 37:'Ripsii.',
  32:'Siniharmaasta satelee.', 35:'Sangen harmaasta satelee.', 38:'Satelee.',
  33:'Siniharmaasta kaatosadettakin.', 36:'Sangen harmaasta myös kaatosadettakin.', 39:'Kaatosadetta.',
  41:'Siniharmaasta märkä hiutale.', 44:'Sangen harmaasta märkä hiutale.', 47:'Märkä hiutale.',
  42:'Siniharmaasta räntää.', 45:'Sangen harmaasta räntää.', 48:'Räntää.',
  43:'Siniharmaasta tiskirättiä.', 46:'Sangen harmaasta tiskirättiä.', 49:'Tiskirättiä.',
  51:'Sinihirmaasta kevyt hiutale.', 54:'Sangen harmaasta kevyt hiutale.', 57:'Kevyt hiutale.',
  52:'Siniharmaasta lunta.', 55:'Sangen harmaasta lunta.', 58:'Lunta.',
  53:'Siniharmaasta pyryä.', 56:'Sangen harmaasta pyryä.', 59:'Pyryttää.',
  61:'Rakeita jossain.', 64:'Rakeita.', 67:'Rakeiden tulitus.'
};
const ssText = c => { if (c==null) return ''; const key=Number(c)%100; return SS_TEXT[key]||''; };

const PRECIP_CODES = new Set([
  11,14,17,21,24,27,31,32,33,34,35,36,37,38,39,41,42,43,44,45,46,47,48,49,
  51,52,53,54,55,56,57,58,59,61,64,67,71,74,77
]);
const THUNDER_CODES = new Set([71,74,77]);
const SHOWER_NON_THUNDER = new Set([21,24,27,61,64,67]);

/* Nowcast symbol_code sanasto (yö/päivä normalisoitu) — täsmälleen pyyntösi mukaan */
const NC_SYMBOL = {
  'clearsky': "sinistä",
  'fair': "sangen sinistä",
  'partlycloudy': "siniharmaata",
  'cloudy': "harmaata",
  'lightrainshowers': "Jokunen kuuro.",
  'heavyrainshowers': "Äänekästä kuuroa.",
  'rainshowersandthunder': "Sepon välisuihkut.",
  'thunderstorm': "Seppo riehuu.",
  'heavyrain': "Saavista kaatuu.",
  'lightrain': "Ripsii.",
  'sleet': "Räntää.",
  'lightsleetshowers_and_thunder': "Sepon tiskivuoro.",
  'snowshowers_and_thunder': "Lumiukkonen.",
  'snow': "Lunta.",
  'heavysnow': "Pyryttää.",
  'fog': "MIST!"
};
/* Normalisoi _day/_night pois ja palauta teksti */
function ncSymbolText(code){
  if (!code) return '';
  const base = code.replace(/_(day|night)$/,'');
  return NC_SYMBOL[base] || '';
}

/* Downgrade sateinen SS → pilvisyydeksi (tekstiheuriistiikka) */
function downgradeToCloudiness(descRaw){
  if (!descRaw) return 'pilvistä';
  const s = descRaw.toLowerCase();
  if (s.includes('siniharmaasta') || s.includes('sinihirmaasta')) return 'siniharmaata';
  if (s.includes('sangen harmaasta')) return 'sangen harmaata';
  return 'pilvistä';
}
function stripPunct(s){ return (s||'').replace(/[.!?]+$/,'').trim(); }
function prettyDescNonFirst(descRaw){ return descRaw || '–'; }

/* FMI WFS */
function buildWfsForecast(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::forecast::harmonie::surface::point::timevaluepair';
  const params='temperature,precipitation1h,windspeedms,SmartSymbol';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-2); e.setHours(e.getHours()+24);
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=60`;
}

/* XML → sarjat */
const parseXML = txt => {
  const x = new DOMParser().parseFromString(txt,'application/xml');
  const ex = x.querySelector('Exception, ows\\:Exception');
  if (ex){ const t=x.querySelector('ExceptionText, ows\\:ExceptionText'); throw new Error('FMI virhe: '+(t?t.textContent:'Tuntematon virhe')); }
  return x;
};
const extractSeries = x => {
  const get=(e,n)=>e.getElementsByTagNameNS('*',n)[0];
  const all=x.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTimeseries');
  const o={};
  for (const s of all){
    const id=(s.getAttribute('gml:id')||'').toLowerCase();
    let k='';
    if (id.includes('temperature')) k='temperature';
    else if (id.includes('precipitation1h')) k='precipitation1h';
    else if (id.includes('windspeedms')) k='windspeedms';
    else if (id.includes('smartsymbol')) k='SmartSymbol';
    if (!k) continue;
    const map=new Map();
    const pts=s.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTVP');
    for (const p of pts){
      const t=get(p,'time')?.textContent;
      const v=get(p,'value')?.textContent;
      if (!t) continue;
      const num = v!=null ? Number(v) : null;
      map.set(t, isNaN(num)?null:num);
    }
    o[k]=map;
  }
  return o;
};

/* MET Nowcast – sade + puuska + symbol_code (t0–t2) */
async function fetchNowcastForHour(lat, lon, dUTC){
  try{
    const url = `https://api.met.no/weatherapi/nowcast/2.0/complete?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&altitude=0`;
    const res = await fetch(url, { cache:'no-store', headers: { 'Accept': 'application/json' } });
    if (!res.ok) return { val:null, meta:`NC!${res.status}` };
    const js = await res.json();
    const ts = js?.properties?.timeseries;
    if (!Array.isArray(ts) || !ts.length) return { val:null, meta:'NC!empty' };

    const targetUTC = dUTC.getTime();
    let best = ts.find(it => new Date(it.time).getTime() === targetUTC);
    if (!best){
      const fut = ts.map(it=>({t:new Date(it.time).getTime(), it})).filter(x=>x.t>=targetUTC).sort((a,b)=>a.t-b.t)[0];
      if (fut && (fut.t - targetUTC) <= 30*60*1000) best = fut.it;
    }
    if (!best){
      let cand=null, diff=1e12;
      for (const it of ts){ const dt=Math.abs(new Date(it.time).getTime()-targetUTC); if (dt<diff){diff=dt; cand=it;} }
      if (cand && diff <= 20*60*1000) best = cand;
    }
    if (!best) return { val:null, meta:'NC!miss' };

    const acc  = best?.data?.next_1_hours?.details?.precipitation_amount;
    const pr   = best?.data?.instant?.details?.precipitation_rate;
    const gust = best?.data?.instant?.details?.wind_speed_of_gust;
    const sym  = best?.data?.next_1_hours?.summary?.symbol_code || null;

    let p = null;
    if (typeof acc === 'number') p = acc;
    else if (typeof pr === 'number') p = pr;

    return { val:(typeof p==='number'?p:null), meta:'NC', gust:(typeof gust==='number'?gust:null), sym };
  }catch{ return { val:null, meta:'NC!err' }; }
}

/* Solut */
function rainCell(val, {markGrey=false}={}){
  if (val==null || isNaN(Number(val))) return { text:'–', cls:'soft', num:null };
  const n = Number(val);
  if (n === 0) return { text:'—', cls:'soft dash', num:0 };
  return { text:n.toFixed(1)+' mm', cls:(markGrey?'soft':''), num:n };
}
function windCell(mean, gust, {baseGrey=true}={}){
  const mOk = (mean!=null && !isNaN(Number(mean)));
  const gOk = (gust!=null && !isNaN(Number(gust)));
  const meanV = mOk ? Number(mean) : null;
  const gustV = gOk ? Number(gust) : null;
  let txt = (mOk ? meanV.toFixed(1)+' m/s' : '–');

  let gustTxt = '';
  let gustWhite = false;
  if (gOk && gustV >= 15){
    gustTxt = ` (<span style="color:#e8e8e8">${gustV.toFixed(1)}</span>)`;
    gustWhite = true;
  }
  const meanWhite = (mOk && meanV >= 12);
  const cls = (meanWhite || gustWhite) ? '' : (baseGrey ? 'soft' : '');
  return { text: txt + gustTxt, cls };
}

/* Taulukon teko */
(async function(){
  scrollTo(0,1); setTimeout(()=>scrollTo(0,1),150);
  if (!LAT || !LON || isNaN(LAT) || isNaN(LON)){
    out.innerHTML = `<div class="err">Puuttuvat tai virheelliset koordinaatit. Käytä:<br><code>?lat=60.1699&lon=24.9384</code></div>`;
    return;
  }

  try{
    const fRes = await fetch(buildWfsForecast(LAT,LON), {cache:'no-store'});
    const fTxt = await fRes.text();
    if (!fRes.ok){ out.innerHTML = `<div class="err">FMI ennuste HTTP ${fRes.status}\n${fTxt.slice(0,400)}</div>`; return; }
    const forecast = extractSeries(parseXML(fTxt));

    const now = new Date();
    const thisHourLocal  = new Date(new Date(now).setMinutes(0,0,0));

    const fKeys = Array.from(forecast.temperature?.keys?.()||[]).sort();
    const pickKeys = [];
    for (const k of fKeys){
      const d = new Date(k);
      if (d >= thisHourLocal){ pickKeys.push(k); if (pickKeys.length>=13) break; }
    }
    if (!pickKeys.length){ out.innerHTML = `<div class="muted">Ei rivejä tälle ikkunalle.</div>`; return; }

    const d0 = new Date(pickKeys[0]);
    const d1 = pickKeys[1] ? new Date(pickKeys[1]) : null;
    const d2 = pickKeys[2] ? new Date(pickKeys[2]) : null;
    const [nc0, nc1, nc2] = await Promise.all([
      fetchNowcastForHour(LAT, LON, d0),
      d1 ? fetchNowcastForHour(LAT, LON, d1) : Promise.resolve({val:null, meta:'NC!skip'}),
      d2 ? fetchNowcastForHour(LAT, LON, d2) : Promise.resolve({val:null, meta:'NC!skip'})
    ]);

    let html = '';
    let prevDescRaw = null;

    /* t0 (nyt) */
    {
      const key = pickKeys[0];
      const temp = forecast.temperature?.get(key);
      const wind = forecast.windspeedms?.get(key);
      const ss   = forecast.SmartSymbol?.get(key);
      const ssDay = (ss!=null) ? Number(ss)%100 : null;

      const rainVal0 = (nc0 && typeof nc0.val==='number') ? nc0.val : null;
      const rObj = (rainVal0!=null && rainVal0<0.1) ? {text:'—', cls:'soft dash', num:0} : rainCell(rainVal0);
      const rainHtml = `${rObj.text}${tag('NC')}`;
      const timeClass = (rObj.num!=null && rObj.num > 0) ? 't' : 't soft';

      const wObj = windCell(wind, (nc0 && typeof nc0.gust==='number' ? nc0.gust : null), { baseGrey:true });

      // Kuvaus: ensisijaisesti Nowcast symbol_code, muuten aiempi logiikka
      let baseDesc = ncSymbolText(nc0?.sym);
      if (!baseDesc){
        if (rainVal0!=null && rainVal0>=0.1){
          baseDesc = 'Sadetta.'; // varmistus jos SS puuttuu; (aiemmassa versiossa käytettiin ncTextForRain)
        }else{
          const raw = ssText(ss) || '–';
          if ((rainVal0!=null && rainVal0<0.1) && SHOWER_NON_THUNDER.has(ssDay)){
            baseDesc = 'siniharmaata';
          }else if ((rainVal0!=null && rainVal0<0.1) && ssDay!=null && PRECIP_CODES.has(ssDay)){
            baseDesc = downgradeToCloudiness(raw);
          }else{
            baseDesc = raw;
          }
        }
      }
      // Ukkonen lisäviitteenä aina SS:stä
      const thunderNote = THUNDER_CODES.has(ssDay) ? ` (<em>${stripPunct(ssText(ss)||'')}?</em>)` : '';
      const desc = baseDesc + thunderNote;

      html += `<div class="row">
        <div class="${timeClass}">${fmtHM(now)}</div>
        <div class="soft">${temp!=null?Math.round(temp)+'°C':'–'}</div>
        <div class="desc ${ (rObj.num!=null && rObj.num>=0.1) || nc0?.sym ? '' : 'soft' }">${desc}</div>
        <div class="${rObj.cls||''}">${rainHtml}</div>
        <div class="${wObj.cls||''}">${wObj.text}</div>
      </div>`;
      prevDescRaw = ssText(ss) || '–';
    }

    /* t+1h */
    if (pickKeys.length >= 2){
      const key = pickKeys[1], dUtc = new Date(key);
      const temp = forecast.temperature?.get(key);
      const wind = forecast.windspeedms?.get(key);
      const rain = forecast.precipitation1h?.get(key);
      const ss   = forecast.SmartSymbol?.get(key);
      const ssDay = (ss!=null) ? Number(ss)%100 : null;

      let rObj, rTag='NC', rainUsed=null;
      if (nc1 && typeof nc1.val==='number'){
        rObj = (nc1.val<0.1) ? {text:'—', cls:'soft dash', num:0} : rainCell(nc1.val);
        rainUsed = (nc1.val<0.1) ? 0 : nc1.val;
      } else {
        rObj = rainCell(rain, {markGrey:true}); rainUsed=(typeof rain==='number'?rain:null); rTag='HRM';
      }
      const timeClass = (rainUsed!=null && rainUsed > 0) ? 't' : 't soft';

      const wObj = windCell(wind, (nc1 && typeof nc1.gust==='number' ? nc1.gust : null), { baseGrey:true });

      // desc: ensisijaisesti Nowcast symbol_code
      let baseDesc = ncSymbolText(nc1?.sym);
      if (!baseDesc){
        if (rainUsed!=null && rainUsed>=0.1){
          baseDesc = 'Sadetta.';
        }else{
          const raw = ssText(ss) || '–';
          if ((rainUsed!=null && rainUsed<0.1) && SHOWER_NON_THUNDER.has(ssDay)){
            baseDesc = 'siniharmaata';
          }else if ((rainUsed!=null && rainUsed<0.1) && ssDay!=null && PRECIP_CODES.has(ssDay)){
            baseDesc = downgradeToCloudiness(raw);
          }else{
            baseDesc = raw;
            if (raw === prevDescRaw && raw !== '–') baseDesc = '<span class="ditto" title="sama kuin edellä">&raquo;</span>';
          }
        }
      }
      const thunderNote = THUNDER_CODES.has(ssDay) ? ` (<em>${stripPunct(ssText(ss)||'')}?</em>)` : '';
      const desc = baseDesc + thunderNote;
      prevDescRaw = ssText(ss) || '–';

      html += `<div class="row">
        <div class="${timeClass}">${fmtHM(dUtc)}</div>
        <div class="soft">${temp!=null?Math.round(temp)+'°C':'–'}</div>
        <div class="desc ${ (rainUsed!=null && rainUsed>=0.1) || nc1?.sym ? '' : 'soft' }">${desc}</div>
        <div class="${rObj.cls||''}">${rObj.text}${tag(rTag)}</div>
        <div class="${wObj.cls||''}">${wObj.text}</div>
      </div>`;
    }

    /* t+2h */
    if (pickKeys.length >= 3){
      const key = pickKeys[2], dUtc = new Date(key);
      const temp = forecast.temperature?.get(key);
      const wind = forecast.windspeedms?.get(key);
      const rain = forecast.precipitation1h?.get(key);
      const ss   = forecast.SmartSymbol?.get(key);
      const ssDay = (ss!=null) ? Number(ss)%100 : null;

      let rObj, rTag='NC', rainUsed=null;
      if (nc2 && typeof nc2.val==='number'){
        rObj = (nc2.val<0.1) ? {text:'—', cls:'soft dash', num:0} : rainCell(nc2.val);
        rainUsed = (nc2.val<0.1) ? 0 : nc2.val;
      } else {
        rObj = rainCell(rain, {markGrey:true}); rainUsed=(typeof rain==='number'?rain:null); rTag='HRM';
      }
      const timeClass = (rainUsed!=null && rainUsed > 0) ? 't' : 't soft';

      const wObj = windCell(wind, (nc2 && typeof nc2.gust==='number' ? nc2.gust : null), { baseGrey:true });

      let baseDesc = ncSymbolText(nc2?.sym);
      if (!baseDesc){
        if (rainUsed!=null && rainUsed>=0.1){
          baseDesc = 'Sadetta.';
        }else{
          const raw = ssText(ss) || '–';
          if ((rainUsed!=null && rainUsed<0.1) && SHOWER_NON_THUNDER.has(ssDay)){
            baseDesc = 'siniharmaata';
          }else if ((rainUsed!=null && rainUsed<0.1) && ssDay!=null && PRECIP_CODES.has(ssDay)){
            baseDesc = downgradeToCloudiness(raw);
          }else{
            baseDesc = raw;
            if (raw === prevDescRaw && raw !== '–') baseDesc = '<span class="ditto" title="sama kuin edellä">&raquo;</span>';
          }
        }
      }
      const thunderNote = THUNDER_CODES.has(ssDay) ? ` (<em>${stripPunct(ssText(ss)||'')}?</em>)` : '';
      const desc = baseDesc + thunderNote;
      prevDescRaw = ssText(ss) || '–';

      html += `<div class="row">
        <div class="${timeClass}">${fmtHM(dUtc)}</div>
        <div class="soft">${temp!=null?Math.round(temp)+'°C':'–'}</div>
        <div class="desc ${ (rainUsed!=null && rainUsed>=0.1) || nc2?.sym ? '' : 'soft' }">${desc}</div>
        <div class="${rObj.cls||''}">${rObj.text}${tag(rTag)}</div>
        <div class="${wObj.cls||''}">${wObj.text}</div>
      </div>`;
    }

    /* t+3…t+12 – forceGrey jos (drizzle-set) & sade <0.3 */
    const drizzleCodes = new Set([11,31,34,37,41,44,47,51,54,57]); // + yö %100
    for (let i=3; i<pickKeys.length; i++){
      const key = pickKeys[i], dUtc = new Date(key);
      const temp = forecast.temperature?.get(key);
      const rain = forecast.precipitation1h?.get(key);
      const wind = forecast.windspeedms?.get(key);
      const ss   = forecast.SmartSymbol?.get(key);

      const ssDay = (ss!=null) ? (Number(ss)%100) : null;

      const tmp = rainCell(rain);
      const wet  = (tmp.num!=null && tmp.num > 0);
      const forceGrey = (wet && tmp.num < 0.3 && drizzleCodes.has(ssDay));
      const rObj = forceGrey ? rainCell(rain, {markGrey:true}) : rainCell(rain);

      const descRaw = ssText(ss) || '–';
      const descPretty =
        (descRaw === prevDescRaw && descRaw !== '–')
          ? '<span class="ditto" title="sama kuin edellä">&raquo;</span>'
          : prettyDescNonFirst(descRaw);
      prevDescRaw = descRaw;

      const wObj = windCell(wind, null, { baseGrey:true });
      const highlight = wet && !forceGrey;

      html += `<div class="row">
        <div class="t hh ${highlight?'':'soft'}"><span class="${highlight?'miniW':'mini'}">klo&nbsp;</span>${fmtH(dUtc)}</div>
        <div class="${highlight?'':'soft'}">${temp!=null?Math.round(temp)+'°C':'–'}</div>
        <div class="desc ${highlight?'':'soft'}">${descPretty}</div>
        <div class="${rObj.cls||''}">${rObj.text}${tag('HRM')}</div>
        <div class="${highlight?'':'soft'}">${wObj.text}</div>
      </div>`;
    }

    out.innerHTML = html || `<div class="muted">Ei rivejä tälle ikkunalle.</div>`;
  }catch(e){
    out.innerHTML = `<div class="err">${String(e.message||e)}</div>`;
  }
})();
</script>
