<!doctype html>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="noindex">
<title>SÄÄ SEURAAVAT 12 h (FMI)</title>
<style>
  :root { color-scheme: dark; }
  html,body{height:100%}
  body{
    margin:0; padding:28px 14px 24px; background:#000; color:#e8e8e8;
    font:17px/1.5 Arial,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility
  }

  /* yläreunan harmaa viiva + lista */
  .list{
    border-top:1px solid #2a2a2a;
    margin-top:6px;
  }

  /* pieni harmaa "klo" ankkuri kellosarakkeen ylle */
  .klohdr{
    color:#9aa; font-size:12px; letter-spacing:.3px;
    margin:6px 0 4px 0;
    display:grid;
    grid-template-columns:54px 64px 1fr 70px 64px; /* sama rytmi kuin riveillä */
  }
  .klohdr > div:first-child{
    border-right:1px solid #2a2a2a;
    padding-right:10px; margin-right:4px;
  }
  .klohdr > div:not(:first-child){ visibility:hidden; } /* muut otsakkeet piiloon */

  /* rivit */
  .row{
    display:grid; grid-template-columns:54px 64px 1fr 70px 64px;
    gap:8px; padding:6px 0; border-bottom:1px solid #1c1c1c;
  }
  /* pystyviiva kellosarakkeen jälkeen */
  .row > div:first-child{
    border-right:1px solid #2a2a2a;
    padding-right:10px; margin-right:4px;
  }

  .muted{ color:#95a0aa }
  .err{ color:#ff6b6b; white-space:pre-wrap }
</style>

<!-- "klo" ankkuri -->
<div class="klohdr"><div>klo</div><div></div><div></div><div></div><div></div></div>

<!-- lista + rivit -->
<div class="list" id="out" aria-live="polite"></div>

<script>
/* FMI super-min 12 h — HH:MM, dedup-kuvaukset, laajennettu Weathersymbol3, fallback sateesta
   Koordinaatit vain URL:sta (?lat=...&lon=...)
*/
const q = new URLSearchParams(location.search);
const LAT = q.get('lat');
const LON = q.get('lon');
const TZ  = 'Europe/Helsinki';

const out = document.getElementById('out');

/* Aika: pakota aina HH:MM (kaksoispiste), ei 13.45-muotoa */
const tFmt = new Intl.DateTimeFormat('fi-FI', {
  hour:'2-digit', minute:'2-digit', hour12:false, timeZone:TZ, hourCycle:'h23'
});
function fmtHM(d){
  const parts = tFmt.formatToParts(d);
  const hh = parts.find(p=>p.type==='hour')?.value ?? '00';
  const mm = parts.find(p=>p.type==='minute')?.value ?? '00';
  return `${hh}:${mm}`;
}

/* Weathersymbol3 → FI-teksti (laajennettu). Palauttaa '' jos ei tunnisteta. */
function sym(code){
  const m = {
    // pouta & pilvisyys
    1:'poutaa',
    2:'pilvipoutaa',
    3:'pilvistä',
    21:'sumua',
    22:'utua',

    // tihku (drizzle)
    51:'tihkuntapaista',
    52:'tihkua',
    53:'sakeaa tihkua',

    // sade (jatkuva)
    61:'ripsii',
    62:'sataa',
    63:'Esterin',

    // lumi
    71:'hiutaloi',
    72:'lunta',
    73:'pyryttää',

    // räntä (sleet / rain+snow)
    68:'räntää',
    69:'Eiran Räntä',

    // kuurot (showers)
    41:'kuurohkoja',
    42:'kuuroja',
    43:'suurkuuroja',

    // ukkonen
    80:'ukkosta',
    95:'ukkoskuuroja',
    96:'raeukkosta',
    97:'ISO VASARA'
  };
  return m[Number(code)] || '';
}

/* Fallback-kuvaus sademäärästä, jos symbolia ei tunnisteta/puutu */
function fallbackFromRain(rain){
  const p = (rain == null ? 0 : Number(rain));
  if (p >= 7.0) return 'Esterin';
  if (p >= 2.0) return 'sataa';
  if (p >  0.1) return 'ripsii';
  return '–'; // pouta → viiva (pidetään minimalistisena)
}

/* WFS-kysely (nyt..+12h) */
function buildUrl(lat, lon){
  const base = 'https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq   = 'fmi::forecast::harmonie::surface::point::timevaluepair';
  const params = 'temperature,precipitation1h,windspeedms,Weathersymbol3';
  const now = new Date(), end = new Date(now); end.setHours(end.getHours()+12);
  const iso = d => d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(now))}&endtime=${encodeURIComponent(iso(end))}&timestep=60`;
}

const parseXML = txt => {
  const x = new DOMParser().parseFromString(txt, 'application/xml');
  const ex = x.querySelector('Exception, ows\\:Exception');
  if (ex) {
    const t = x.querySelector('ExceptionText, ows\\:ExceptionText');
    throw new Error('FMI virhe: ' + (t ? t.textContent : 'Tuntematon virhe'));
  }
  return x;
};

const extract = x => {
  const get = (e,n)=>e.getElementsByTagNameNS('*',n)[0];
  const all = x.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTimeseries');
  const o = {};
  for (const s of all) {
    const id = (s.getAttribute('gml:id') || '').toLowerCase();
    let k = '';
    if      (id.includes('temperature'))      k = 'temperature';
    else if (id.includes('precipitation1h'))  k = 'precipitation1h';
    else if (id.includes('windspeedms'))      k = 'windspeedms';
    else if (id.includes('weathersymbol3'))   k = 'Weathersymbol3';
    if (!k) continue;
    const map = new Map();
    for (const p of s.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTVP')){
      const t = get(p,'time')?.textContent;
      const v = get(p,'value')?.textContent;
      if (!t) continue;
      const num = v!=null ? Number(v) : null;
      map.set(t, isNaN(num) ? null : num);
    }
    o[k] = map;
  }
  return o;
};

function fetchWithTimeout(ms=9000){
  const ctrl = new AbortController();
  const t = setTimeout(()=>ctrl.abort(), ms);
  return { signal: ctrl.signal, clear: ()=>clearTimeout(t) };
}

(async () => {
  // pikkutemppu: tiputa osoitepalkki heti avauksessa
  scrollTo(0,1); setTimeout(()=>scrollTo(0,1), 150);

  if (!LAT || !LON) {
    out.innerHTML = `<div class="err">Puuttuvat koordinaatit. Käytä osoitetta muodossa:<br>
<code>?lat=60.1699&lon=24.9384</code></div>`;
    return;
  }

  try{
    const t = fetchWithTimeout(9000);
    const res = await fetch(buildUrl(LAT, LON), { cache:'no-store', signal: t.signal });
    t.clear();
    const txt = await res.text();
    if (!res.ok) throw new Error(`HTTP ${res.status}\n${txt.slice(0,200)}`);

    const ser = extract(parseXML(txt));
    const now = new Date(), end = new Date(now); end.setHours(end.getHours()+12);

    let html = '';
    let prevDesc = null; // peräkkäisten kuvausten piilotus

    for (let d = new Date(now); d <= end; d.setHours(d.getHours()+1)) {
      const utc = new Date(Date.UTC(
        d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours()
      )).toISOString().replace(/\.\d{3}Z$/,'Z');

      const temp = ser.temperature?.get(utc);
      const rain = ser.precipitation1h?.get(utc);
      const wind = ser.windspeedms?.get(utc);
      const wsym = ser.Weathersymbol3?.get(utc);

      const rawDesc   = sym(wsym);
      const descCore  = (rawDesc !== '') ? rawDesc : fallbackFromRain(rain);
      const desc      = descCore; // ei näytetä (WS3:xx) -koodia oletuksena

      const shownDesc = (desc === prevDesc && desc !== '–') ? '' : desc;
      prevDesc = desc;

      html += `<div class="row">
        <div>${fmtHM(new Date(d))}</div>
        <div>${temp!=null ? Math.round(temp) + '°C' : '–'}</div>
        <div>${shownDesc}</div>
        <div>${rain!=null ? rain.toFixed(1) + ' mm' : '–'}</div>
        <div>${wind!=null ? wind.toFixed(1) + ' m/s' : '–'}</div>
      </div>`;
    }

    out.innerHTML = html || `<div class="muted">Ei rivejä tälle ajalle.</div>`;
  } catch (e) {
    out.innerHTML = `<div class="err">${String(e.message || e)}</div>`;
  }
})();
</script>
