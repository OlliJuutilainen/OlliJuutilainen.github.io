<!doctype html>
<html lang="fi">
<head>
<script>
(function() {
  const hash = location.hash && location.hash.startsWith('#') ? location.hash.slice(1) : '';
  const searchFallback = (!hash && location.search && location.search.startsWith('?')) ? location.search.slice(1) : '';
  const P = new URLSearchParams(hash || searchFallback);

  function requireParam(value, name){
    if (typeof value !== 'string' || value.length === 0){
      throw new Error(`Puuttuva tai virheellinen parametri: ${name}`);
    }
    return value;
  }

  const T = requireParam((() => {
    const primary = P.get('t');
    if (typeof primary === 'string' && primary.length > 0) return primary;
    const fallback = P.get('token');
    return fallback;
  })(), 't');
  const K = requireParam((() => {
    const primary = P.get('k');
    if (typeof primary === 'string' && primary.length > 0) return primary;
    const fallback = P.get('key');
    return fallback;
  })(), 'k');

  console.log('DEBUG href=', location.href);
  console.log('DEBUG T=', T, 'K=', K);

  const API_BASE = 'https://tusinasaa-worker.ollijuutilainen.workers.dev';

  fetch(`${API_BASE}/api/loc?t=${encodeURIComponent(T)}`, { cache: 'no-store' })
    .then(r => { if (!r.ok) throw new Error(`KV 404/400 (${r.status})`); return r.json(); })
    .then(({v, iv, ct}) => decryptAndUse(K, iv, ct))
    .catch(err => console.error('Haku epäonnistui:', err));

  function b64uToBytes(s){
    if (typeof s !== 'string' || s.length === 0){
      throw new Error('b64uToBytes: input ei ole kelvollinen merkkijono');
    }
    const normalized = s.replace(/-/g,'+').replace(/_/g,'/');
    const pad = (4 - normalized.length % 4) % 4;
    const padded = normalized + '='.repeat(pad);
    const bin = atob(padded);
    const out = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
    return out;
  }
  async function decryptAndUse(k, iv, ct){
    try {
      const keyBytes = b64uToBytes(k);
      const ivBytes  = b64uToBytes(iv);
      const ctBytes  = b64uToBytes(ct);
      const cryptoKey = await crypto.subtle.importKey('raw', keyBytes, {name:'AES-GCM'}, false, ['decrypt']);
      const plain = await crypto.subtle.decrypt({name:'AES-GCM', iv: ivBytes}, cryptoKey, ctBytes);
      const cfg = JSON.parse(new TextDecoder().decode(new Uint8Array(plain)));
      const { lat, lon, z=13 } = cfg;
      console.log('Tusinasää coords:', lat, lon, z);
      // TODO: käytä arvoja UI:ssa…
    } catch (e) {
      console.error('Purku epäonnistui:', e);
    }
  }
})();
</script>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="noindex">
<title>TUSINASÄÄ 12</title>
<!-- ohjelman leima: TUSINASÄÄ 12 versio 1.1.1 -->
<style>
  :root {
    color-scheme: dark;
    --color-bg: #000;
    --color-text: #e8e8e8;
    --color-page-title: #9aa6b0;
    --color-mini: #7f8a93;
    --color-mini-strong: #e8e8e8;
    --color-muted: #74808a;
    --color-soft: #7f8a93;
    --color-border: #2a2a2a;
    --color-border-strong: #1c1c1c;
    --color-badge-default: #7f8a93;
    --color-badge-nc: #9fb6ff;
    --color-badge-nc-border: #35415a;
    --color-badge-hrm: #b7b7b7;
    --color-badge-hrm-border: #3a3a3a;
    --color-badge-fallback: #d9b27d;
    --color-badge-fallback-border: #5a4528;
    --color-error: #ff6b6b;
    --color-error-note: #888;
    --color-contradiction: #a65050;
  }
  @media (prefers-color-scheme: light){
    :root {
      color-scheme: light;
      --color-bg: #f7f8fa;
      --color-text: #1c1f22;
      --color-page-title: #5a6570;
      --color-mini: #646f78;
      --color-mini-strong: #1c1f22;
      --color-muted: #596470;
      --color-soft: #68737e;
      --color-border: #d5d9df;
      --color-border-strong: #c5c9cf;
      --color-badge-default: #68737e;
      --color-badge-nc: #4a5dab;
      --color-badge-nc-border: #a8b4cf;
      --color-badge-hrm: #555b60;
      --color-badge-hrm-border: #c3c6ca;
      --color-badge-fallback: #8d6c3f;
      --color-badge-fallback-border: #d8c2a3;
      --color-error: #c34242;
      --color-error-note: #666;
      --color-contradiction: #c46464;
    }
  }
  html,body{height:100%}
  body{
    margin:0; padding:22px 14px 24px; background:var(--color-bg); color:var(--color-text);
    font:17px/1.5 Arial,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
    font-synthesis:none;
  }
  .pageTitle{ font-weight:700; font-size:15px; letter-spacing:.4px; color:var(--color-page-title);
    text-transform:uppercase; margin:0 0 4px 0 }
  .mini{ color:var(--color-mini); font-size:12px; letter-spacing:.3px; line-height:1.2 }
  .miniTwilight{ font-style:italic; font-weight:300 }
  .twilightMainText{
    font-size:13px;
    text-transform:uppercase;
    letter-spacing:.6px;
    font-style:italic;
    font-weight:350;
    font-variation-settings:'wght' 350;
  }
  @supports not (font-weight: 350){
    .twilightMainText{
      font-weight:300;
    }
  }
  .miniPrefixed::before{
    content:'';
    display:inline-block;
    width:var(--mini-ellipsis-width, 10px);
  }
  .miniW{ color:var(--color-mini-strong); font-size:12px; letter-spacing:.3px; line-height:1.2 }
  .caps{ text-transform:uppercase; letter-spacing:.5px }
  .list{ border-top:1px solid var(--color-border); margin-top:6px; }
  .sourceBadge{
    display:inline-block;
    margin-left:6px;
    padding:1px 5px 0;
    border:1px solid var(--color-border);
    border-radius:3px;
    font-size:11px;
    letter-spacing:.3px;
    text-transform:uppercase;
    color:var(--color-badge-default);
  }
  .sourceBadgeNc{ color:var(--color-badge-nc); border-color:var(--color-badge-nc-border); }
  .sourceBadgeHrm{ color:var(--color-badge-hrm); border-color:var(--color-badge-hrm-border); }
  .sourceBadgeFallback{ color:var(--color-badge-fallback); border-color:var(--color-badge-fallback-border); }
  .hdr{
    color:var(--color-muted); font-size:12px; letter-spacing:.3px; margin:6px 0 4px 0;
    display:grid; grid-template-columns:54px 34px 1fr 70px 70px; align-items:end; justify-items:center;
    gap:8px;
  }
  .hdr > div:first-child{ border-right:1px solid var(--color-border); padding-right:10px; margin-right:4px }
  .hdr div:nth-child(-n+3){ justify-self:start; text-align:left }
  .hdr div:nth-child(4){ justify-self:center; text-align:center; transform:translateX(-1px) }
  .hdr div:nth-child(5){ justify-self:start; text-align:left; font-size:11px }
  .row{
    display:grid; grid-template-columns:54px 34px 1fr 70px 70px;
    gap:8px; padding:6px 0; border-bottom:1px solid var(--color-border-strong); align-items:center;
    min-height:54px;
  }
  .row > div:first-child{ border-right:1px solid var(--color-border); padding-right:10px; margin-right:4px; text-align:right }
  .muted{ color:var(--color-muted) } .soft{ color:var(--color-soft) }
  .cell{ color:var(--color-text) }
  .cell.soft{ color:var(--color-soft) }
  .desc{ color:var(--color-soft) }
  .descWhite{ color:var(--color-mini-strong) }
  .contradictionMain{ text-decoration:line-through; text-decoration-thickness:1.1px; text-decoration-color:var(--color-contradiction); text-decoration-skip-ink:auto }
  .contradictionNote{ display:block; font-size:9px; font-style:italic; color:var(--color-error-note); letter-spacing:.2px; margin-top:2px }
  .row > div:nth-child(4){ text-align:center }
  .row > div:nth-child(5){ font-size:16px }
  .desc .ditto{ display:inline } .ditto{ color:inherit }
  .dash{ text-align:center }
  .windDir{ display:block; margin-top:2px; font-size:11px }
  .err{ color:var(--color-error); white-space:pre-wrap; font-size:14px; margin-top:8px }
</style>
</head>
<body>

<h1 id="pageTitle" class="pageTitle" style="display:none"></h1>

<div class="hdr">
  <div></div><div></div><div></div>
  <div class="caps">SADE</div>
  <div class="caps">TUULEE</div>
</div>
<div class="list" id="out" aria-live="polite"></div>

<script src="https://unpkg.com/tz-lookup@6.1.25/dist/tz.js"></script>
<script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.min.js"></script>

<script type="module">
/* --------- perusinfra & virheet näkyviin --------- */
/* --------- tonttien työlista (palaverin jatkotoimet) --------- */
/*
1. Yhtenäistä pääselitteen kirjainkoko niin, että `lowercaseMainDescription`
   ajetaan kaikissa vaiheissa ilman päivä-vaiherajausta, ja varmista samalla,
   ettei tyhjät tai HTML-elementillä alkavat selitteet muutu.
2. Selvitä nousua edeltävien kuivien tuntien käsittely: kun hämärävaihe ei enää
   päädy päätekstiksi, varmista että kuivan sään kuvaus nostaa ensimmäisen
   kirjaimen isoksi ja ettei hämärän CSS-yläsuuraus laukea vahingossa.
3. Päivitä testisuunnitelma kattamaan sumu-, sade- ja kuivatapaukset sekä
   aurinkotapahtumien molemmat kieliasut, jotta kirjaimiston poikkeamat eivät
   palaa jatkokehityksessä.
*/
const out = document.getElementById('out');

function prependError(message){
  out.innerHTML = `<div class="err">${message}</div>` + out.innerHTML;
}

window.addEventListener('error', e => {
  if (e?.error && typeof e.error === 'object' && e.error.__tusinaHandled){
    return;
  }
  const msg = (e && e.message) ? e.message : String(e);
  const where = (e && e.filename) ? `\n@ ${e.filename}:${e.lineno||''}:${e.colno||''}` : '';
  prependError(`Virhe: ${msg}${where}`);
});
window.addEventListener('unhandledrejection', e => {
  const reason = e?.reason;
  if (reason && typeof reason === 'object' && reason.__tusinaHandled){
    return;
  }
  const msg = reason ? (reason.message || String(reason)) : 'tuntematon virhe';
  prependError(`Virhe (lupaus): ${msg}`);
});

function base64urlToBytes(b64u){
  if (typeof b64u !== 'string' || !b64u){
    throw new Error('Virheellinen base64url-merkkijono.');
  }
  const normalized = b64u.replace(/-/g, '+').replace(/_/g, '/');
  const padLength = (4 - normalized.length % 4) % 4;
  const padded = normalized + '='.repeat(padLength);
  const bin = atob(padded);
  const outArr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) outArr[i] = bin.charCodeAt(i);
  return outArr;
}

async function fetchAndDecryptLocation(token, keyB64u){
  const host = (typeof location === 'object' && typeof location.hostname === 'string')
    ? location.hostname.toLowerCase()
    : '';
  const configuredWorkerBase = (typeof window !== 'undefined' && (
    window.TUSINASAA_API_BASE || window.TUSINA_WORKER_BASE || window.TUSINA_API_BASE
  )) || 'https://tusinasaa-worker.ollijuutilainen.workers.dev';
  const workerBase = configuredWorkerBase.replace(/\/+$/, '');
  const useWorkerEndpoint = /\.github\.io$/.test(host);
  const endpointBase = useWorkerEndpoint ? workerBase : '';
  const endpoint = `${endpointBase}/api/loc?t=${encodeURIComponent(token)}`;
  const res = await fetch(endpoint, { cache: 'no-store', credentials: 'omit' });
  if (!res.ok){
    const sourceLabel = useWorkerEndpoint ? 'Cloudflare-työntekijästä' : 'palvelimelta';
    const errMsg = res.status === 404
      ? `Sijaintitokenia ei löytynyt (${sourceLabel}).`
      : `Sijaintipalvelu (${sourceLabel}) vastasi virheellä (${res.status}).`;
    throw new Error(errMsg);
  }

  let payload;
  try {
    payload = await res.json();
  } catch (err) {
    throw new Error('Sijaintipalvelu palautti virheellistä dataa.');
  }

  if (!payload || typeof payload !== 'object'){
    throw new Error('Sijaintipaketti puuttuu.');
  }

  const { v, iv, ct } = payload;
  const version = typeof v === 'string' ? parseInt(v, 10) : v;
  if (!Number.isFinite(version) || version !== 1){
    console.error('Tuntematon sijaintipaketin versio. Vastaanotettu paketti:', payload);
    throw new Error('Tuntematon sijaintipaketin versio.');
  }
  if (typeof iv !== 'string' || typeof ct !== 'string'){
    throw new Error('Sijaintipaketista puuttuu salausdata.');
  }

  let keyBytes, ivBytes, ctBytes;
  try {
    keyBytes = base64urlToBytes(keyB64u);
    ivBytes = base64urlToBytes(iv);
    ctBytes = base64urlToBytes(ct);
  } catch (err) {
    throw new Error('Sijaintipaketin base64url-muunnos epäonnistui.');
  }

  let cryptoKey;
  try {
    cryptoKey = await crypto.subtle.importKey('raw', keyBytes, { name: 'AES-GCM' }, false, ['decrypt']);
  } catch (err) {
    throw new Error('Sijaintiavain ei kelpaa AES-GCM -purkuun.');
  }

  let plaintext;
  try {
    plaintext = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: ivBytes }, cryptoKey, ctBytes);
  } catch (err) {
    throw new Error('Sijaintipaketin purku epäonnistui (AES-GCM).');
  }

  let parsed;
  try {
    const decoded = new TextDecoder().decode(new Uint8Array(plaintext));
    parsed = JSON.parse(decoded);
  } catch (err) {
    throw new Error('Sijaintipaketin sisältö on virheellinen.');
  }

  if (!parsed || !Number.isFinite(parsed.lat) || !Number.isFinite(parsed.lon)){
    throw new Error('Sijaintipaketista puuttuu kelvolliset lat/lon-arvot.');
  }

  return parsed;
}

/* --------- mittaa ellipsin leveys pienitekstissä --------- */
function initMiniEllipsisWidth(){
  if (!document?.body) return;
  const span = document.createElement('span');
  span.className = 'mini';
  span.textContent = '...';
  span.style.visibility = 'hidden';
  span.style.position = 'absolute';
  span.style.whiteSpace = 'pre';
  span.style.pointerEvents = 'none';
  document.body.appendChild(span);
  const rect = span.getBoundingClientRect();
  span.remove();
  const width = rect?.width;
  if (Number.isFinite(width) && width > 0){
    const px = width.toFixed(2)+'px';
    document.documentElement.style.setProperty('--mini-ellipsis-width', px);
    window.__miniEllipsisWidth = width;
  }
}
if (document.readyState === 'loading'){
  document.addEventListener('DOMContentLoaded', initMiniEllipsisWidth, { once: true });
} else {
  initMiniEllipsisWidth();
}

/* --------- URL-parametrit & sijainti --------- */
const q = new URLSearchParams(location.search);
const DBG = q.has('dbg');
const SHOW_SOURCE_BADGES = DBG || q.has('src');
const tag = s => DBG ? ` <span class="soft" style="font-size:12px">${s}</span>` : '';

let LAT_STR = q.get('lat');
let LON_STR = q.get('lon');
let ZOOM_PARAM = q.get('z');
let LOCATION_SOURCE = 'query';
let specialTitle = null;

const hashRaw = location.hash.startsWith('#') ? location.hash.slice(1) : location.hash;
const hashParams = new URLSearchParams(hashRaw);
const HASH_TOKEN = hashParams.get('t');
const HASH_KEY = hashParams.get('k');

if (HASH_TOKEN || HASH_KEY){
  if (!HASH_TOKEN || !HASH_KEY){
    const which = !HASH_TOKEN ? 'token (#t)' : 'avain (#k)';
    const msg = `Sijaintilinkistä puuttuu ${which}.`;
    prependError(msg);
    throw new Error(msg);
  }

  try {
    /* Hash-fragmentti on ensisijainen sijaintilähde; query-parametrit jäävät varatueksi kehitystilanteisiin. */
    const decrypted = await fetchAndDecryptLocation(HASH_TOKEN, HASH_KEY);
    LAT_STR = String(decrypted.lat);
    LON_STR = String(decrypted.lon);
    if (decrypted?.z != null) ZOOM_PARAM = String(decrypted.z);
    if (typeof decrypted?.title === 'string'){
      const trimmed = decrypted.title.trim();
      if (trimmed) specialTitle = trimmed.slice(0, 160);
    }
    LOCATION_SOURCE = 'hash';
    if (DBG){
      console.info('Sijainti purettu hash-fragmentista', { lat: LAT_STR, lon: LON_STR, z: ZOOM_PARAM, token: HASH_TOKEN });
    }
  } catch (err) {
    const detail = err?.message ? `: ${err.message}` : '';
    prependError(`Sijaintipaketin purku epäonnistui${detail}`);
    console.error('Sijaintipaketin purku epäonnistui', err);
    if (err && typeof err === 'object') err.__tusinaHandled = true;
    throw err;
  }
} else if (DBG && HASH_TOKEN == null && HASH_KEY == null){
  console.info('Hash-fragmenttia ei annettu; käytetään kehityksen query-parametreja.', { lat: LAT_STR, lon: LON_STR });
}

const LAT = parseFloat(LAT_STR);
const LON = parseFloat(LON_STR);

const FALLBACK_TIME_ZONE = (() => {
  try {
    const resolved = Intl.DateTimeFormat().resolvedOptions()?.timeZone;
    return (typeof resolved === 'string' && resolved) ? resolved : 'UTC';
  } catch (err) {
    return 'UTC';
  }
})();

function inferTimeZone(lat, lon){
  const fallback = FALLBACK_TIME_ZONE || 'UTC';
  if (Number.isFinite(lat) && Number.isFinite(lon)){
    try {
      if (typeof tzlookup === 'function'){
        const guess = tzlookup(lat, lon);
        if (typeof guess === 'string' && guess) return guess;
      }
    } catch (err) {
      if (DBG) console.warn('tzlookup fail', err);
    }
  }
  return fallback;
}

let timeZone = inferTimeZone(LAT, LON);
if (typeof timeZone !== 'string' || !timeZone){
  timeZone = FALLBACK_TIME_ZONE || 'UTC';
}
const TZ = timeZone;

/* --------- erikoisotsikot --------- */
const pageTitle = document.getElementById('pageTitle');
if (!specialTitle){
  const queryTitleRaw = q.get('title');
  if (typeof queryTitleRaw === 'string'){
    const trimmed = queryTitleRaw.trim();
    if (trimmed) specialTitle = trimmed.slice(0, 160);
  }
}
if (specialTitle){
  pageTitle.textContent = specialTitle;
  pageTitle.style.display = '';
}

/* --------- aikaformatit --------- */
const hmFi = new Intl.DateTimeFormat('fi-FI',{hour:'2-digit',minute:'2-digit',hour12:false,timeZone:TZ,hourCycle:'h23'});
function fmtHM(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}:${ps.find(p=>p.type==='minute')?.value||'00'}`; }
function fmtH(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}`; }

/* --------- SS-sanakirja (sovittu) --------- */
const SS_TEXT = {
  1:'sinistä', 2:'sangen sinistä', 4:'siniharmaata', 6:'sangen harmaata', 7:'harmaata',
  9:'sumua',
  71:'seppoa kutittaa', 74:'seppoa ärsyttää', 77:'seppo on vihainen',
  21:'kuuro jossain', 24:'kuuroja', 27:'kuuroja sakeana',
  11:'tihkuu', 14:'kryotihkua', 17:'kryosadetta',
  31:'siniharmaasta ripsii', 34:'sangen harmaasta ripsii', 37:'ripsii',
  32:'siniharmaasta satelee', 35:'sangen harmaasta satelee', 38:'satelee',
  33:'siniharmaasta kaatosadettakin', 36:'sangen harmaasta myös kaatosadettakin', 39:'kaatosadetta',
  41:'siniharmaasta märkä hiutale', 44:'sangen harmaasta märkä hiutale', 47:'märkä hiutale',
  42:'siniharmaasta räntää', 45:'sangen harmaasta räntää', 48:'räntää',
  43:'siniharmaasta tiskirättiä', 46:'sangen harmaasta tiskirättiä', 49:'tiskirättiä',
  51:'siniharmaasta kevyt hiutale', 54:'sangen harmaasta kevyt hiutale', 57:'kevyt hiutale',
  52:'siniharmaasta lunta', 55:'sangen harmaasta lunta', 58:'lunta',
  53:'siniharmaasta pyryä', 56:'sangen harmaasta pyryä', 59:'pyryttää',
  61:'rakeita jossain', 64:'rakeita', 67:'rakeiden tulitus'
};
const SMART_SYMBOL_INFO = {
  1:  { label: 'clear', dry: true },
  2:  { label: 'mostly_clear', dry: true },
  4:  { label: 'partly_cloudy', dry: true },
  6:  { label: 'cloudy', dry: true },
  7:  { label: 'overcast', dry: true },
  9:  { label: 'fog', fog: true },
  11: { label: 'drizzle', precip: true, weak: true },
  14: { label: 'freezing_drizzle', precip: true, weak: true, highlightSmall: true },
  17: { label: 'freezing_rain', precip: true, highlightSmall: true, contradictionHeavy: true },
  21: { label: 'shower_light', precip: true, highlightSmall: true },
  24: { label: 'shower', precip: true, highlightSmall: true, contradictionHeavy: true },
  27: { label: 'shower_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  31: { label: 'light_rain', precip: true },
  32: { label: 'rain', precip: true, highlightSmall: true, contradictionHeavy: true },
  33: { label: 'rain_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  34: { label: 'light_rain', precip: true },
  35: { label: 'rain', precip: true, highlightSmall: true, contradictionHeavy: true },
  36: { label: 'rain_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  37: { label: 'light_rain', precip: true },
  38: { label: 'rain', precip: true, highlightSmall: true, contradictionHeavy: true },
  39: { label: 'rain_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  41: { label: 'wet_snow_light', precip: true, weak: true },
  42: { label: 'sleet', precip: true, highlightSmall: true, contradictionHeavy: true },
  43: { label: 'sleet_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  44: { label: 'wet_snow', precip: true },
  45: { label: 'sleet', precip: true, highlightSmall: true, contradictionHeavy: true },
  46: { label: 'sleet_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  47: { label: 'wet_snow', precip: true },
  48: { label: 'sleet', precip: true, highlightSmall: true, contradictionHeavy: true },
  49: { label: 'sleet_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  51: { label: 'snow_light', precip: true, weak: true },
  52: { label: 'snow', precip: true, highlightSmall: true, contradictionHeavy: true },
  53: { label: 'snow_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  54: { label: 'snow_light', precip: true },
  55: { label: 'snow', precip: true, highlightSmall: true, contradictionHeavy: true },
  56: { label: 'snow_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  57: { label: 'snow_light', precip: true },
  58: { label: 'snow', precip: true, highlightSmall: true, contradictionHeavy: true },
  59: { label: 'snow_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  61: { label: 'hail', precip: true, hail: true, highlightSmall: true, contradictionHeavy: true },
  64: { label: 'hail', precip: true, hail: true, highlightSmall: true, contradictionHeavy: true },
  67: { label: 'hail', precip: true, hail: true, highlightSmall: true, contradictionHeavy: true },
  71: { label: 'thunder', precip: true, thunder: true, highlightSmall: true },
  74: { label: 'thunder', precip: true, thunder: true, highlightSmall: true },
  77: { label: 'thunder', precip: true, thunder: true, highlightSmall: true }
};
const ssText = c => {
  if (c == null) return '';
  const num = Number(c);
  if (!Number.isFinite(num)) return '';
  const key = ((num % 100) + 100) % 100;
  return SS_TEXT[key] || '';
};
const SMART_SYMBOL_SMALL_RAIN = new Set(
  Object.entries(SMART_SYMBOL_INFO)
    .filter(([, info]) => info.highlightSmall)
    .map(([key]) => Number(key))
);
const SMART_SYMBOL_HEAVY = new Set(
  Object.entries(SMART_SYMBOL_INFO)
    .filter(([, info]) => info.contradictionHeavy)
    .map(([key]) => Number(key))
);
const DRY_TEXTS = new Set(['sinistä','sangen sinistä','siniharmaata','sangen harmaata','harmaata']);

function smartSymbolInfo(code){
  if (code == null) return null;
  const num = Number(code);
  if (!Number.isFinite(num)) return null;
  const key = ((num % 100) + 100) % 100;
  return SMART_SYMBOL_INFO[key] || null;
}

/* pienen sateen ( <0.3 mm ) poikkeuslista (säilytä valkoisena jos nämä) */
const SMALL_RAIN_EXCEPT = SMART_SYMBOL_SMALL_RAIN;
const HEAVY_SSCODE = SMART_SYMBOL_HEAVY;

/* --------- MET Nowcast symbolit (NC) --------- */
const NC_SYMBOL = {
  'clearsky': "sinistä", 'fair': "sangen sinistä", 'partlycloudy': "siniharmaata", 'cloudy': "harmaata",
  'lightrainshowers': "jokunen kuuro", 'heavyrainshowers': "äänekästä kuuroa",
  'rainshowersandthunder': "sepon välisuihkut", 'thunderstorm': "seppo riehuu",
  'heavyrain': "saavista kaatuu", 'lightrain': "ripsii", 'sleet': "räntää",
  'lightsleetshowers_and_thunder': "sepon tiskivuoro", 'snowshowers_and_thunder': "lumiukkonen",
  'snow': "lunta", 'heavysnow': "pyryttää", 'fog': "sumua"
};
const NOWCAST_INFO = {
  clearsky: { label: 'clear', dry: true },
  fair: { label: 'mostly_clear', dry: true },
  partlycloudy: { label: 'partly_cloudy', dry: true },
  cloudy: { label: 'overcast', dry: true },
  lightrainshowers: { label: 'shower_light', precip: true, weak: true },
  heavyrainshowers: { label: 'shower_heavy', precip: true },
  rainshowersandthunder: { label: 'thunder_shower', precip: true, thunder: true },
  thunderstorm: { label: 'thunder', precip: true, thunder: true },
  heavyrain: { label: 'rain_heavy', precip: true },
  lightrain: { label: 'rain_light', precip: true, weak: true },
  sleet: { label: 'sleet', precip: true },
  lightsleetshowers_and_thunder: { label: 'thunder_sleet', precip: true, thunder: true },
  snowshowers_and_thunder: { label: 'thunder_snow', precip: true, thunder: true },
  snow: { label: 'snow', precip: true },
  heavysnow: { label: 'snow_heavy', precip: true },
  fog: { label: 'fog', fog: true }
};
const ncBase = code => code ? code.replace(/_(day|night)$/,'') : '';
function ncSymbolInfo(code){
  const base = ncBase(code);
  return base ? (NOWCAST_INFO[base] || null) : null;
}
const ncSymbolText = code => (NC_SYMBOL[ncBase(code)] || '');
function ncIsPrecip(code){
  const info = ncSymbolInfo(code);
  return !!(info && (info.precip || info.fog || info.thunder));
}

/* --------- Tuulensuunta tekstit --------- */
function dir8(deg){
  if (deg==null || isNaN(deg)) return '';
  const d = ((deg%360)+360)%360;
  if (d>=337.5 || d<22.5)   return 'pohjoisesta';
  if (d<67.5)               return 'koillisesta';
  if (d<112.5)              return 'idästä';
  if (d<157.5)              return 'kaakosta';
  if (d<202.5)              return 'etelästä';
  if (d<247.5)              return 'lounaasta';
  if (d<292.5)              return 'lännestä';
  return 'luoteesta';
}

/* --------- FMI WFS (HARMONIE) --------- */
function buildWfsForecast(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::forecast::harmonie::surface::point::timevaluepair';
  const params='temperature,precipitation1h,windspeedms,winddirection,SmartSymbol';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-2); e.setHours(e.getHours()+24);
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=60`;
}

/* --------- XML → sarjat --------- */
const parseXML = txt => {
  const x = new DOMParser().parseFromString(txt,'application/xml');
  const ex = x.querySelector('Exception, ows\\:Exception');
  if (ex){ const t=x.querySelector('ExceptionText, ows\\:ExceptionText'); throw new Error('FMI virhe: '+(t?t.textContent:'Tuntematon virhe')); }
  return x;
};
const extractSeries = x => {
  const get=(e,n)=>e.getElementsByTagNameNS('*',n)[0];
  const all=x.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTimeseries');
  const o={};
  for (const s of all){
    const id=(s.getAttribute('gml:id')||'').toLowerCase();
    let k='';
    if (id.includes('temperature')) k='temperature';
    else if (id.includes('precipitation1h')) k='precipitation1h';
    else if (id.includes('windspeedms')) k='windspeedms';
    else if (id.includes('winddirection')) k='winddirection';
    else if (id.includes('smartsymbol')) k='SmartSymbol';
    if (!k) continue;
    const map=new Map();
    const pts=s.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTVP');
    for (const p of pts){
      const t=get(p,'time')?.textContent;
      const v=get(p,'value')?.textContent;
      if (!t) continue;
      const num = v!=null ? Number(v) : null;
      map.set(t, isNaN(num)?null:num);
    }
    o[k]=map;
  }
  return o;
};

async function fetchForecast(lat, lon){
  const url = buildWfsForecast(lat, lon);
  const res = await fetch(url, { cache: 'no-store' });
  const txt = await res.text();
  if (!res.ok){
    throw new Error(`FMI ennuste HTTP ${res.status}\n${txt.slice(0,400)}`);
  }
  const forecastSeries = extractSeries(parseXML(txt));
  const keys = Array.from(forecastSeries.temperature?.keys?.() || []).sort();
  const hours = keys.map(key => ({
    key,
    time: new Date(key),
    temperature: forecastSeries.temperature?.get(key) ?? null,
    precipitation: forecastSeries.precipitation1h?.get(key) ?? null,
    windSpeed: forecastSeries.windspeedms?.get(key) ?? null,
    windDirection: forecastSeries.winddirection?.get(key) ?? null,
    smartSymbol: forecastSeries.SmartSymbol?.get(key) ?? null
  }));
  return { hours, series: forecastSeries };
}

/* --------- MET Nowcast – sade + puuska + symbol_code --------- */
const NOWCAST_CACHE_TTL = 5 * 60 * 1000;
const NOWCAST_RETRY_COOLDOWN = 60 * 1000;
const nowcastShared = new Map();

function nowcastKey(lat, lon){
  return `${Number(lat).toFixed(4)},${Number(lon).toFixed(4)}`;
}

async function fetchNowcastTimeseries(lat, lon){
  try{
    const url = `https://api.met.no/weatherapi/nowcast/2.0/complete?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&altitude=0`;
    const res = await fetch(url, { cache:'no-store', headers: { 'Accept': 'application/json' } });
    if (!res.ok) return { ok:false, meta:`NC!${res.status}` };
    const js = await res.json();
    const ts = js?.properties?.timeseries;
    if (!Array.isArray(ts) || !ts.length) return { ok:false, meta:'NC!empty' };
    return { ok:true, timeseries: ts };
  }catch{
    return { ok:false, meta:'NC!err' };
  }
}

function pickNowcastFromSeries(ts, dUTC, metaBase){
  if (!(dUTC instanceof Date) || Number.isNaN(dUTC.getTime())) return { val:null, meta:'NC!date' };
  if (!Array.isArray(ts) || !ts.length) return { val:null, meta:'NC!empty' };

  const targetUTC = dUTC.getTime();
  let future=null,fDiff=Infinity,past=null,pDiff=Infinity;
  for (const it of ts){
    const t=new Date(it.time).getTime(), diff=t-targetUTC, ad=Math.abs(diff);
    if (diff>=0 && ad<fDiff){fDiff=ad; future=it;}
    if (diff<0  && ad<pDiff){pDiff=ad; past=it;}
  }
  let best=null;
  if (future && fDiff<=60*60000) best=future;
  else if (past && pDiff<=60*60000) best=past;
  if (!best) return { val:null, meta:'NC!miss' };

  const acc  = best?.data?.next_1_hours?.details?.precipitation_amount;
  const pr   = best?.data?.instant?.details?.precipitation_rate;
  const gust = best?.data?.instant?.details?.wind_speed_of_gust;
  const sym  = best?.data?.next_1_hours?.summary?.symbol_code || null;

  let p = null; if (typeof acc === 'number') p = acc; else if (typeof pr === 'number') p = pr;
  const meta = metaBase || 'NC';
  return { val:(typeof p==='number'?p:null), meta, gust:(typeof gust==='number'?gust:null), sym };
}

async function ensureNowcastBundle(lat, lon){
  const key = nowcastKey(lat, lon);
  const now = Date.now();
  let entry = nowcastShared.get(key);
  if (!entry){
    entry = { timeseries:null, fetchedAt:0, stale:false, meta:'NC!init', promise:null, retryAt:0 };
    nowcastShared.set(key, entry);
  }

  if (entry.promise){
    return entry.promise;
  }

  if (entry.timeseries){
    if (!entry.stale && (now - entry.fetchedAt) <= NOWCAST_CACHE_TTL){
      return { ok:true, timeseries: entry.timeseries, meta:'NC', stale:false };
    }
    if (entry.stale && now < entry.retryAt){
      return { ok:true, timeseries: entry.timeseries, meta:'NC~stale', stale:true };
    }
  }

  entry.promise = (async()=>{
    try{
      const res = await fetchNowcastTimeseries(lat, lon);
      if (res.ok){
        entry.timeseries = res.timeseries;
        entry.fetchedAt = Date.now();
        entry.stale = false;
        entry.meta = 'NC';
        entry.retryAt = 0;
        return { ok:true, timeseries: entry.timeseries, meta:'NC', stale:false };
      }
      entry.meta = res.meta || 'NC!err';
      entry.retryAt = Date.now() + NOWCAST_RETRY_COOLDOWN;
      if (entry.timeseries){
        entry.stale = true;
        return { ok:true, timeseries: entry.timeseries, meta:'NC~stale', stale:true };
      }
      entry.timeseries = null;
      entry.stale = false;
      return { ok:false, timeseries:null, meta:entry.meta, stale:false };
    } finally {
      entry.promise = null;
    }
  })();

  return entry.promise;
}

async function fetchNowcastForHour(lat, lon, dUTC){
  const bundle = await ensureNowcastBundle(lat, lon);
  if (!bundle || !bundle.ok){
    return { val:null, meta: bundle?.meta || 'NC!err' };
  }
  const metaBase = bundle.meta || (bundle.stale ? 'NC~stale' : 'NC');
  const picked = pickNowcastFromSeries(bundle.timeseries, dUTC, metaBase);
  if (bundle.stale && picked.meta === 'NC'){
    return { ...picked, meta:'NC~stale' };
  }
  return picked;
}

async function fetchNowcasts(lat, lon, targetHours){
  if (!Array.isArray(targetHours) || !targetHours.length){
    return new Map();
  }
  const results = await Promise.all(targetHours.map(h => {
    const date = h?.time instanceof Date ? h.time : new Date(h?.key || h);
    return fetchNowcastForHour(lat, lon, date).catch(() => ({ val:null, meta:'NC!err' }));
  }));
  const map = new Map();
  targetHours.forEach((hour, idx) => {
    const key = hour?.key || (hour?.time instanceof Date ? hour.time.toISOString() : null);
    if (key) map.set(key, results[idx] || { val:null, meta:'NC!err' });
  });
  return map;
}

function nowcastMetaTag(meta){
  if (typeof meta !== 'string') return 'NC';
  if (meta.startsWith('NC~')) return 'NC~';
  if (meta.startsWith('NC!')) return 'NC!';
  return 'NC';
}

/* --------- Sunrise API: hämärä- ja nousu/laskuajat --------- */
const TZ_PARTS_CACHE = new Map();
function getTimeZoneFormatter(timeZone){
  const key = timeZone || 'UTC';
  if (TZ_PARTS_CACHE.has(key)) return TZ_PARTS_CACHE.get(key);
  let fmt;
  try {
    fmt = new Intl.DateTimeFormat('en-US',{
      timeZone: key,
      hour12: false,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      fractionalSecondDigits: 3
    });
  } catch (err) {
    fmt = new Intl.DateTimeFormat('en-US',{
      timeZone: key,
      hour12: false,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  }
  TZ_PARTS_CACHE.set(key, fmt);
  return fmt;
}
function partsForZone(date, timeZone){
  if (!isValidDate(date)) return null;
  try {
    const parts = getTimeZoneFormatter(timeZone).formatToParts(date);
    const obj = {};
    for (const part of parts){
      if (part.type === 'literal') continue;
      if (obj[part.type] == null) obj[part.type] = part.value;
    }
    if (obj.second == null) obj.second = '00';
    return obj;
  } catch (err) {
    if (DBG) console.warn('partsForZone fail', err);
    return null;
  }
}
function numOrNaN(value){
  const n = Number(value);
  return Number.isFinite(n) ? n : NaN;
}
function fractionalToMillis(value){
  if (value == null) return 0;
  const str = String(value).replace(/\D/g,'');
  if (!str) return 0;
  return Number(str.slice(0,3).padEnd(3,'0'));
}
function calendarParts(date, timeZone){
  const parts = partsForZone(date, timeZone);
  if (!parts) return null;
  const year = numOrNaN(parts.year);
  const month = numOrNaN(parts.month);
  const day = numOrNaN(parts.day);
  const hour = numOrNaN(parts.hour);
  const minute = numOrNaN(parts.minute);
  const second = numOrNaN(parts.second);
  if (![year, month, day, hour, minute, second].every(Number.isFinite)) return null;
  const millisecond = fractionalToMillis(parts.fractionalSecond);
  return { year, month, day, hour, minute, second, millisecond };
}
function makeDateInTimeZone(year, month, day, hour, minute, second, timeZone){
  const base = new Date(Date.UTC(year, month-1, day, hour, minute, second));
  const parts = calendarParts(base, timeZone);
  if (!parts) return base;
  const utc = Date.UTC(parts.year, parts.month-1, parts.day, parts.hour, parts.minute, parts.second);
  const diff = utc + parts.millisecond - base.getTime();
  return new Date(base.getTime() - diff);
}
function getTimeZoneOffsetMinutes(date, timeZone){
  const parts = calendarParts(date, timeZone);
  if (!parts) return -date.getTimezoneOffset();
  const utc = Date.UTC(parts.year, parts.month-1, parts.day, parts.hour, parts.minute, parts.second);
  return Math.round((utc + parts.millisecond - date.getTime()) / 60000);
}
function canonicalDateForDay(date, timeZone){
  const parts = calendarParts(date, timeZone);
  if (!parts) return date;
  return makeDateInTimeZone(parts.year, parts.month, parts.day, 12, 0, 0, timeZone);
}
function formatOffsetFromMinutes(offMin){
  if (!Number.isFinite(offMin)) return '+00:00';
  const sign = offMin >= 0 ? '+' : '-';
  const abs = Math.abs(offMin);
  const hh = String(Math.trunc(abs/60)).padStart(2,'0');
  const mm = String(Math.trunc(abs%60)).padStart(2,'0');
  return `${sign}${hh}:${mm}`;
}
function dateKeyForZone(date, timeZone){
  const parts = calendarParts(date, timeZone);
  if (!parts) return null;
  const y = String(parts.year).padStart(4,'0');
  const m = String(parts.month).padStart(2,'0');
  const d = String(parts.day).padStart(2,'0');
  return `${y}-${m}-${d}`;
}
function offsetHHMM(d){
  const ref = canonicalDateForDay(isValidDate(d) ? d : new Date(), TZ);
  const offMin = getTimeZoneOffsetMinutes(ref, TZ);
  return formatOffsetFromMinutes(offMin);
}
function offsetToMinutes(offset){
  const m = /^([+-])(\d{2}):(\d{2})$/.exec(offset);
  if (!m) return 0;
  const sign = m[1] === '+' ? 1 : -1;
  const h = Number(m[2]);
  const min = Number(m[3]);
  return sign * (h*60 + min);
}
function isValidDate(d){
  return d instanceof Date && !isNaN(d.getTime());
}
function formatWithOffset(date, offset){
  if (!isValidDate(date)) return null;
  const offMin = offsetToMinutes(offset);
  const shifted = new Date(date.getTime() + offMin*60000);
  const y = shifted.getUTCFullYear();
  const m = String(shifted.getUTCMonth()+1).padStart(2,'0');
  const d = String(shifted.getUTCDate()).padStart(2,'0');
  const hh = String(shifted.getUTCHours()).padStart(2,'0');
  const mm = String(shifted.getUTCMinutes()).padStart(2,'0');
  const ss = String(shifted.getUTCSeconds()).padStart(2,'0');
  return `${y}-${m}-${d}T${hh}:${mm}:${ss}${offset}`;
}
function wrapTimeEntry(str, offset){
  if (!str) return null;
  const dt = new Date(str);
  if (!isValidDate(dt)) return null;
  const formatted = formatWithOffset(dt, offset);
  return formatted ? { time: formatted } : null;
}
function wrapFromDate(dt, offset){
  if (!isValidDate(dt)) return null;
  const formatted = formatWithOffset(dt, offset);
  return formatted ? { time: formatted } : null;
}
/* Cache per YYYY-MM-DD */
const sunriseCache = new Map();
async function fetchSunriseDay(dateLocal, lat, lon){
  const canonical = canonicalDateForDay(dateLocal, TZ);
  const parts = calendarParts(canonical, TZ) || calendarParts(dateLocal, TZ);
  const year = parts?.year ?? canonical.getUTCFullYear();
  const monthIdx = (parts ? parts.month - 1 : canonical.getUTCMonth());
  const day = parts?.day ?? canonical.getUTCDate();
  const key = dateKeyForZone(canonical, TZ) || `${year}-${String(monthIdx+1).padStart(2,'0')}-${String(day).padStart(2,'0')}`;
  if (sunriseCache.has(key)) return sunriseCache.get(key);
  const offset = offsetHHMM(canonical);
  const url = `https://api.met.no/weatherapi/sunrise/3.0/sun?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&date=${key}&offset=${encodeURIComponent(offset)}`;
  try{
    const res = await fetch(url, {cache:'no-store', headers:{'Accept':'application/json'}});
    if (!res.ok){
      const errObj = { __error: `Sunrise v3 HTTP ${res.status}` };
      sunriseCache.set(key, errObj);
      return errObj;
    }
    const js = await res.json();
    const props = js?.properties || (Array.isArray(js?.features) ? js.features[0]?.properties : null) || js?.feature?.properties || null;
    if (!props){
      const errObj = { __error: 'Sunrise v3 empty' };
      sunriseCache.set(key, errObj);
      return errObj;
    }
    const result = {
      sunrise: wrapTimeEntry(props.sunrise?.time, offset),
      sunset: wrapTimeEntry(props.sunset?.time, offset),
      solarnoon: wrapTimeEntry(props.solarnoon?.time, offset),
      solarmidnight: wrapTimeEntry(props.solarmidnight?.time, offset)
    };
    const hasSunCalc = typeof SunCalc === 'object' && SunCalc && typeof SunCalc.getTimes === 'function';
    if (hasSunCalc){
      const offMin = offsetToMinutes(offset);
      const midRef = new Date(Date.UTC(year, monthIdx, day, 12) - offMin*60000);
      const times = SunCalc.getTimes(midRef, lat, lon) || {};
      result.civil_twilight_begin = wrapFromDate(times.dawn, offset);
      result.civil_twilight_end = wrapFromDate(times.dusk, offset);
      result.nautical_twilight_begin = wrapFromDate(times.nauticalDawn, offset);
      result.nautical_twilight_end = wrapFromDate(times.nauticalDusk, offset);
      result.astronomical_twilight_begin = wrapFromDate(times.nightEnd, offset);
      result.astronomical_twilight_end = wrapFromDate(times.night, offset);
    } else {
      result.__warn = 'SunCalc unavailable';
    }
    sunriseCache.set(key, result);
    return result;
  }catch(e){
    const errObj = { __error: `Sunrise v3 ERR ${String(e && e.message || e)}` };
    sunriseCache.set(key, errObj);
    return errObj;
  }
}
const tp = s => s ? new Date(s) : null;

async function fetchSunPhases(lat, lon, hours){
  const uniq = new Map();
  if (Array.isArray(hours)){
    for (const hour of hours){
      const baseDate = hour?.time instanceof Date ? hour.time : new Date(hour?.key || hour);
      if (!isValidDate(baseDate)) continue;
      const key = dateKeyForZone(baseDate, TZ) || (
        Number.isFinite(baseDate.getFullYear())
          ? `${baseDate.getFullYear()}-${String(baseDate.getMonth()+1).padStart(2,'0')}-${String(baseDate.getDate()).padStart(2,'0')}`
          : null
      );
      if (!key || uniq.has(key)) continue;
      uniq.set(key, { key, date: baseDate });
    }
  }
  if (!uniq.size) return new Map();
  const entries = Array.from(uniq.values()).map(({ key, date }) => (
    fetchSunriseDay(date, lat, lon)
      .then(value => ({ key, value }))
      .catch(e => ({ key, value: { __error: `Sunrise run fail: ${e?.message || e}` } }))
  ));
  const results = await Promise.all(entries);
  const map = new Map();
  for (const { key, value } of results){
    map.set(key, value);
  }
  return map;
}

/* Päättele vaihe & mahdollinen vaihtominuutti tunnin sisällä */
function phaseLabel(phase){
  switch(phase){
    case 'day': return null;
    case 'civil': return 'porvarillinen hämärä';
    case 'nautical': return 'nauttinen hämärä';
    case 'astronomical': return 'astronominen hämärä';
    case 'night': return 'säkkipimeä';
    default: return null;
  }
}
const TWILIGHT_PHASES = new Set(['civil','nautical','astronomical','night']);
function nextLabelFor(toPhase){
  if (toPhase==='nautical') return 'vaihtuu nauttiseksi';
  if (toPhase==='astronomical') return 'astronominen hämärä';
  if (toPhase==='night') return 'säkkipimeä';
  if (toPhase==='civil') return 'porvarillinen alkaa';
  return null;
}
function beginLabel(phase){
  if (phase==='astronomical') return 'astronominen hämärä alkaa';
  if (phase==='civil') return 'porvarillinen alkaa';
  if (phase==='nautical') return 'nauttinen hämärä alkaa';
  return null;
}

const MIN = 60000;

function analyzeTwilightForHour(dLocal, dayObj){
  if (!dayObj || dayObj.__error) return { phase: null, withinChange: null, sunEvent: null, dbg: dayObj?.__error||null };
  const rise = tp(dayObj.sunrise?.time);
  const set  = tp(dayObj.sunset?.time);
  const civStart = tp(dayObj.civil_twilight_begin?.time);
  const civEnd   = tp(dayObj.civil_twilight_end?.time);
  const nautStart= tp(dayObj.nautical_twilight_begin?.time);
  const nautEnd  = tp(dayObj.nautical_twilight_end?.time);
  const astroStart=tp(dayObj.astronomical_twilight_begin?.time);
  const astroEnd  =tp(dayObj.astronomical_twilight_end?.time);

  const t0 = new Date(dLocal); t0.setMinutes(0,0,0);
  const t1 = new Date(t0); t1.setHours(t1.getHours()+1);

  function where(t){
    if (astroStart && t<astroStart) return 'night';
    if (astroStart && nautStart && t>=astroStart && t<nautStart) return 'astronomical';
    if (nautStart && civStart && t>=nautStart && t<civStart) return 'nautical';
    if (civStart && rise && t>=civStart && t<rise) return 'civil';
    if (rise && set && t>=rise && t<set) return 'day';
    if (set && civEnd && t>=set && t<civEnd) return 'civil';
    if (civEnd && nautEnd && t>=civEnd && t<nautEnd) return 'nautical';
    if (nautEnd && astroEnd && t>=nautEnd && t<astroEnd) return 'astronomical';
    if (astroEnd && t>=astroEnd) return 'night';
    return null;
  }
  const p0 = where(t0);
  const p1 = where(t1);

  const transitions = [civStart,civEnd,nautStart,nautEnd,astroStart,astroEnd]
    .filter(Boolean)
    .sort((a,b)=>a-b);
  const times = [t0];
  for (const t of transitions){ if (t>t0 && t<t1) times.push(t); }
  times.push(t1);
  const segments = [];
  for (let i=0; i<times.length-1; i++){
    const start = times[i];
    const end = times[i+1];
    if (!start || !end || end<=start) continue;
    const mid = new Date((start.getTime()+end.getTime())/2);
    const phase = where(mid);
    segments.push({ phase, start, end, duration: end-start });
  }

  let dominantPhase = p0;
  let dominantSegment = null;
  for (const seg of segments){
    if (!seg.phase || !TWILIGHT_PHASES.has(seg.phase)) continue;
    if (seg.duration > 30*MIN && (!dominantSegment || seg.duration > dominantSegment.duration)){
      dominantPhase = seg.phase;
      dominantSegment = seg;
    }
  }

  let phaseStart = null;
  if (dominantPhase && TWILIGHT_PHASES.has(dominantPhase)){
    for (const t of transitions){
      if (t > (dominantSegment?.end || t1)) break;
      const to = where(new Date(t.getTime()+1000));
      if (to === dominantPhase) phaseStart = t;
    }
    if (!phaseStart && dominantSegment){
      phaseStart = dominantSegment.start;
    }
  }

  let withinChange = null, sunEvent = null;
  if (rise && rise>=t0 && rise<t1) sunEvent = { type:'rise', at: rise };
  if (set  && set >=t0 && set <t1) sunEvent = { type:'set',  at: set  };

  if (!sunEvent && p0 && p1 && p0!==p1){
    const candidates = [civStart,civEnd,nautStart,nautEnd,astroStart,astroEnd].filter(t=>t && t>=t0 && t<t1).sort((a,b)=>a-b);
    const at = candidates[0] || null;
    if (at){
      const toPhase = where(new Date(at.getTime()+1));
      if (toPhase){
        const fromPhase = where(new Date(at.getTime()-1));
        withinChange = { to: toPhase, at, from: fromPhase || null };
      }
    }
  }
  const startedWithinHour = !!(phaseStart && phaseStart>t0 && phaseStart<t1);
  return {
    phase: dominantPhase,
    withinChange,
    sunEvent,
    dbg: null,
    rise,
    set,
    phaseStart,
    startedWithinHour
  };
}

function formatSmallTag(entry){
  if (!entry) return '';
  let text = '';
  let italic = false;
  let prefix = false;
  let preserveCase = false;
  let white = false;
  if (typeof entry === 'string'){ text = entry; }
  else if (typeof entry === 'object' && entry){
    text = entry.text || '';
    italic = !!entry.italic;
    prefix = !!entry.prefix;
    preserveCase = !!entry.preserveCase;
    white = !!entry.white;
  }
  if (!text) return '';
  if (prefix && text.startsWith('...')) prefix = false;
  const classes = [white ? 'miniW' : 'mini'];
  if (italic) classes.push('miniTwilight');
  if (prefix) classes.push('miniPrefixed');
  const cls = classes.join(' ');
  const body = preserveCase ? text : text.toLocaleLowerCase('fi-FI');
  const attrs = [];
  if (entry && entry.dittoEllipsis) attrs.push('data-ditto-ellipsis="1"');
  const attrStr = attrs.length ? ' ' + attrs.join(' ') : '';
  return `<span class="${cls}"${attrStr}>${body}</span>`;
}

function baseSunEventText(at, type){
  if (!(at instanceof Date)) return null;
  const hhmm = fmtHM(at);
  if (!hhmm) return null;
  const mins = at.getMinutes();
  const isRise = type === 'rise';
  if (typeof mins === 'number' && mins < 30){
    return isRise ? `auringonnousu ${hhmm}` : `auringonlasku ${hhmm}`;
  }
  const verb = isRise ? 'Aurinko nousee' : 'Aurinko laskee';
  return `${verb} ${hhmm}.`;
}

function formatSunEventTag(sunEvent){
  if (!sunEvent || !(sunEvent.at instanceof Date)) return null;
  const sentence = baseSunEventText(sunEvent.at, sunEvent.type);
  if (!sentence) return null;
  const minutes = sunEvent.at.getMinutes();
  const beforeMain = Number.isInteger(minutes) && minutes < 30;
  return {
    text: sentence,
    italic: true,
    prefix: false,
    preserveCase: true,
    beforeMain
  };
}

function buildDescriptionHtml({ main, tags, extra }){
  const safeMain = main || '–';
  const tagList = Array.isArray(tags) ? tags : [];
  let extraHtml = extra || '';
  const formattedAfter = [];
  const formattedBefore = [];
  for (const entry of tagList){
    const html = formatSmallTag(entry);
    if (!html) continue;
    const beforeMain = typeof entry === 'object' && entry && entry.beforeMain;
    if (beforeMain) formattedBefore.push(html);
    else formattedAfter.push(html);
  }
  const beforeHtml = formattedBefore.join('<br>');
  const afterHtml = formattedAfter.join('<br>');
  const beforeSection = beforeHtml ? `${beforeHtml}<br>` : '';
  const afterSection = afterHtml ? `<br>${afterHtml}` : '';
  return `${beforeSection}${safeMain}${afterSection}${extraHtml}`;
}

function shouldTintForGold(tw, hourStart){
  if (!tw) return false;
  const sunEvent = (tw.sunEvent && tw.sunEvent.at instanceof Date) ? tw.sunEvent : null;

  if (sunEvent && sunEvent.type === 'rise'){
    const riseTime = sunEvent.at;
    const startValid = hourStart instanceof Date && !Number.isNaN(hourStart.getTime());
    if (startValid){
      const startMs = hourStart.getTime();
      const eventMs = riseTime.getTime();
      if (!Number.isFinite(eventMs)) return false;
      if (eventMs >= startMs - 5*MIN && eventMs < startMs) return true;
      if (eventMs >= startMs && eventMs < startMs + 30*MIN) return true;
      return false;
    }
    const mins = riseTime.getMinutes();
    return Number.isInteger(mins) && mins < 30;
  }

  const setTime = (
    sunEvent && sunEvent.type === 'set'
      ? sunEvent.at
      : (tw.set instanceof Date ? tw.set : null)
  );
  if (!(setTime instanceof Date)) return false;

  const mins = setTime.getMinutes();
  if (!Number.isInteger(mins)) return false;

  const startValid = hourStart instanceof Date && !Number.isNaN(hourStart.getTime());
  if (!startValid) return !!sunEvent && sunEvent.type === 'set' && mins >= 30;

  const startMs = hourStart.getTime();
  const eventMs = setTime.getTime();
  if (!Number.isFinite(eventMs)) return false;

  const endMs = startMs + 60*MIN;
  if (eventMs >= startMs && eventMs < endMs){
    return mins >= 30;
  }
  if (eventMs >= endMs && eventMs < endMs + 5*MIN){
    return true;
  }
  return false;
}

function replaceBlueWithGold(text){
  if (!text || typeof text !== 'string') return text;
  let out = text;
  out = out.replace(/sangen\s+sinistä/gi, match => match[0] === match[0].toUpperCase() ? 'Sangen kultaista' : 'sangen kultaista');
  out = out.replace(/sinistä/gi, match => match[0] === match[0].toUpperCase() ? 'Kultaista' : 'kultaista');
  out = out.replace(/siniharmaa([a-zäöå]*)/gi, (match, tail) => {
    const repl = `kultaharmaa${tail||''}`;
    return match[0] === match[0].toUpperCase() ? repl.charAt(0).toUpperCase() + repl.slice(1) : repl;
  });
  return out;
}

function maybeApplyGoldTint(baseText, tw, hourStart){
  if (!baseText || typeof baseText !== 'string') return baseText;
  if (!shouldTintForGold(tw, hourStart)) return baseText;
  if (!/sini/i.test(baseText)) return baseText;
  return replaceBlueWithGold(baseText);
}

function lowercaseMainDescription(text){
  if (!text || typeof text !== 'string') return text;
  if (!text.trim()) return text;
  if (/^\s*</.test(text)) return text;
  return text.toLocaleLowerCase('fi-FI');
}

function descriptorInfoFromOptions(opts){
  if (!opts) return null;
  const { smartSymbolCode, nowcastCode } = opts;
  return smartSymbolInfo(smartSymbolCode) || ncSymbolInfo(nowcastCode) || null;
}

function isWetDescriptor(text, opts = {}){
  const info = descriptorInfoFromOptions(opts);
  if (info && (info.precip || info.fog || info.thunder)) return true;
  if (!text) return false;
  const low = text.toLowerCase();
  return [
    'ripsii', 'satelee', 'kaatosad', 'ränt', 'hiutale', 'pyry', 'rake',
    'kuuro', 'ukkos', 'tihkuu', 'sadetta', 'märkä', 'lunta', 'sumu'
  ].some(w => low.includes(w));
}

function isWeakWetDescriptor(text, opts = {}){
  const info = descriptorInfoFromOptions(opts);
  if (info && info.weak) return true;
  if (!text) return false;
  const low = text.toLowerCase();
  return ['tihku', 'kevyt hiutale', 'märkä hiutale'].some(w => low.includes(w));
}

function isDryDescriptor(text, opts = {}){
  const info = descriptorInfoFromOptions(opts);
  if (info && !(info.precip || info.fog || info.thunder)) return true;
  if (!text) return false;
  const low = text.toLowerCase().trim();
  return DRY_TEXTS.has(low);
}

function capitalizeDryDescriptor(text, opts = {}){
  if (typeof text !== 'string') return text;
  const trimmed = text.trim();
  if (!trimmed) return text;
  const info = descriptorInfoFromOptions(opts);
  let dry = false;
  if (info){
    if (!(info.precip || info.fog || info.thunder)) dry = true;
  }
  if (!dry){
    const normalized = trimmed.toLocaleLowerCase('fi-FI');
    dry = DRY_TEXTS.has(normalized);
  }
  if (!dry) return text;
  const leading = text.match(/^\s*/)?.[0] ?? '';
  const rest = text.slice(leading.length);
  if (!rest) return text;
  const firstChar = rest.charAt(0);
  const upper = firstChar.toLocaleUpperCase('fi-FI');
  if (firstChar === upper) return text;
  return leading + upper + rest.slice(1);
}

function analyzeFogDescriptor({ text, source }){
  const raw = (typeof text === 'string') ? text.trim() : '';
  if (!raw) return { isFog: false, baseText: raw, displayText: raw };
  const normalized = raw.toLocaleLowerCase('fi-FI');
  if (normalized === 'sumua' || normalized === 'sumu'){
    let displayText = 'sumua';
    if (source === 'harmonie') displayText = 'näkyvyys: mahdollinen';
    else if (source === 'nowcast') displayText = 'näkyvyys: ei ole';
    return { isFog: true, baseText: 'sumua', displayText };
  }
  return { isFog: false, baseText: raw, displayText: raw };
}

function selectDescription({ nowcastText, harmonieText, expectedNowcast=false }){
  const now = (typeof nowcastText === 'string') ? nowcastText.trim() : '';
  if (now){
    return { text: now, source: 'nowcast', fallbackFromNowcast: false };
  }
  const hrm = (typeof harmonieText === 'string') ? harmonieText.trim() : '';
  if (hrm){
    return { text: hrm, source: 'harmonie', fallbackFromNowcast: !!expectedNowcast };
  }
  return { text: '–', source: 'none', fallbackFromNowcast: false };
}

function buildSourceBadge({ source, expectedNowcast=false, fallbackFromNowcast=false }){
  if (!SHOW_SOURCE_BADGES) return '';
  if (source == null || source === 'none') return '';
  if (source === 'nowcast'){
    return '<span class="sourceBadge sourceBadgeNc">NC</span>';
  }
  if (source === 'harmonie'){
    const classes = ['sourceBadge', 'sourceBadgeHrm'];
    if (fallbackFromNowcast && expectedNowcast) classes.push('sourceBadgeFallback');
    return `<span class="${classes.join(' ')}">HRM</span>`;
  }
  const label = (typeof source === 'string') ? source.trim().toUpperCase() : '';
  if (!label) return '';
  return `<span class="sourceBadge">${label}</span>`;
}

function isThunderDescriptor(text, opts = {}){
  const info = descriptorInfoFromOptions(opts);
  if (info && info.thunder) return true;
  if (!text) return false;
  const low = text.toLowerCase();
  return ['ukkos', 'seppo', 'välisuihkut', 'lumiukko'].some(word => low.includes(word));
}

function isHailDescriptor(text, opts = {}){
  const info = descriptorInfoFromOptions(opts);
  if (info && info.hail) return true;
  if (!text) return false;
  return text.toLowerCase().includes('rake');
}

function isThunderOrHailDescriptor(text, opts = {}){
  return isThunderDescriptor(text, opts) || isHailDescriptor(text, opts);
}

function hasPrecipFogOrThunderDescriptor(text, opts = {}){
  if (isWetDescriptor(text, opts)) return true;
  if (isThunderDescriptor(text, opts)) return true;
  const info = descriptorInfoFromOptions(opts);
  return !!(info && info.fog);
}

function ensureQuestionSuffix(text){
  if (text == null) return '?';
  const body = String(text).trim().replace(/[.?!]+$/,'');
  return body ? body + '?' : '?';
}

function wrapItalic(text){
  if (text == null) return text;
  const trimmed = text.trim();
  if (/^<\s*em[>\s]/i.test(trimmed) && /<\/\s*em\s*>$/i.test(trimmed)) return text;
  return `<em>${text}</em>`;
}

function buildThunderTag({ baseText, source, descriptorOpts }){
  if (!isThunderOrHailDescriptor(baseText, descriptorOpts)) return null;
  let text = baseText.trim();
  if (!text || text === '–') return null;
  const fromHarmonie = (source === 'harmonie');
  let italic = false;
  if (fromHarmonie){
    italic = true;
    text = text.replace(/\.+$/,'');
    if (!text.endsWith('?')) text += '?';
  }
  return {
    text,
    italic,
    preserveCase: true,
    white: true
  };
}

function wrapContradiction(descHtml){
  if (!descHtml || descHtml.includes('contradictionMain')) return descHtml;
  const parts = descHtml.split('<br>');
  const main = parts.shift() || '';
  const rest = parts.length ? '<br>' + parts.join('<br>') : '';
  let final = `<span class="contradictionMain">${main}</span>${rest}`;
  if (!final.endsWith('<br>')) final += '<br>';
  final += `<span class="contradictionNote">tai niin ne lupasivat...</span>`;
  return final;
}

function applyContradiction({ descHtml, baseDesc, ssCode, rainVal, rainDisplay }){
  if (!descHtml) return { html: descHtml, flagged: false };
  const base = baseDesc ? baseDesc.trim() : '';
  const hasDesc = base && base !== '–';
  const rainNum = (typeof rainVal === 'number' && !Number.isNaN(rainVal)) ? rainVal : null;
  const rainShown = (typeof rainDisplay === 'number' && !Number.isNaN(rainDisplay)) ? rainDisplay : null;
  const descriptorOpts = { smartSymbolCode: ssCode };
  let strike = false;
  if (rainNum != null && rainNum > 0.3 && isDryDescriptor(base, descriptorOpts)){
    strike = true;
  } else if (hasDesc && rainShown === 0){
    const code = (ssCode != null) ? Number(ssCode) % 100 : null;
    if (code != null && HEAVY_SSCODE.has(code)) strike = true;
  }
  if (!strike) return { html: descHtml, flagged: false };
  return { html: wrapContradiction(descHtml), flagged: true };
}

const twilightState = { lastPhase: null, lastHourStart: null, announced: new Set() };

function resetTwilightState(){
  twilightState.lastPhase = null;
  twilightState.lastHourStart = null;
  twilightState.announced.clear();
}

function allowTwilightAsMain(tw){
  if (!tw || !tw.sunEvent) return true;
  const at = tw.sunEvent.at;
  if (!(at instanceof Date)) return true;
  const minutes = at.getMinutes();
  if (!Number.isFinite(minutes)) return true;
  if (tw.sunEvent.type === 'rise') return minutes >= 30;
  if (tw.sunEvent.type === 'set') return minutes < 30;
  return true;
}

function decorateDescription(baseText, tw, { precipish, hourStart }){
  let tintedMain = baseText;
  let twilightMain = false;
  const tags = [];
  if (!tw) return { main: tintedMain, twilightMain, tags };

  const phaseMain = phaseLabel(tw.phase);
  tintedMain = maybeApplyGoldTint(baseText, tw, hourStart);
  let main = tintedMain;

  const twilightMainAllowed = allowTwilightAsMain(tw);

  if (!precipish && phaseMain && twilightMainAllowed){
    main = `<span class="twilightMainText">${phaseMain}</span>`;
    twilightMain = true;
  }

  let startTag = null;
  let startKey = null;
  if (tw.phase && TWILIGHT_PHASES.has(tw.phase) && tw.phaseStart instanceof Date){
    const phaseStart = tw.phaseStart;
    const hhmm = fmtHM(phaseStart);
    const minutes = phaseStart.getMinutes();
    const beforeMain = Number.isInteger(minutes) && minutes < 30;
    let label = beginLabel(tw.phase);
    if (!label && phaseMain) label = `${phaseMain} alkaa`;
    if (label && hhmm){
      const entry = { text: `${label} ${hhmm}`, italic: true, beforeMain };
      startKey = `${tw.phase}-${phaseStart.getTime()}`;
      if (tw.startedWithinHour){
        startTag = entry;
      } else if (
        tw.phase !== twilightState.lastPhase &&
        !twilightState.announced.has(startKey)
      ){
        const prevHourStart = twilightState.lastHourStart;
        if (prevHourStart && phaseStart >= prevHourStart){
          startTag = entry;
        }
      }
    }
  }

  if (tw.sunEvent){
    const entry = formatSunEventTag(tw.sunEvent);
    if (entry) tags.push(entry);
  } else if (startTag){
    tags.push(startTag);
    if (startKey) twilightState.announced.add(startKey);
  } else if (tw.withinChange){
    const label = precipish ? beginLabel(tw.withinChange.to) : nextLabelFor(tw.withinChange.to);
    const at = tw.withinChange.at;
    const hhmm = at instanceof Date ? fmtHM(at) : null;
    if (label && hhmm){
      const toPhase = tw.withinChange.to;
      const minutes = at.getMinutes();
      const fromPhase = tw.withinChange.from || tw.phase;
      let text = `...${label} ${hhmm}`;
      let dittoEllipsis = false;
      if (toPhase === 'night'){
        text = `säkkipimeä ${hhmm}`;
      } else if (!precipish){
        if (toPhase === 'astronomical' && fromPhase === 'night'){
          text = `astronominen hämärä ${hhmm}`;
        } else if (typeof minutes === 'number' && minutes >= 30){
          const toPhaseIsTwilight = toPhase && TWILIGHT_PHASES.has(toPhase);
          const fromPhaseIsTwilight = fromPhase && TWILIGHT_PHASES.has(fromPhase);
          if (toPhaseIsTwilight && fromPhaseIsTwilight){
            const twilightShortLabels = {
              civil: 'porvarillinen',
              nautical: 'nauttinen',
              astronomical: 'astronominen',
            };
            const shortLabel = twilightShortLabels[toPhase];
            if (shortLabel){
              text = `${shortLabel} ${hhmm}`;
              dittoEllipsis = true;
            }
          }
        }
      }
      const entry = { text, italic: true };
      if (Number.isInteger(minutes) && minutes < 30) entry.beforeMain = true;
      if (dittoEllipsis) entry.dittoEllipsis = true;
      tags.push(entry);
    } else if (label){
      const base = `...${label} ${fmtHM(tw.withinChange.at)}`;
      const text = tw.withinChange?.to === 'night' ? base.replace(/^\.\.\./, '').trimStart() : base;
      tags.push({ text, italic: true });
    }
    if (
      label &&
      tw.withinChange?.at instanceof Date &&
      typeof tw.withinChange?.to === 'string' &&
      TWILIGHT_PHASES.has(tw.withinChange.to)
    ){
      const key = `${tw.withinChange.to}-${tw.withinChange.at.getTime()}`;
      twilightState.announced.add(key);
    }
  } else if (phaseMain){
    if (precipish || !twilightMain) tags.push({ text: phaseMain, italic: true, prefix: true });
  }

  twilightState.lastPhase = tw.phase || null;
  twilightState.lastHourStart = hourStart || null;

  return { main, twilightMain, tags, twilightLabel: phaseMain || null };
}

function maybeApplyTwilightPrecipOverride({
  decorated,
  rainVal,
  baseDesc,
  descTags,
  tw,
  rowIndex,
  fallbackFromNowcast,
  descSource,
  descriptorOpts,
  hourStart
}){
  const result = { applied: false, main: null, tags: null, forceDescWhite: false, forceRainWhite: false };
  if (!decorated || !decorated.twilightMain) return result;
  if (!(Number.isFinite(rainVal) && rainVal > 0)) return result;
  if (!hasPrecipFogOrThunderDescriptor(baseDesc, descriptorOpts)) return result;

  const tags = Array.isArray(descTags) ? [...descTags] : [];
  if (decorated.twilightLabel){
    tags.unshift({ text: decorated.twilightLabel, italic: true, preserveCase: true });
  }

  let main = (typeof baseDesc === 'string') ? baseDesc : '';
  if (main && main !== '–'){
    let tinted = maybeApplyGoldTint(main, tw, hourStart);
    main = tinted;
  }

  let mainHtml = main || baseDesc || '–';

  const italicizeThunder = (
    rowIndex === 2 &&
    !!fallbackFromNowcast &&
    descSource === 'harmonie' &&
    isThunderOrHailDescriptor(baseDesc, descriptorOpts)
  );
  if (italicizeThunder){
    const body = ensureQuestionSuffix(mainHtml);
    mainHtml = wrapItalic(body);
  }

  result.applied = true;
  result.main = mainHtml;
  result.tags = tags;
  result.forceDescWhite = true;
  result.forceRainWhite = true;
  return result;
}

function computeHighlightStates({ rowIndex, rainVal, descWet, descWeak }){
  const rainWhite = (rainVal!=null && rainVal>0 && !(rowIndex>=3 && descWeak && rainVal<0.3));
  let descWhite = false;
  if (rowIndex < 3){
    if (rainWhite) descWhite = true;
    else if (descWet && !descWeak) descWhite = true;
  } else if (descWet){
    if (!descWeak) descWhite = true;
    else if (rainVal!=null && rainVal>=0.3) descWhite = true;
  }
  if (rainVal === 0) descWhite = false;
  return { rainWhite, descWhite };
}

/* --------- solut --------- */
function rainCell(val, { markGrey=false, source=null } = {}){
  if (val==null || isNaN(Number(val))) return { text:'–', num:null, extraClass:'', forceGrey:true, source };
  const n = Number(val);
  if (n === 0) return { text:'—', num:0, extraClass:'dash', forceGrey:true, source };
  return { text:n.toFixed(1)+' mm', num:n, extraClass:'', forceGrey:markGrey, source };
}
function formatWindSpeed(val){
  if (!Number.isFinite(val)) return null;
  const rounded = Math.round(val);
  return (Object.is(rounded, -0) ? 0 : rounded).toString();
}

function windCell(mean, gust, dirDeg, { meanSource='harmonie', gustSource=null } = {}){
  const mOk = (mean!=null && !isNaN(Number(mean)));
  const gOk = (gust!=null && !isNaN(Number(gust)));
  const meanV = mOk ? Number(mean) : null;
  const gustV = gOk ? Number(gust) : null;

  const meanTxt = formatWindSpeed(meanV);
  let txt = (mOk && meanTxt!=null ? meanTxt+' m/s' : '–');

  let gustTxt = '';
  let highlight = false;
  if (gOk && gustV >= 15){
    const gustFmt = formatWindSpeed(gustV);
    if (gustFmt != null){
      gustTxt = ` (<em style="color:var(--color-mini-strong)">${gustFmt}</em>)`;
    }
    highlight = true;
  }
  if (mOk && meanV >= 10) highlight = true;

  const dirTxt = dir8(dirDeg);
  const dirHtml = dirTxt ? `<span class="${highlight ? 'miniW' : 'mini'} windDir">${dirTxt}</span>` : '';

  const sources = new Set();
  if (meanSource) sources.add(meanSource);
  if (gOk && gustSource) sources.add(gustSource);

  return { html: txt + gustTxt + dirHtml, white: highlight, sources: Array.from(sources) };
}

/* Ditto */
function normalizedDittoKey(s){
  return s.toLowerCase().replace(/<[^>]*>/g,'').replace(/[()[\]{}?.,]/g,'').replace(/\s+/g,' ').trim();
}
function renderRow(row, state){
  const {
    timeHtml,
    temp,
    descHtml,
    descMainHtml,
    descWhite,
    descDisplaySource,
    descExpectedNowcast = false,
    descFallbackFromNowcast = false,
    rainObj,
    rainWhite,
    rainSource,
    rainExpectedNowcast = false,
    rainFallbackFromNowcast = false,
    windObj,
    windWhite,
    windSources,
    windExpectedNowcast = false,
    windFallbackFromNowcast = false,
    twDbg,
    rainTag,
    timeWhite = false,
    tempWhite = false,
    skipDitto = false
  } = row || {};
  const rain = rainObj || { text: '–', num: null, extraClass: '', forceGrey: false, source: null };
  const wind = windObj || { html: '–', white: false, sources: [] };
  const mainHtml = descMainHtml || descHtml || '–';
  const plain = mainHtml.replace(/<[^>]*>/g,'').trim();
  const normalized = plain ? normalizedDittoKey(plain) : '';
  let displayDesc = (typeof descHtml === 'string' && descHtml.length) ? descHtml : mainHtml;
  if (!skipDitto && normalized && state.prevDescKey && normalized === state.prevDescKey){
    let tailHtml = '';
    if (typeof descHtml === 'string' && descHtml.length){
      if (descHtml.startsWith(mainHtml)){
        tailHtml = descHtml.slice(mainHtml.length);
      } else {
        const idx = descHtml.indexOf(mainHtml);
        if (idx >= 0){
          tailHtml = descHtml.slice(idx + mainHtml.length);
        }
      }
    }
    if (tailHtml){
      tailHtml = tailHtml.replace(/(<span[^>]*data-ditto-ellipsis=\"1\"[^>]*>)(\s*)(?!\.\.\.)([^<]*)/gi, (match, open, ws, text) => {
        const trimmed = text || '';
        if (trimmed.startsWith('...')) return open + ws + trimmed;
        return open + ws + '...' + trimmed;
      });
    }
    displayDesc = '<span class="ditto" title="sama kuin edellä">&raquo;</span>' + (tailHtml || '');
  } else {
    state.prevDescKey = normalized || null;
  }
  const descBadge = buildSourceBadge({
    source: descDisplaySource,
    expectedNowcast: !!descExpectedNowcast,
    fallbackFromNowcast: !!descFallbackFromNowcast
  });
  if (descBadge){
    displayDesc += ` ${descBadge}`;
  }
  const resolvedRainSource = rainSource != null ? rainSource : rain.source;
  const rainBadge = buildSourceBadge({
    source: resolvedRainSource,
    expectedNowcast: !!rainExpectedNowcast,
    fallbackFromNowcast: !!rainFallbackFromNowcast
  });
  const rainTagHtml = (rain.text === '—') ? '' : tag(rainTag || '');
  const rainBadgeHtml = rainBadge ? ` ${rainBadge}` : '';
  const twTag = DBG && twDbg ? ` <span class="soft" style="font-size:12px">${twDbg}</span>` : '';
  const descClasses = ['desc'];
  if (descWhite) descClasses.push('descWhite'); else descClasses.push('soft');
  const timeClasses = ['cell'];
  if (!timeWhite) timeClasses.push('soft');
  const tempClasses = ['cell','hh'];
  if (!tempWhite) tempClasses.push('soft');
  const rainClasses = ['cell'];
  if (!rainWhite || rain.forceGrey) rainClasses.push('soft');
  if (rain.extraClass) rainClasses.push(rain.extraClass);
  const windClasses = ['cell'];
  if (!windWhite) windClasses.push('soft');
  const resolvedWindSources = Array.isArray(windSources) && windSources.length
    ? windSources
    : (Array.isArray(wind.sources) ? wind.sources : []);
  const uniqueWindSources = Array.from(new Set(resolvedWindSources.filter(Boolean)));
  const windBadges = uniqueWindSources
    .map(src => buildSourceBadge({
      source: src,
      expectedNowcast: !!(windExpectedNowcast && src === 'nowcast'),
      fallbackFromNowcast: !!(windFallbackFromNowcast && src === 'harmonie')
    }))
    .filter(Boolean)
    .join(' ');
  const windBadgeHtml = windBadges ? ` ${windBadges}` : '';
  return (
    `<div class="row">`+
      `<div class="${timeClasses.join(' ')}">${timeHtml || '–'}</div>`+
      `<div class="${tempClasses.join(' ')}">${(temp!=null && !Number.isNaN(temp))?Math.round(temp)+'°':'–'}</div>`+
      `<div class="${descClasses.join(' ')}">${displayDesc}${twTag}</div>`+
      `<div class="${rainClasses.join(' ')}">${rain.text}${rainTagHtml}${rainBadgeHtml}</div>`+
      `<div class="${windClasses.join(' ')}">${wind.html}${windBadgeHtml}</div>`+
    `</div>`
  );
}

function createHourlyRowModel({ hour, index, nowcast, twilightResolver, launchTime }){
  if (!hour || !(hour.time instanceof Date) || Number.isNaN(hour.time.getTime())) return null;
  const dUtc = new Date(hour.time);
  const isNowcastHour = index <= 2;
  const expectedNowcast = isNowcastHour;
  const smartSymbolCode = hour.smartSymbol;
  const nowcastCode = isNowcastHour ? nowcast?.sym : null;
  const descriptorOpts = { smartSymbolCode, nowcastCode };
  let rainTag = isNowcastHour ? nowcastMetaTag(nowcast?.meta) : 'HRM';
  let rainVal = null;
  let rainObj = null;
  let rainSource = null;
  let rainFallbackFromNowcast = false;
  if (isNowcastHour && nowcast && typeof nowcast.val === 'number'){
    rainVal = nowcast.val < 0.1 ? 0 : nowcast.val;
    rainSource = 'nowcast';
    rainObj = rainCell(rainVal, { source: rainSource });
  } else {
    const hrmVal = (typeof hour.precipitation === 'number') ? hour.precipitation : null;
    rainVal = hrmVal;
    rainSource = 'harmonie';
    if (isNowcastHour) rainFallbackFromNowcast = true;
    if (!isNowcastHour){
      const wet = (rainVal != null && rainVal > 0);
      const smallWet = (wet && rainVal < 0.3);
      const ssDay = (smartSymbolCode != null) ? (Number(smartSymbolCode) % 100) : null;
      const useGreyRain = smallWet && (ssDay == null || !SMALL_RAIN_EXCEPT.has(ssDay));
      rainObj = rainCell(rainVal, { markGrey: useGreyRain, source: rainSource });
    } else {
      rainObj = rainCell(rainVal, { markGrey: index >= 3, source: rainSource });
      rainTag = 'HRM';
    }
  }
  if (!rainObj) rainObj = rainCell(rainVal, { source: rainSource });
  const gustAvailable = (index === 0 && nowcast && typeof nowcast.gust === 'number');
  const gust = gustAvailable ? nowcast.gust : null;
  const gustSource = gustAvailable ? 'nowcast' : null;
  const windObj = windCell(hour.windSpeed, gust, hour.windDirection, { meanSource: 'harmonie', gustSource });
  const rainExpectedNowcast = expectedNowcast;
  const descSelection = selectDescription({
    nowcastText: isNowcastHour ? ncSymbolText(nowcast?.sym) : null,
    harmonieText: ssText(hour.smartSymbol),
    expectedNowcast
  });
  const fogInfo = analyzeFogDescriptor({ text: descSelection.text, source: descSelection.source });
  let baseDesc = fogInfo.baseText || descSelection.text || '–';
  const descSource = descSelection.source;
  const fallbackFromNowcast = descSelection.fallbackFromNowcast;
  let descDisplaySource = descSource;
  let descDisplayFallbackFromNowcast = fallbackFromNowcast;
  baseDesc = capitalizeDryDescriptor(baseDesc, descriptorOpts);
  const descWet = isWetDescriptor(baseDesc, descriptorOpts);
  const descWeak = isWeakWetDescriptor(baseDesc, descriptorOpts);
  let precipish;
  if (isNowcastHour){
    precipish = ((rainVal != null && rainVal >= 0.1) || (nowcastCode && ncIsPrecip(nowcastCode)) || descWet);
  } else {
    const wet = (rainVal != null && rainVal > 0);
    precipish = wet || descWet;
  }
  let descMain = baseDesc || '–';
  let descTags = [];
  let descExtra = '';
  let twDbg = '';
  let insertedThunderTag = false;
  let twilightFlags = { hadTwilightMain: false, overrideApplied: false };
  let twilightOverride = { applied: false, forceDescWhite: false, forceRainWhite: false };
  try{
    const tw = typeof twilightResolver === 'function' ? twilightResolver(new Date(dUtc)) : null;
    const decorated = decorateDescription(baseDesc, tw, { precipish, hourStart: dUtc });
    twilightFlags.hadTwilightMain = !!decorated.twilightMain;
    descMain = decorated.main || baseDesc || '–';
    descTags = Array.isArray(decorated.tags) ? [...decorated.tags] : [];
    let thunderTag = null;
    if (decorated.twilightMain){
      thunderTag = buildThunderTag({ baseText: baseDesc, source: descSource, descriptorOpts });
    }
    const override = maybeApplyTwilightPrecipOverride({
      decorated,
      rainVal,
      baseDesc,
      descTags,
      tw,
      rowIndex: index,
      fallbackFromNowcast,
      descSource,
      descriptorOpts,
      hourStart: dUtc
    });
    twilightOverride = override;
    if (override.applied){
      twilightFlags.overrideApplied = true;
      descMain = override.main;
      descTags = Array.isArray(override.tags) ? override.tags : [];
      descDisplaySource = descSource;
      descDisplayFallbackFromNowcast = fallbackFromNowcast;
    } else if (thunderTag){
      descTags.unshift(thunderTag);
      insertedThunderTag = true;
      if (decorated.twilightMain){
        descDisplaySource = 'twilight';
        descDisplayFallbackFromNowcast = false;
      }
    } else if (decorated.twilightMain){
      descDisplaySource = 'twilight';
      descDisplayFallbackFromNowcast = false;
    }
    if (DBG){
      if (tw?.dbg) twDbg = `[TW ${tw.dbg}]`;
      else if (tw){
        const p = tw.phase || 'n/a';
        if (tw.sunEvent) twDbg = `[TW ${p} | ${tw.sunEvent.type === 'set' ? 'set' : 'rise'} ${fmtHM(tw.sunEvent.at)}]`;
        else if (tw.withinChange) twDbg = `[TW ${p} | change→${tw.withinChange.to} ${fmtHM(tw.withinChange.at)}]`;
        else twDbg = `[TW ${p}]`;
      }
    }
  }catch{
    if (DBG) twDbg = '[TW!err]';
  }
  if (fogInfo.isFog){
    descMain = fogInfo.displayText;
    descDisplaySource = descSource;
    descDisplayFallbackFromNowcast = fallbackFromNowcast;
  }
  if (DBG && isNowcastHour){
    const isNcTag = rainTag.startsWith('NC');
    const tagText = (isNcTag && nowcast?.sym && !ncIsPrecip(nowcast.sym)) ? `[${ncBase(nowcast.sym)}]` : `[${rainTag}]`;
    descExtra += ` <span class="soft" style="font-size:12px">${tagText}</span>`;
    if (nowcast?.meta && nowcast.meta !== 'NC'){
      descExtra += ` <span class="soft" style="font-size:12px">[${nowcast.meta}]</span>`;
    }
    if (twDbg && !twDbg.startsWith('[TW!err]')){
      descExtra += ` <span class="soft" style="font-size:12px">${twDbg}</span>`;
      twDbg = '';
    }
  }
  const windSources = Array.isArray(windObj?.sources) ? windObj.sources : [];
  const windExpectedNowcast = gustAvailable && windSources.includes('nowcast');
  const windFallbackFromNowcast = false;
  const highlight = computeHighlightStates({
    rowIndex: index,
    rainVal,
    descWet,
    descWeak
  });
  let { rainWhite, descWhite } = highlight;
  if (twilightOverride.applied){
    if (twilightOverride.forceRainWhite) rainWhite = true;
    if (twilightOverride.forceDescWhite) descWhite = true;
    if (rainObj.forceGrey) rainObj.forceGrey = false;
  }
  if (!twilightFlags.overrideApplied && twilightFlags.hadTwilightMain){
    descWhite = false;
  }
  if (insertedThunderTag) descWhite = false;
  const timeWhite = (rainWhite || descWhite || windObj.white);
  const initialDescHtml = buildDescriptionHtml({ main: descMain, tags: descTags, extra: descExtra });
  const contradiction = applyContradiction({
    descHtml: initialDescHtml,
    baseDesc,
    ssCode: hour.smartSymbol,
    rainVal,
    rainDisplay: rainObj.num
  });
  const finalDescHtml = (contradiction && typeof contradiction.html === 'string')
    ? contradiction.html
    : initialDescHtml;
  let timeHtml;
  if (index === 0){
    const launch = (launchTime instanceof Date && !Number.isNaN(launchTime.getTime())) ? launchTime : null;
    const displayTime = launch || dUtc;
    timeHtml = fmtHM(displayTime);
  } else {
    const timeClass = timeWhite ? 'miniW' : 'mini';
    timeHtml = `<span class="${timeClass}">klo&nbsp;</span>${fmtH(dUtc)}`;
  }
  return {
    key: hour.key,
    time: dUtc,
    timeHtml,
    timeWhite,
    temp: hour.temperature,
    tempWhite: false,
    descHtml: finalDescHtml,
    descMainHtml: descMain,
    descWhite,
    descDisplaySource,
    descExpectedNowcast: expectedNowcast,
    descFallbackFromNowcast: descDisplayFallbackFromNowcast,
    rainObj,
    rainWhite,
    rainTag,
    rainSource,
    rainExpectedNowcast,
    rainFallbackFromNowcast,
    windObj,
    windWhite: windObj.white,
    windSources,
    windExpectedNowcast,
    windFallbackFromNowcast,
    twDbg,
    skipDitto: !!(contradiction && contradiction.flagged)
  };
}

function buildHourlyModel({ hours, nowcasts, sunPhases, launchTime }){
  if (!Array.isArray(hours) || !hours.length) return { rows: [] };
  resetTwilightState();
  const nowcastMap = nowcasts instanceof Map ? nowcasts : new Map();
  const sunMap = sunPhases instanceof Map ? sunPhases : new Map();
  const rows = [];
  const resolver = (date) => {
    const key = dateKeyForZone(date, TZ) || (
      Number.isFinite(date.getFullYear())
        ? `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}`
        : null
    );
    const dayObj = key ? (sunMap.get(key) || sunMap.get(String(key)) || null) : null;
    return analyzeTwilightForHour(date, dayObj);
  };
  hours.forEach((hour, index) => {
    const nowcast = nowcastMap.get(hour.key) || nowcastMap.get(hour.time?.toISOString()) || null;
    const row = createHourlyRowModel({ hour, index, nowcast, twilightResolver: resolver, launchTime });
    if (row) rows.push(row);
  });
  return { rows };
}

function renderHourlyModel(model){
  const rows = model?.rows || [];
  if (!rows.length){
    out.innerHTML = `<div class="muted">Ei rivejä tälle ikkunalle.</div>`;
    return;
  }
  const state = { prevDescKey: null };
  const html = rows.map(row => renderRow(row, state));
  out.innerHTML = html.join('');
}

/* --------- render --------- */
(async function(){
  scrollTo(0,1); setTimeout(()=>scrollTo(0,1),150);
  if (LAT_STR == null || LON_STR == null || !Number.isFinite(LAT) || !Number.isFinite(LON)){
    out.innerHTML = `<div class="err">Puuttuvat tai virheelliset koordinaatit. Käytä:<br><code>?lat=60.1699&lon=24.9384</code></div>`;
    return;
  }

  out.innerHTML = '<div class="muted">Ladataan säätietoja…</div>';

  try{
    const forecastData = await fetchForecast(LAT, LON);
    const now = new Date();
    const thisHourLocal = new Date(new Date(now).setMinutes(0,0,0));
    const upcoming = forecastData.hours.filter(hour => {
      const time = hour?.time instanceof Date ? hour.time : new Date(hour?.key || hour);
      return time instanceof Date && !Number.isNaN(time.getTime()) && time >= thisHourLocal;
    }).slice(0, 13);

    if (!upcoming.length){
      out.innerHTML = `<div class="muted">Ei rivejä tälle ikkunalle.</div>`;
      return;
    }

    const nowcastTargets = upcoming.slice(0, 3);
    const [nowcasts, sunPhases] = await Promise.all([
      fetchNowcasts(LAT, LON, nowcastTargets),
      fetchSunPhases(LAT, LON, upcoming)
    ]);

    const model = buildHourlyModel({ hours: upcoming, nowcasts, sunPhases, launchTime: now });
    renderHourlyModel(model);
  }catch(e){
    const msg = (e && e.message) ? e.message : String(e);
    out.innerHTML = `<div class="err">${msg}</div>`;
  }
})();
</script>

</body>
</html>
