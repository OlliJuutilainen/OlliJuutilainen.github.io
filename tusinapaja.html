<!doctype html>
<html lang="fi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="noindex">
<title>TUSINASÄÄ 12</title>
<style>
  :root { color-scheme: dark; }
  html,body{height:100%}
  body{
    margin:0; padding:22px 14px 24px; background:#000; color:#e8e8e8;
    font:17px/1.5 Arial,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
    font-synthesis:none;
  }
  .pageTitle{ font-weight:700; font-size:15px; letter-spacing:.4px; color:#9aa6b0;
    text-transform:uppercase; margin:0 0 4px 0 }
  .mini{ color:#7f8a93; font-size:12px; letter-spacing:.3px; line-height:1.2 }
  .miniTwilight{ font-style:italic; font-weight:300 }
  .twilightMainText{
    font-size:13px;
    text-transform:uppercase;
    letter-spacing:.6px;
    font-style:italic;
    font-weight:350;
    font-variation-settings:'wght' 350;
  }
  @supports not (font-weight: 350){
    .twilightMainText{
      font-weight:300;
    }
  }
  .miniPrefixed::before{
    content:'';
    display:inline-block;
    width:var(--mini-ellipsis-width, 10px);
  }
  .miniW{ color:#e8e8e8; font-size:12px; letter-spacing:.3px; line-height:1.2 }
  .caps{ text-transform:uppercase; letter-spacing:.5px }
  .list{ border-top:1px solid #2a2a2a; margin-top:6px; }
  .sourceBadge{
    display:inline-block;
    margin-left:6px;
    padding:1px 5px 0;
    border:1px solid #2a2a2a;
    border-radius:3px;
    font-size:11px;
    letter-spacing:.3px;
    text-transform:uppercase;
    color:#7f8a93;
  }
  .sourceBadgeNc{ color:#9fb6ff; border-color:#35415a; }
  .sourceBadgeHrm{ color:#b7b7b7; border-color:#3a3a3a; }
  .sourceBadgeFallback{ color:#d9b27d; border-color:#5a4528; }
  .hdr{
    color:#6b7580; font-size:12px; letter-spacing:.3px; margin:6px 0 4px 0;
    display:grid; grid-template-columns:54px 34px 1fr 70px 70px; align-items:end; justify-items:center;
    gap:8px;
  }
  .hdr > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px }
  .hdr div:nth-child(-n+3){ justify-self:start; text-align:left }
  .hdr div:nth-child(4){ justify-self:center; text-align:center; transform:translateX(-1px) }
  .hdr div:nth-child(5){ justify-self:start; text-align:left; font-size:11px }
  .row{
    display:grid; grid-template-columns:54px 34px 1fr 70px 70px;
    gap:8px; padding:6px 0; border-bottom:1px solid #1c1c1c; align-items:center;
    min-height:54px;
  }
  .row > div:first-child{ border-right:1px solid #2a2a2a; padding-right:10px; margin-right:4px; text-align:right }
  .muted{ color:#74808a } .soft{ color:#7f8a93 }
  .cell{ color:#e8e8e8 }
  .cell.soft{ color:#7f8a93 }
  .desc{ color:#7f8a93 }
  .descWhite{ color:#e8e8e8 }
  .contradictionMain{ text-decoration:line-through; text-decoration-thickness:1.1px; text-decoration-color:#a65050; text-decoration-skip-ink:auto }
  .contradictionNote{ display:block; font-size:9px; font-style:italic; color:#888; letter-spacing:.2px; margin-top:2px }
  .row > div:nth-child(4){ text-align:center }
  .row > div:nth-child(5){ font-size:16px }
  .desc .ditto{ display:inline } .ditto{ color:inherit }
  .dash{ text-align:center }
  .windDir{ display:block; margin-top:2px; font-size:11px }
  .err{ color:#ff6b6b; white-space:pre-wrap; font-size:14px; margin-top:8px }
</style>
</head>
<body>

<h1 id="pageTitle" class="pageTitle" style="display:none"></h1>

<div class="hdr">
  <div></div><div></div><div></div>
  <div class="caps">SADE</div>
  <div class="caps">TUULEE</div>
</div>
<div class="list" id="out" aria-live="polite"></div>

<script src="https://cdn.jsdelivr.net/npm/tz-lookup@6.1.25/dist/tz.js"></script>
<script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.min.js"></script>

<script>
/* --------- perusinfra & virheet näkyviin --------- */
/* --------- tonttien työlista (palaverin jatkotoimet) --------- */
/*
1. Yhtenäistä pääselitteen kirjainkoko niin, että `capitalizeDayDescription`
   ajetaan kaikissa vaiheissa ilman päivä-vaiherajausta, ja varmista samalla,
   ettei tyhjät tai HTML-elementillä alkavat selitteet muutu.
2. Selvitä nousua edeltävien kuivien tuntien käsittely: kun hämärävaihe ei enää
   päädy päätekstiksi, varmista että kuivan sään kuvaus nostaa ensimmäisen
   kirjaimen isoksi ja ettei hämärän CSS-yläsuuraus laukea vahingossa.
3. Päivitä testisuunnitelma kattamaan sumu-, sade- ja kuivatapaukset sekä
   aurinkotapahtumien molemmat kieliasut, jotta kirjaimiston poikkeamat eivät
   palaa jatkokehityksessä.
*/
const out = document.getElementById('out');
window.addEventListener('error', e => {
  const msg = (e && e.message) ? e.message : String(e);
  const where = (e && e.filename) ? `\n@ ${e.filename}:${e.lineno||''}:${e.colno||''}` : '';
  out.innerHTML = `<div class="err">Virhe: ${msg}${where}</div>` + out.innerHTML;
});
window.addEventListener('unhandledrejection', e => {
  const reason = e?.reason;
  const msg = reason ? (reason.message || String(reason)) : 'tuntematon virhe';
  out.innerHTML = `<div class="err">Virhe (lupaus): ${msg}</div>` + out.innerHTML;
});

/* --------- mittaa ellipsin leveys pienitekstissä --------- */
function initMiniEllipsisWidth(){
  if (!document?.body) return;
  const span = document.createElement('span');
  span.className = 'mini';
  span.textContent = '...';
  span.style.visibility = 'hidden';
  span.style.position = 'absolute';
  span.style.whiteSpace = 'pre';
  span.style.pointerEvents = 'none';
  document.body.appendChild(span);
  const rect = span.getBoundingClientRect();
  span.remove();
  const width = rect?.width;
  if (Number.isFinite(width) && width > 0){
    const px = width.toFixed(2)+'px';
    document.documentElement.style.setProperty('--mini-ellipsis-width', px);
    window.__miniEllipsisWidth = width;
  }
}
if (document.readyState === 'loading'){
  document.addEventListener('DOMContentLoaded', initMiniEllipsisWidth, { once: true });
} else {
  initMiniEllipsisWidth();
}

/* --------- URL-parametrit --------- */
const q = new URLSearchParams(location.search);
const LAT_STR = q.get('lat'); const LON_STR = q.get('lon');
const LAT = parseFloat(LAT_STR); const LON = parseFloat(LON_STR);
const DBG = q.has('dbg');
const SHOW_SOURCE_BADGES = DBG || q.has('src');
const tag = s => DBG ? ` <span class="soft" style="font-size:12px">${s}</span>` : '';

const FALLBACK_TIME_ZONE = (() => {
  try {
    const resolved = Intl.DateTimeFormat().resolvedOptions()?.timeZone;
    return (typeof resolved === 'string' && resolved) ? resolved : 'UTC';
  } catch (err) {
    return 'UTC';
  }
})();

function inferTimeZone(lat, lon){
  const fallback = FALLBACK_TIME_ZONE || 'UTC';
  if (Number.isFinite(lat) && Number.isFinite(lon)){
    try {
      if (typeof tzlookup === 'function'){
        const guess = tzlookup(lat, lon);
        if (typeof guess === 'string' && guess) return guess;
      }
    } catch (err) {
      if (DBG) console.warn('tzlookup fail', err);
    }
  }
  return fallback;
}

let timeZone = inferTimeZone(LAT, LON);
if (typeof timeZone !== 'string' || !timeZone){
  timeZone = FALLBACK_TIME_ZONE || 'UTC';
}
const TZ = timeZone;

/* --------- erikoisotsikot --------- */
const pageTitle = document.getElementById('pageTitle');
if (LAT_STR === '60.3281' && LON_STR === '25.0551'){
  pageTitle.textContent = 'TUSINASÄÄ 12 · ASOLA'; pageTitle.style.display = '';
} else if (LAT_STR === '60.1562' && LON_STR === '24.7767'){
  pageTitle.textContent = 'TUSINASÄÄ 12 · RANTAKOTO'; pageTitle.style.display = '';
}

/* --------- aikaformatit --------- */
const hmFi = new Intl.DateTimeFormat('fi-FI',{hour:'2-digit',minute:'2-digit',hour12:false,timeZone:TZ,hourCycle:'h23'});
function fmtHM(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}:${ps.find(p=>p.type==='minute')?.value||'00'}`; }
function fmtH(d){ const ps=hmFi.formatToParts(d); return `${ps.find(p=>p.type==='hour')?.value||'00'}`; }

/* --------- SS-sanakirja (sovittu) --------- */
const SS_TEXT = {
  1:'sinistä', 2:'sangen sinistä', 4:'siniharmaata', 6:'sangen harmaata', 7:'harmaata',
  9:'sumua',
  71:'seppoa kutittaa', 74:'seppoa ärsyttää', 77:'seppo on vihainen',
  21:'kuuro jossain', 24:'kuuroja', 27:'kuuroja sakeana',
  11:'tihkuu', 14:'kryotihkua', 17:'kryosadetta',
  31:'siniharmaasta ripsii', 34:'sangen harmaasta ripsii', 37:'ripsii',
  32:'siniharmaasta satelee', 35:'sangen harmaasta satelee', 38:'satelee',
  33:'siniharmaasta kaatosadettakin', 36:'sangen harmaasta myös kaatosadettakin', 39:'kaatosadetta',
  41:'siniharmaasta märkä hiutale', 44:'sangen harmaasta märkä hiutale', 47:'märkä hiutale',
  42:'siniharmaasta räntää', 45:'sangen harmaasta räntää', 48:'räntää',
  43:'siniharmaasta tiskirättiä', 46:'sangen harmaasta tiskirättiä', 49:'tiskirättiä',
  51:'sinihirmaasta kevyt hiutale', 54:'sangen harmaasta kevyt hiutale', 57:'kevyt hiutale',
  52:'siniharmaasta lunta', 55:'sangen harmaasta lunta', 58:'lunta',
  53:'siniharmaasta pyryä', 56:'sangen harmaasta pyryä', 59:'pyryttää',
  61:'rakeita jossain', 64:'rakeita', 67:'rakeiden tulitus'
};
const SMART_SYMBOL_INFO = {
  1:  { label: 'clear', dry: true },
  2:  { label: 'mostly_clear', dry: true },
  4:  { label: 'partly_cloudy', dry: true },
  6:  { label: 'cloudy', dry: true },
  7:  { label: 'overcast', dry: true },
  9:  { label: 'fog', fog: true },
  11: { label: 'drizzle', precip: true, weak: true },
  14: { label: 'freezing_drizzle', precip: true, weak: true, highlightSmall: true },
  17: { label: 'freezing_rain', precip: true, highlightSmall: true, contradictionHeavy: true },
  21: { label: 'shower_light', precip: true, highlightSmall: true },
  24: { label: 'shower', precip: true, highlightSmall: true, contradictionHeavy: true },
  27: { label: 'shower_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  31: { label: 'light_rain', precip: true },
  32: { label: 'rain', precip: true, highlightSmall: true, contradictionHeavy: true },
  33: { label: 'rain_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  34: { label: 'light_rain', precip: true },
  35: { label: 'rain', precip: true, highlightSmall: true, contradictionHeavy: true },
  36: { label: 'rain_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  37: { label: 'light_rain', precip: true },
  38: { label: 'rain', precip: true, highlightSmall: true, contradictionHeavy: true },
  39: { label: 'rain_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  41: { label: 'wet_snow_light', precip: true, weak: true },
  42: { label: 'sleet', precip: true, highlightSmall: true, contradictionHeavy: true },
  43: { label: 'sleet_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  44: { label: 'wet_snow', precip: true },
  45: { label: 'sleet', precip: true, highlightSmall: true, contradictionHeavy: true },
  46: { label: 'sleet_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  47: { label: 'wet_snow', precip: true },
  48: { label: 'sleet', precip: true, highlightSmall: true, contradictionHeavy: true },
  49: { label: 'sleet_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  51: { label: 'snow_light', precip: true, weak: true },
  52: { label: 'snow', precip: true, highlightSmall: true, contradictionHeavy: true },
  53: { label: 'snow_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  54: { label: 'snow_light', precip: true },
  55: { label: 'snow', precip: true, highlightSmall: true, contradictionHeavy: true },
  56: { label: 'snow_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  57: { label: 'snow_light', precip: true },
  58: { label: 'snow', precip: true, highlightSmall: true, contradictionHeavy: true },
  59: { label: 'snow_heavy', precip: true, highlightSmall: true, contradictionHeavy: true },
  61: { label: 'hail', precip: true, hail: true, highlightSmall: true, contradictionHeavy: true },
  64: { label: 'hail', precip: true, hail: true, highlightSmall: true, contradictionHeavy: true },
  67: { label: 'hail', precip: true, hail: true, highlightSmall: true, contradictionHeavy: true },
  71: { label: 'thunder', precip: true, thunder: true, highlightSmall: true },
  74: { label: 'thunder', precip: true, thunder: true, highlightSmall: true },
  77: { label: 'thunder', precip: true, thunder: true, highlightSmall: true }
};
const ssText = c => {
  if (c == null) return '';
  const num = Number(c);
  if (!Number.isFinite(num)) return '';
  const key = ((num % 100) + 100) % 100;
  return SS_TEXT[key] || '';
};
const SMART_SYMBOL_SMALL_RAIN = new Set(
  Object.entries(SMART_SYMBOL_INFO)
    .filter(([, info]) => info.highlightSmall)
    .map(([key]) => Number(key))
);
const SMART_SYMBOL_HEAVY = new Set(
  Object.entries(SMART_SYMBOL_INFO)
    .filter(([, info]) => info.contradictionHeavy)
    .map(([key]) => Number(key))
);
const DRY_TEXTS = new Set(['sinistä','sangen sinistä','siniharmaata','sangen harmaata','harmaata']);

function smartSymbolInfo(code){
  if (code == null) return null;
  const num = Number(code);
  if (!Number.isFinite(num)) return null;
  const key = ((num % 100) + 100) % 100;
  return SMART_SYMBOL_INFO[key] || null;
}

/* pienen sateen ( <0.3 mm ) poikkeuslista (säilytä valkoisena jos nämä) */
const SMALL_RAIN_EXCEPT = SMART_SYMBOL_SMALL_RAIN;
const HEAVY_SSCODE = SMART_SYMBOL_HEAVY;

/* --------- MET Nowcast symbolit (NC) --------- */
const NC_SYMBOL = {
  'clearsky': "sinistä", 'fair': "sangen sinistä", 'partlycloudy': "siniharmaata", 'cloudy': "harmaata",
  'lightrainshowers': "jokunen kuuro", 'heavyrainshowers': "äänekästä kuuroa",
  'rainshowersandthunder': "sepon välisuihkut", 'thunderstorm': "seppo riehuu",
  'heavyrain': "saavista kaatuu", 'lightrain': "ripsii", 'sleet': "räntää",
  'lightsleetshowers_and_thunder': "sepon tiskivuoro", 'snowshowers_and_thunder': "lumiukkonen",
  'snow': "lunta", 'heavysnow': "pyryttää", 'fog': "sumua"
};
const NOWCAST_INFO = {
  clearsky: { label: 'clear', dry: true },
  fair: { label: 'mostly_clear', dry: true },
  partlycloudy: { label: 'partly_cloudy', dry: true },
  cloudy: { label: 'overcast', dry: true },
  lightrainshowers: { label: 'shower_light', precip: true, weak: true },
  heavyrainshowers: { label: 'shower_heavy', precip: true },
  rainshowersandthunder: { label: 'thunder_shower', precip: true, thunder: true },
  thunderstorm: { label: 'thunder', precip: true, thunder: true },
  heavyrain: { label: 'rain_heavy', precip: true },
  lightrain: { label: 'rain_light', precip: true, weak: true },
  sleet: { label: 'sleet', precip: true },
  lightsleetshowers_and_thunder: { label: 'thunder_sleet', precip: true, thunder: true },
  snowshowers_and_thunder: { label: 'thunder_snow', precip: true, thunder: true },
  snow: { label: 'snow', precip: true },
  heavysnow: { label: 'snow_heavy', precip: true },
  fog: { label: 'fog', fog: true }
};
const ncBase = code => code ? code.replace(/_(day|night)$/,'') : '';
function ncSymbolInfo(code){
  const base = ncBase(code);
  return base ? (NOWCAST_INFO[base] || null) : null;
}
const ncSymbolText = code => (NC_SYMBOL[ncBase(code)] || '');
function ncIsPrecip(code){
  const info = ncSymbolInfo(code);
  return !!(info && (info.precip || info.fog || info.thunder));
}

/* --------- Tuulensuunta tekstit --------- */
function dir8(deg){
  if (deg==null || isNaN(deg)) return '';
  const d = ((deg%360)+360)%360;
  if (d>=337.5 || d<22.5)   return 'pohjoisesta';
  if (d<67.5)               return 'koillisesta';
  if (d<112.5)              return 'idästä';
  if (d<157.5)              return 'kaakosta';
  if (d<202.5)              return 'etelästä';
  if (d<247.5)              return 'lounasta';
  if (d<292.5)              return 'lännestä';
  return 'luoteesta';
}

/* --------- FMI WFS (HARMONIE) --------- */
function buildWfsForecast(lat,lon){
  const base='https://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature';
  const sq='fmi::forecast::harmonie::surface::point::timevaluepair';
  const params='temperature,precipitation1h,windspeedms,winddirection,SmartSymbol';
  const now=new Date(), s=new Date(now), e=new Date(now);
  s.setHours(s.getHours()-2); e.setHours(e.getHours()+24);
  const iso=d=>d.toISOString().replace(/\.\d{3}Z$/,'Z');
  return `${base}&storedquery_id=${encodeURIComponent(sq)}&latlon=${encodeURIComponent(lat+','+lon)}&parameters=${encodeURIComponent(params)}&starttime=${encodeURIComponent(iso(s))}&endtime=${encodeURIComponent(iso(e))}&timestep=60`;
}

/* --------- XML → sarjat --------- */
const parseXML = txt => {
  const x = new DOMParser().parseFromString(txt,'application/xml');
  const ex = x.querySelector('Exception, ows\\:Exception');
  if (ex){ const t=x.querySelector('ExceptionText, ows\\:ExceptionText'); throw new Error('FMI virhe: '+(t?t.textContent:'Tuntematon virhe')); }
  return x;
};
const extractSeries = x => {
  const get=(e,n)=>e.getElementsByTagNameNS('*',n)[0];
  const all=x.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTimeseries');
  const o={};
  for (const s of all){
    const id=(s.getAttribute('gml:id')||'').toLowerCase();
    let k='';
    if (id.includes('temperature')) k='temperature';
    else if (id.includes('precipitation1h')) k='precipitation1h';
    else if (id.includes('windspeedms')) k='windspeedms';
    else if (id.includes('winddirection')) k='winddirection';
    else if (id.includes('smartsymbol')) k='SmartSymbol';
    if (!k) continue;
    const map=new Map();
    const pts=s.getElementsByTagNameNS('http://www.opengis.net/waterml/2.0','MeasurementTVP');
    for (const p of pts){
      const t=get(p,'time')?.textContent;
      const v=get(p,'value')?.textContent;
      if (!t) continue;
      const num = v!=null ? Number(v) : null;
      map.set(t, isNaN(num)?null:num);
    }
    o[k]=map;
  }
  return o;
};

async function fetchForecast(lat, lon){
  const url = buildWfsForecast(lat, lon);
  const res = await fetch(url, { cache: 'no-store' });
  const txt = await res.text();
  if (!res.ok){
    throw new Error(`FMI ennuste HTTP ${res.status}\n${txt.slice(0,400)}`);
  }
  const forecastSeries = extractSeries(parseXML(txt));
  const keys = Array.from(forecastSeries.temperature?.keys?.() || []).sort();
  const hours = keys.map(key => ({
    key,
    time: new Date(key),
    temperature: forecastSeries.temperature?.get(key) ?? null,
    precipitation: forecastSeries.precipitation1h?.get(key) ?? null,
    windSpeed: forecastSeries.windspeedms?.get(key) ?? null,
    windDirection: forecastSeries.winddirection?.get(key) ?? null,
    smartSymbol: forecastSeries.SmartSymbol?.get(key) ?? null
  }));
  return { hours, series: forecastSeries };
}

/* --------- MET Nowcast – sade + puuska + symbol_code --------- */
const NOWCAST_CACHE_TTL = 5 * 60 * 1000;
const NOWCAST_RETRY_COOLDOWN = 60 * 1000;
const nowcastShared = new Map();

function nowcastKey(lat, lon){
  return `${Number(lat).toFixed(4)},${Number(lon).toFixed(4)}`;
}

async function fetchNowcastTimeseries(lat, lon){
  try{
    const url = `https://api.met.no/weatherapi/nowcast/2.0/complete?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&altitude=0`;
    const res = await fetch(url, { cache:'no-store', headers: { 'Accept': 'application/json' } });
    if (!res.ok) return { ok:false, meta:`NC!${res.status}` };
    const js = await res.json();
    const ts = js?.properties?.timeseries;
    if (!Array.isArray(ts) || !ts.length) return { ok:false, meta:'NC!empty' };
    return { ok:true, timeseries: ts };
  }catch{
    return { ok:false, meta:'NC!err' };
  }
}

function pickNowcastFromSeries(ts, dUTC, metaBase){
  if (!(dUTC instanceof Date) || Number.isNaN(dUTC.getTime())) return { val:null, meta:'NC!date' };
  if (!Array.isArray(ts) || !ts.length) return { val:null, meta:'NC!empty' };

  const targetUTC = dUTC.getTime();
  let future=null,fDiff=Infinity,past=null,pDiff=Infinity;
  for (const it of ts){
    const t=new Date(it.time).getTime(), diff=t-targetUTC, ad=Math.abs(diff);
    if (diff>=0 && ad<fDiff){fDiff=ad; future=it;}
    if (diff<0  && ad<pDiff){pDiff=ad; past=it;}
  }
  let best=null;
  if (future && fDiff<=60*60000) best=future;
  else if (past && pDiff<=60*60000) best=past;
  if (!best) return { val:null, meta:'NC!miss' };

  const acc  = best?.data?.next_1_hours?.details?.precipitation_amount;
  const pr   = best?.data?.instant?.details?.precipitation_rate;
  const gust = best?.data?.instant?.details?.wind_speed_of_gust;
  const sym  = best?.data?.next_1_hours?.summary?.symbol_code || null;

  let p = null; if (typeof acc === 'number') p = acc; else if (typeof pr === 'number') p = pr;
  const meta = metaBase || 'NC';
  return { val:(typeof p==='number'?p:null), meta, gust:(typeof gust==='number'?gust:null), sym };
}

async function ensureNowcastBundle(lat, lon){
  const key = nowcastKey(lat, lon);
  const now = Date.now();
  let entry = nowcastShared.get(key);
  if (!entry){
    entry = { timeseries:null, fetchedAt:0, stale:false, meta:'NC!init', promise:null, retryAt:0 };
    nowcastShared.set(key, entry);
  }

  if (entry.promise){
    return entry.promise;
  }

  if (entry.timeseries){
    if (!entry.stale && (now - entry.fetchedAt) <= NOWCAST_CACHE_TTL){
      return { ok:true, timeseries: entry.timeseries, meta:'NC', stale:false };
    }
    if (entry.stale && now < entry.retryAt){
      return { ok:true, timeseries: entry.timeseries, meta:'NC~stale', stale:true };
    }
  }

  entry.promise = (async()=>{
    try{
      const res = await fetchNowcastTimeseries(lat, lon);
      if (res.ok){
        entry.timeseries = res.timeseries;
        entry.fetchedAt = Date.now();
        entry.stale = false;
        entry.meta = 'NC';
        entry.retryAt = 0;
        return { ok:true, timeseries: entry.timeseries, meta:'NC', stale:false };
      }
      entry.meta = res.meta || 'NC!err';
      entry.retryAt = Date.now() + NOWCAST_RETRY_COOLDOWN;
      if (entry.timeseries){
        entry.stale = true;
        return { ok:true, timeseries: entry.timeseries, meta:'NC~stale', stale:true };
      }
      entry.timeseries = null;
      entry.stale = false;
      return { ok:false, timeseries:null, meta:entry.meta, stale:false };
    } finally {
      entry.promise = null;
    }
  })();

  return entry.promise;
}

async function fetchNowcastForHour(lat, lon, dUTC){
  const bundle = await ensureNowcastBundle(lat, lon);
  if (!bundle || !bundle.ok){
    return { val:null, meta: bundle?.meta || 'NC!err' };
  }
  const metaBase = bundle.meta || (bundle.stale ? 'NC~stale' : 'NC');
  const picked = pickNowcastFromSeries(bundle.timeseries, dUTC, metaBase);
  if (bundle.stale && picked.meta === 'NC'){
    return { ...picked, meta:'NC~stale' };
  }
  return picked;
}

async function fetchNowcasts(lat, lon, targetHours){
  if (!Array.isArray(targetHours) || !targetHours.length){
    return new Map();
  }
  const results = await Promise.all(targetHours.map(h => {
    const date = h?.time instanceof Date ? h.time : new Date(h?.key || h);
    return fetchNowcastForHour(lat, lon, date).catch(() => ({ val:null, meta:'NC!err' }));
  }));
  const map = new Map();
  targetHours.forEach((hour, idx) => {
    const key = hour?.key || (hour?.time instanceof Date ? hour.time.toISOString() : null);
    if (key) map.set(key, results[idx] || { val:null, meta:'NC!err' });
  });
  return map;
}

function nowcastMetaTag(meta){
  if (typeof meta !== 'string') return 'NC';
  if (meta.startsWith('NC~')) return 'NC~';
  if (meta.startsWith('NC!')) return 'NC!';
  return 'NC';
}

/* --------- Sunrise API: hämärä- ja nousu/laskuajat --------- */
const TZ_PARTS_CACHE = new Map();
function getTimeZoneFormatter(timeZone){
  const key = timeZone || 'UTC';
  if (TZ_PARTS_CACHE.has(key)) return TZ_PARTS_CACHE.get(key);
  let fmt;
  try {
    fmt = new Intl.DateTimeFormat('en-US',{
      timeZone: key,
      hour12: false,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      fractionalSecondDigits: 3
    });
  } catch (err) {
    fmt = new Intl.DateTimeFormat('en-US',{
      timeZone: key,
      hour12: false,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  }
  TZ_PARTS_CACHE.set(key, fmt);
  return fmt;
}
function partsForZone(date, timeZone){
  if (!isValidDate(date)) return null;
  try {
    const parts = getTimeZoneFormatter(timeZone).formatToParts(date);
    const obj = {};
    for (const part of parts){
      if (part.type === 'literal') continue;
      if (obj[part.type] == null) obj[part.type] = part.value;
    }
    if (obj.second == null) obj.second = '00';
    return obj;
  } catch (err) {
    if (DBG) console.warn('partsForZone fail', err);
    return null;
  }
}
function numOrNaN(value){
  const n = Number(value);
  return Number.isFinite(n) ? n : NaN;
}
function fractionalToMillis(value){
  if (value == null) return 0;
  const str = String(value).replace(/\D/g,'');
  if (!str) return 0;
  return Number(str.slice(0,3).padEnd(3,'0'));
}
function calendarParts(date, timeZone){
  const parts = partsForZone(date, timeZone);
  if (!parts) return null;
  const year = numOrNaN(parts.year);
  const month = numOrNaN(parts.month);
  const day = numOrNaN(parts.day);
  const hour = numOrNaN(parts.hour);
  const minute = numOrNaN(parts.minute);
  const second = numOrNaN(parts.second);
  if (![year, month, day, hour, minute, second].every(Number.isFinite)) return null;
  const millisecond = fractionalToMillis(parts.fractionalSecond);
  return { year, month, day, hour, minute, second, millisecond };
}
function makeDateInTimeZone(year, month, day, hour, minute, second, timeZone){
  const base = new Date(Date.UTC(year, month-1, day, hour, minute, second));
  const parts = calendarParts(base, timeZone);
  if (!parts) return base;
  const utc = Date.UTC(parts.year, parts.month-1, parts.day, parts.hour, parts.minute, parts.second);
  const diff = utc + parts.millisecond - base.getTime();
  return new Date(base.getTime() - diff);
}
function getTimeZoneOffsetMinutes(date, timeZone){
  const parts = calendarParts(date, timeZone);
  if (!parts) return -date.getTimezoneOffset();
  const utc = Date.UTC(parts.year, parts.month-1, parts.day, parts.hour, parts.minute, parts.second);
  return Math.round((utc + parts.millisecond - date.getTime()) / 60000);
}
function canonicalDateForDay(date, timeZone){
  const parts = calendarParts(date, timeZone);
  if (!parts) return date;
  return makeDateInTimeZone(parts.year, parts.month, parts.day, 12, 0, 0, timeZone);
}
function formatOffsetFromMinutes(offMin){
  if (!Number.isFinite(offMin)) return '+00:00';
  const sign = offMin >= 0 ? '+' : '-';
  const abs = Math.abs(offMin);
  const hh = String(Math.trunc(abs/60)).padStart(2,'0');
  const mm = String(Math.trunc(abs%60)).padStart(2,'0');
  return `${sign}${hh}:${mm}`;
}
function dateKeyForZone(date, timeZone){
  const parts = calendarParts(date, timeZone);
  if (!parts) return null;
  const y = String(parts.year).padStart(4,'0');
  const m = String(parts.month).padStart(2,'0');
  const d = String(parts.day).padStart(2,'0');
  return `${y}-${m}-${d}`;
}
function offsetHHMM(d){
  const ref = canonicalDateForDay(isValidDate(d) ? d : new Date(), TZ);
  const offMin = getTimeZoneOffsetMinutes(ref, TZ);
  return formatOffsetFromMinutes(offMin);
}
function offsetToMinutes(offset){
  const m = /^([+-])(\d{2}):(\d{2})$/.exec(offset);
  if (!m) return 0;
  const sign = m[1] === '+' ? 1 : -1;
  const h = Number(m[2]);
  const min = Number(m[3]);
  return sign * (h*60 + min);
}
function isValidDate(d){
  return d instanceof Date && !isNaN(d.getTime());
}
function formatWithOffset(date, offset){
  if (!isValidDate(date)) return null;
  const offMin = offsetToMinutes(offset);
  const shifted = new Date(date.getTime() + offMin*60000);
  const y = shifted.getUTCFullYear();
  const m = String(shifted.getUTCMonth()+1).padStart(2,'0');
  const d = String(shifted.getUTCDate()).padStart(2,'0');
  const hh = String(shifted.getUTCHours()).padStart(2,'0');
  const mm = String(shifted.getUTCMinutes()).padStart(2,'0');
  const ss = String(shifted.getUTCSeconds()).padStart(2,'0');
  return `${y}-${m}-${d}T${hh}:${mm}:${ss}${offset}`;
}
function wrapTimeEntry(str, offset){
  if (!str) return null;
  const dt = new Date(str);
  if (!isValidDate(dt)) return null;
  const formatted = formatWithOffset(dt, offset);
  return formatted ? { time: formatted } : null;
}
function wrapFromDate(dt, offset){
  if (!isValidDate(dt)) return null;
  const formatted = formatWithOffset(dt, offset);
  return formatted ? { time: formatted } : null;
}
/* Cache per YYYY-MM-DD */
const sunriseCache = new Map();
async function fetchSunriseDay(dateLocal, lat, lon){
  const canonical = canonicalDateForDay(dateLocal, TZ);
  const parts = calendarParts(canonical, TZ) || calendarParts(dateLocal, TZ);
  const year = parts?.year ?? canonical.getUTCFullYear();
  const monthIdx = (parts ? parts.month - 1 : canonical.getUTCMonth());
  const day = parts?.day ?? canonical.getUTCDate();
  const key = dateKeyForZone(canonical, TZ) || `${year}-${String(monthIdx+1).padStart(2,'0')}-${String(day).padStart(2,'0')}`;
  if (sunriseCache.has(key)) return sunriseCache.get(key);
  const offset = offsetHHMM(canonical);
  const url = `https://api.met.no/weatherapi/sunrise/3.0/sun?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&date=${key}&offset=${encodeURIComponent(offset)}`;
  try{
    const res = await fetch(url, {cache:'no-store', headers:{'Accept':'application/json'}});
    if (!res.ok){
      const errObj = { __error: `Sunrise v3 HTTP ${res.status}` };
      sunriseCache.set(key, errObj);
      return errObj;
    }
    const js = await res.json();
    const props = js?.properties || (Array.isArray(js?.features) ? js.features[0]?.properties : null) || js?.feature?.properties || null;
    if (!props){
      const errObj = { __error: 'Sunrise v3 empty' };
      sunriseCache.set(key, errObj);
      return errObj;
    }
    const result = {
      sunrise: wrapTimeEntry(props.sunrise?.time, offset),
      sunset: wrapTimeEntry(props.sunset?.time, offset),
      solarnoon: wrapTimeEntry(props.solarnoon?.time, offset),
      solarmidnight: wrapTimeEntry(props.solarmidnight?.time, offset)
    };
    const hasSunCalc = typeof SunCalc === 'object' && SunCalc && typeof SunCalc.getTimes === 'function';
    if (hasSunCalc){
      const offMin = offsetToMinutes(offset);
      const midRef = new Date(Date.UTC(year, monthIdx, day, 12) - offMin*60000);
      const times = SunCalc.getTimes(midRef, lat, lon) || {};
      result.civil_twilight_begin = wrapFromDate(times.dawn, offset);
      result.civil_twilight_end = wrapFromDate(times.dusk, offset);
      result.nautical_twilight_begin = wrapFromDate(times.nauticalDawn, offset);
      result.nautical_twilight_end = wrapFromDate(times.nauticalDusk, offset);
      result.astronomical_twilight_begin = wrapFromDate(times.nightEnd, offset);
      result.astronomical_twilight_end = wrapFromDate(times.night, offset);
    } else {
      result.__warn = 'SunCalc unavailable';
    }
    sunriseCache.set(key, result);
    return result;
  }catch(e){
    const errObj = { __error: `Sunrise v3 ERR ${String(e && e.message || e)}` };
    sunriseCache.set(key, errObj);
    return errObj;
  }
}
const tp = s => s ? new Date(s) : null;

async function fetchSunPhases(lat, lon, hours){
  const uniq = new Map();
  if (Array.isArray(hours)){
    for (const hour of hours){
      const baseDate = hour?.time instanceof Date ? hour.time : new Date(hour?.key || hour);
      if (!isValidDate(baseDate)) continue;
      const key = dateKeyForZone(baseDate, TZ) || (
        Number.isFinite(baseDate.getFullYear())
          ? `${baseDate.getFullYear()}-${String(baseDate.getMonth()+1).padStart(2,'0')}-${String(baseDate.getDate()).padStart(2,'0')}`
          : null
      );
      if (!key || uniq.has(key)) continue;
      uniq.set(key, { key, date: baseDate });
    }
  }
  if (!uniq.size) return new Map();
  const entries = Array.from(uniq.values()).map(({ key, date }) => (
    fetchSunriseDay(date, lat, lon)
      .then(value => ({ key, value }))
      .catch(e => ({ key, value: { __error: `Sunrise run fail: ${e?.message || e}` } }))
  ));
  const results = await Promise.all(entries);
  const map = new Map();
  for (const { key, value } of results){
    map.set(key, value);
  }
  return map;
}

/* Päättele vaihe & mahdollinen vaihtominuutti tunnin sisällä */
function phaseLabel(phase){
  switch(phase){
    case 'day': return null;
    case 'civil': return 'porvarillinen hämärä';
    case 'nautical': return 'nauttinen hämärä';
    case 'astronomical': return 'astronominen hämärä';
    case 'night': return 'säkkipimeä';
    default: return null;
  }
}
const TWILIGHT_PHASES = new Set(['civil','nautical','astronomical','night']);
function nextLabelFor(toPhase){
  if (toPhase==='nautical') return 'vaihtuu nauttiseksi';
  if (toPhase==='astronomical') return 'astronominen hämärä';
  if (toPhase==='night') return 'säkkipimeä';
  if (toPhase==='civil') return 'porvarillinen alkaa';
  return null;
}
function beginLabel(phase){
  if (phase==='astronomical') return 'astronominen hämärä alkaa';
  if (phase==='civil') return 'porvarillinen alkaa';
  if (phase==='nautical') return 'nauttinen hämärä alkaa';
  return null;
}

const MIN = 60000;

function analyzeTwilightForHour(dLocal, dayObj){
  if (!dayObj || dayObj.__error) return { phase: null, withinChange: null, sunEvent: null, dbg: dayObj?.__error||null };
  const rise = tp(dayObj.sunrise?.time);
  const set  = tp(dayObj.sunset?.time);
  const civStart = tp(dayObj.civil_twilight_begin?.time);
  const civEnd   = tp(dayObj.civil_twilight_end?.time);
  const nautStart= tp(dayObj.nautical_twilight_begin?.time);
  const nautEnd  = tp(dayObj.nautical_twilight_end?.time);
  const astroStart=tp(dayObj.astronomical_twilight_begin?.time);
  const astroEnd  =tp(dayObj.astronomical_twilight_end?.time);

  const t0 = new Date(dLocal); t0.setMinutes(0,0,0);
  const t1 = new Date(t0); t1.setHours(t1.getHours()+1);

  function where(t){
    if (astroStart && t<astroStart) return 'night';
    if (astroStart && nautStart && t>=astroStart && t<nautStart) return 'astronomical';
    if (nautStart && civStart && t>=nautStart && t<civStart) return 'nautical';
    if (civStart && rise && t>=civStart && t<rise) return 'civil';
    if (rise && set && t>=rise && t<set) return 'day';
    if (set && civEnd && t>=set && t<civEnd) return 'civil';
    if (civEnd && nautEnd && t>=civEnd && t<nautEnd) return 'nautical';
    if (nautEnd && astroEnd && t>=nautEnd && t<astroEnd) return 'astronomical';
    if (astroEnd && t>=astroEnd) return 'night';
    return null;
  }
  const p0 = where(t0);
  const p1 = where(t1);

  const transitions = [civStart,civEnd,nautStart,nautEnd,astroStart,astroEnd]
    .filter(Boolean)
    .sort((a,b)=>a-b);
  const times = [t0];
  for (const t of transitions){ if (t>t0 && t<t1) times.push(t); }
  times.push(t1);
  const segments = [];
  for (let i=0; i<times.length-1; i++){
    const start = times[i];
    const end = times[i+1];
    if (!start || !end || end<=start) continue;
    const mid = new Date((start.getTime()+end.getTime())/2);
    const phase = where(mid);
    segments.push({ phase, start, end, duration: end-start });
  }

  let dominantPhase = p0;
  let dominantSegment = null;
  for (const seg of segments){
    if (!seg.phase || !TWILIGHT_PHASES.has(seg.phase)) continue;
    if (seg.duration > 30*MIN && (!dominantSegment || seg.duration > dominantSegment.duration)){
      dominantPhase = seg.phase;
      dominantSegment = seg;
    }
  }

  let phaseStart = null;
  if (dominantPhase && TWILIGHT_PHASES.has(dominantPhase)){
    for (const t of transitions){
      if (t > (dominantSegment?.end || t1)) break;
      const to = where(new Date(t.getTime()+1000));
      if (to === dominantPhase) phaseStart = t;
    }
    if (!phaseStart && dominantSegment){
      phaseStart = dominantSegment.start;
    }
  }

  let withinChange = null, sunEvent = null;
  if (rise && rise>=t0 && rise<t1) sunEvent = { type:'rise', at: rise };
  if (set  && set >=t0 && set <t1) sunEvent = { type:'set',  at: set  };

  if (!sunEvent && p0 && p1 && p0!==p1){
    const candidates = [civStart,civEnd,nautStart,nautEnd,astroStart,astroEnd].filter(t=>t && t>=t0 && t<t1).sort((a,b)=>a-b);
    const at = candidates[0] || null;
    if (at){
      const toPhase = where(new Date(at.getTime()+1));
      if (toPhase){
        const fromPhase = where(new Date(at.getTime()-1));
        withinChange = { to: toPhase, at, from: fromPhase || null };
      }
    }
  }
  const startedWithinHour = !!(phaseStart && phaseStart>t0 && phaseStart<t1);
  return {
    phase: dominantPhase,
    withinChange,
    sunEvent,
    dbg: null,
    rise,
    set,
    phaseStart,
    startedWithinHour
  };
}

function formatSmallTag(entry){
  if (!entry) return '';
  let text = '';
  let italic = false;
  let prefix = false;
  let preserveCase = false;
  let white = false;
  if (typeof entry === 'string'){ text = entry; }
  else if (typeof entry === 'object' && entry){
    text = entry.text || '';
    italic = !!entry.italic;
    prefix = !!entry.prefix;
    preserveCase = !!entry.preserveCase;
    white = !!entry.white;
  }
  if (!text) return '';
  if (prefix && text.startsWith('...')) prefix = false;
  const classes = [white ? 'miniW' : 'mini'];
  if (italic) classes.push('miniTwilight');
  if (prefix) classes.push('miniPrefixed');
  const cls = classes.join(' ');
  const body = preserveCase ? text : text.toLocaleLowerCase('fi-FI');
  const attrs = [];
  if (entry && entry.dittoEllipsis) attrs.push('data-ditto-ellipsis="1"');
  const attrStr = attrs.length ? ' ' + attrs.join(' ') : '';
  return `<span class="${cls}"${attrStr}>${body}</span>`;
}

function baseSunEventText(at, type){
  if (!(at instanceof Date)) return null;
  const hhmm = fmtHM(at);
  if (!hhmm) return null;
  const mins = at.getMinutes();
  const isRise = type === 'rise';
  if (typeof mins === 'number' && mins < 30){
    return isRise ? `auringonnousu ${hhmm}` : `auringonlasku ${hhmm}`;
  }
  const verb = isRise ? 'Aurinko nousee' : 'Aurinko laskee';
  return `${verb} ${hhmm}.`;
}

function formatSunEventTag(sunEvent){
  if (!sunEvent || !(sunEvent.at instanceof Date)) return null;
  const sentence = baseSunEventText(sunEvent.at, sunEvent.type);
  if (!sentence) return null;
  const minutes = sunEvent.at.getMinutes();
  const beforeMain = Number.isInteger(minutes) && minutes < 30;
  return {
    text: sentence,
    italic: true,
    prefix: false,
    preserveCase: true,
    beforeMain
  };
}

function buildDescriptionHtml({ main, tags, extra }){
  const safeMain = main || '–';
  const tagList = Array.isArray(tags) ? tags : [];
  let extraHtml = extra || '';
  const formattedAfter = [];
  const formattedBefore = [];
  for (const entry of tagList){
    const html = formatSmallTag(entry);
    if (!html) continue;
    const beforeMain = typeof entry === 'object' && entry && entry.beforeMain;
    if (beforeMain) formattedBefore.push(html);
    else formattedAfter.push(html);
  }
  const beforeHtml = formattedBefore.join('<br>');
  const afterHtml = formattedAfter.join('<br>');
  const beforeSection = beforeHtml ? `${beforeHtml}<br>` : '';
  const afterSection = afterHtml ? `<br>${afterHtml}` : '';
  return `${beforeSection}${safeMain}${afterSection}${extraHtml}`;
}

function shouldTintForGold(tw){
  if (!tw || !tw.sunEvent || !(tw.sunEvent.at instanceof Date)) return false;
  const mins = tw.sunEvent.at.getMinutes();
  if (!Number.isInteger(mins)) return false;
  if (tw.sunEvent.type === 'rise'){ return mins < 30; }
  if (tw.sunEvent.type === 'set'){ return mins <= 30; }
  return false;
}

function replaceBlueWithGold(text){
  if (!text || typeof text !== 'string') return text;
  let out = text;
  out = out.replace(/sangen\s+sinistä/gi, match => match[0] === match[0].toUpperCase() ? 'Sangen kultaista' : 'sangen kultaista');
  out = out.replace(/sinistä/gi, match => match[0] === match[0].toUpperCase() ? 'Kultaista' : 'kultaista');
  out = out.replace(/siniharmaa([a-zäöå]*)/gi, (match, tail) => {
    const repl = `kultaharmaa${tail||''}`;
    return match[0] === match[0].toUpperCase() ? repl.charAt(0).toUpperCase() + repl.slice(1) : repl;
  });
  out = out.replace(/sinihirmaa([a-zäöå]*)/gi, (match, tail) => {
    const repl = `kultahirmaa${tail||''}`;
    return match[0] === match[0].toUpperCase() ? repl.charAt(0).toUpperCase() + repl.slice(1) : repl;
  });
  return out;
}

function maybeApplyGoldTint(baseText, tw){
  if (!baseText || typeof baseText !== 'string') return baseText;
  if (!shouldTintForGold(tw)) return baseText;
  if (!/sini/i.test(baseText)) return baseText;
  return replaceBlueWithGold(baseText);
}

function capitalizeDayDescription(text){
  if (!text || typeof text !== 'string') return text;
  if (!text.trim()) return text;
  if (/^\s*</.test(text)) return text;
  const idx = text.search(/[A-Za-zÅÄÖåäö]/);
  if (idx < 0) return text;
  const ch = text[idx];
  const upper = ch.toLocaleUpperCase('fi-FI');
  if (ch === upper) return text;
  return text.slice(0, idx) + upper + text.slice(idx + 1);
}

function descriptorInfoFromOptions(opts){
  if (!opts) return null;
  const { smartSymbolCode, nowcastCode } = opts;
  return smartSymbolInfo(smartSymbolCode) || ncSymbolInfo(nowcastCode) || null;
}

function isWetDescriptor(text, opts = {}){
  const info = descriptorInfoFromOptions(opts);
  if (info && (info.precip || info.fog || info.thunder)) return true;
  if (!text) return false;
  const low = text.toLowerCase();
  return [
    'ripsii', 'satelee', 'kaatosad', 'ränt', 'hiutale', 'pyry', 'rake', 'mist',
    'kuuro', 'ukkos', 'tihkuu', 'sadetta', 'märkä', 'lunta', 'sumu'
  ].some(w => low.includes(w));
}

function isWeakWetDescriptor(text, opts = {}){
  const info = descriptorInfoFromOptions(opts);
  if (info && info.weak) return true;
  if (!text) return false;
  const low = text.toLowerCase();
  return ['tihku', 'kevyt hiutale', 'märkä hiutale'].some(w => low.includes(w));
}

function isDryDescriptor(text, opts = {}){
  const info = descriptorInfoFromOptions(opts);
  if (info && !(info.precip || info.fog || info.thunder)) return true;
  if (!text) return false;
  const low = text.toLowerCase().trim();
  return DRY_TEXTS.has(low);
}

function analyzeFogDescriptor({ text, source }){
  const raw = (typeof text === 'string') ? text.trim() : '';
  if (!raw) return { isFog: false, baseText: raw, displayText: raw };
  const normalized = raw.toLocaleLowerCase('fi-FI');
  if (normalized === 'mist!' || normalized === 'sumua' || normalized === 'sumu'){
    let displayText = 'sumua';
    if (source === 'harmonie') displayText = 'Näkyvyys: mahdollinen';
    else if (source === 'nowcast') displayText = 'Näkyvyys: ei ole';
    return { isFog: true, baseText: 'sumua', displayText };
  }
  return { isFog: false, baseText: raw, displayText: raw };
}

function selectDescription({ nowcastText, harmonieText, expectedNowcast=false }){
  const now = (typeof nowcastText === 'string') ? nowcastText.trim() : '';
  if (now){
    return { text: now, source: 'nowcast', fallbackFromNowcast: false };
  }
  const hrm = (typeof harmonieText === 'string') ? harmonieText.trim() : '';
  if (hrm){
    return { text: hrm, source: 'harmonie', fallbackFromNowcast: !!expectedNowcast };
  }
  return { text: '–', source: 'none', fallbackFromNowcast: false };
}

function buildSourceBadge({ source, expectedNowcast=false, fallbackFromNowcast=false }){
  if (!SHOW_SOURCE_BADGES || !expectedNowcast) return '';
  if (source === 'nowcast'){
    return '<span class="sourceBadge sourceBadgeNc">NC</span>';
  }
  if (source === 'harmonie'){
    const classes = ['sourceBadge', 'sourceBadgeHrm'];
    if (fallbackFromNowcast) classes.push('sourceBadgeFallback');
    return `<span class="${classes.join(' ')}">HRM</span>`;
  }
  return '';
}

function isThunderDescriptor(text, opts = {}){
  const info = descriptorInfoFromOptions(opts);
  if (info && info.thunder) return true;
  if (!text) return false;
  const low = text.toLowerCase();
  return ['ukkos', 'seppo', 'välisuihkut', 'lumiukko'].some(word => low.includes(word));
}

function isHailDescriptor(text, opts = {}){
  const info = descriptorInfoFromOptions(opts);
  if (info && info.hail) return true;
  if (!text) return false;
  return text.toLowerCase().includes('rake');
}

function isThunderOrHailDescriptor(text, opts = {}){
  return isThunderDescriptor(text, opts) || isHailDescriptor(text, opts);
}

function hasPrecipFogOrThunderDescriptor(text, opts = {}){
  if (isWetDescriptor(text, opts)) return true;
  if (isThunderDescriptor(text, opts)) return true;
  const info = descriptorInfoFromOptions(opts);
  return !!(info && info.fog);
}

function ensureQuestionSuffix(text){
  if (text == null) return '?';
  const body = String(text).trim().replace(/[.?!]+$/,'');
  return body ? body + '?' : '?';
}

function wrapItalic(text){
  if (text == null) return text;
  const trimmed = text.trim();
  if (/^<\s*em[>\s]/i.test(trimmed) && /<\/\s*em\s*>$/i.test(trimmed)) return text;
  return `<em>${text}</em>`;
}

function buildThunderTag({ baseText, source, descriptorOpts }){
  if (!isThunderOrHailDescriptor(baseText, descriptorOpts)) return null;
  let text = baseText.trim();
  if (!text || text === '–') return null;
  const fromHarmonie = (source === 'harmonie');
  let italic = false;
  if (fromHarmonie){
    italic = true;
    text = text.replace(/\.+$/,'');
    if (!text.endsWith('?')) text += '?';
  }
  return {
    text,
    italic,
    preserveCase: true,
    white: true
  };
}

function wrapContradiction(descHtml){
  if (!descHtml || descHtml.includes('contradictionMain')) return descHtml;
  const parts = descHtml.split('<br>');
  const main = parts.shift() || '';
  const rest = parts.length ? '<br>' + parts.join('<br>') : '';
  let final = `<span class="contradictionMain">${main}</span>${rest}`;
  if (!final.endsWith('<br>')) final += '<br>';
  final += `<span class="contradictionNote">tai niin ne lupasivat...</span>`;
  return final;
}

function applyContradiction({ descHtml, baseDesc, ssCode, rainVal, rainDisplay }){
  if (!descHtml) return { html: descHtml, flagged: false };
  const base = baseDesc ? baseDesc.trim() : '';
  const hasDesc = base && base !== '–';
  const rainNum = (typeof rainVal === 'number' && !Number.isNaN(rainVal)) ? rainVal : null;
  const rainShown = (typeof rainDisplay === 'number' && !Number.isNaN(rainDisplay)) ? rainDisplay : null;
  const descriptorOpts = { smartSymbolCode: ssCode };
  let strike = false;
  if (rainNum != null && rainNum > 0.3 && isDryDescriptor(base, descriptorOpts)){
    strike = true;
  } else if (hasDesc && rainShown === 0){
    const code = (ssCode != null) ? Number(ssCode) % 100 : null;
    if (code != null && HEAVY_SSCODE.has(code)) strike = true;
  }
  if (!strike) return { html: descHtml, flagged: false };
  return { html: wrapContradiction(descHtml), flagged: true };
}

const twilightState = { lastPhase: null, lastHourStart: null, announced: new Set() };

function resetTwilightState(){
  twilightState.lastPhase = null;
  twilightState.lastHourStart = null;
  twilightState.announced.clear();
}

function allowTwilightAsMain(tw){
  if (!tw || !tw.sunEvent) return true;
  const at = tw.sunEvent.at;
  if (!(at instanceof Date)) return true;
  const minutes = at.getMinutes();
  if (!Number.isFinite(minutes)) return true;
  if (tw.sunEvent.type === 'rise') return minutes >= 30;
  if (tw.sunEvent.type === 'set') return minutes < 30;
  return true;
}

function decorateDescription(baseText, tw, { precipish, hourStart }){
  let tintedMain = baseText;
  let twilightMain = false;
  const tags = [];
  if (!tw) return { main: tintedMain, twilightMain, tags };

  const phaseMain = phaseLabel(tw.phase);
  tintedMain = maybeApplyGoldTint(baseText, tw);
  if (tw.phase === 'day'){
    tintedMain = capitalizeDayDescription(tintedMain);
  }
  let main = tintedMain;

  const twilightMainAllowed = allowTwilightAsMain(tw);

  if (!precipish && phaseMain && twilightMainAllowed){
    main = `<span class="twilightMainText">${phaseMain}</span>`;
    twilightMain = true;
  }

  let startTag = null;
  let startKey = null;
  if (tw.phase && TWILIGHT_PHASES.has(tw.phase) && tw.phaseStart instanceof Date){
    const phaseStart = tw.phaseStart;
    startKey = `${tw.phase}-${phaseStart.getTime()}`;
    if (tw.startedWithinHour){
      startTag = `ALKAA ${fmtHM(phaseStart)}`;
    } else if (
      tw.phase !== twilightState.lastPhase &&
      !twilightState.announced.has(startKey)
    ){
      const prevHourStart = twilightState.lastHourStart;
      if (prevHourStart && phaseStart >= prevHourStart){
        startTag = `(alkoi ${fmtHM(phaseStart)})`;
      }
    }
  }

  if (tw.sunEvent){
    const entry = formatSunEventTag(tw.sunEvent);
    if (entry) tags.push(entry);
  } else if (startTag){
    tags.push({ text: startTag, italic: true, prefix: true });
    if (startKey) twilightState.announced.add(startKey);
  } else if (tw.withinChange){
    const label = precipish ? beginLabel(tw.withinChange.to) : nextLabelFor(tw.withinChange.to);
    const at = tw.withinChange.at;
    const hhmm = at instanceof Date ? fmtHM(at) : null;
    if (label && hhmm){
      const toPhase = tw.withinChange.to;
      const minutes = at.getMinutes();
      const fromPhase = tw.withinChange.from || tw.phase;
      let text = `...${label} ${hhmm}`;
      let dittoEllipsis = false;
      if (toPhase === 'night'){
        text = `säkkipimeä ${hhmm}`;
      } else if (!precipish){
        if (toPhase === 'astronomical' && fromPhase === 'night'){
          text = `astronominen hämärä ${hhmm}`;
        } else if (typeof minutes === 'number' && minutes >= 30){
          const toPhaseIsTwilight = toPhase && TWILIGHT_PHASES.has(toPhase);
          const fromPhaseIsTwilight = fromPhase && TWILIGHT_PHASES.has(fromPhase);
          if (toPhaseIsTwilight && fromPhaseIsTwilight){
            const twilightShortLabels = {
              civil: 'porvarillinen',
              nautical: 'nauttinen',
              astronomical: 'astronominen',
            };
            const shortLabel = twilightShortLabels[toPhase];
            if (shortLabel){
              text = `${shortLabel} ${hhmm}`;
              dittoEllipsis = true;
            }
          }
        }
      }
      const entry = { text, italic: true };
      if (dittoEllipsis) entry.dittoEllipsis = true;
      tags.push(entry);
    } else if (label){
      const base = `...${label} ${fmtHM(tw.withinChange.at)}`;
      const text = tw.withinChange?.to === 'night' ? base.replace(/^\.\.\./, '').trimStart() : base;
      tags.push({ text, italic: true });
    }
    if (
      label &&
      tw.withinChange?.at instanceof Date &&
      typeof tw.withinChange?.to === 'string' &&
      TWILIGHT_PHASES.has(tw.withinChange.to)
    ){
      const key = `${tw.withinChange.to}-${tw.withinChange.at.getTime()}`;
      twilightState.announced.add(key);
    }
  } else if (phaseMain){
    if (precipish || !twilightMain) tags.push({ text: phaseMain, italic: true, prefix: true });
  }

  twilightState.lastPhase = tw.phase || null;
  twilightState.lastHourStart = hourStart || null;

  return { main, twilightMain, tags, twilightLabel: phaseMain || null };
}

function maybeApplyTwilightPrecipOverride({
  decorated,
  rainVal,
  baseDesc,
  descTags,
  tw,
  rowIndex,
  fallbackFromNowcast,
  descSource,
  descriptorOpts
}){
  const result = { applied: false, main: null, tags: null, forceDescWhite: false, forceRainWhite: false };
  if (!decorated || !decorated.twilightMain) return result;
  if (!(Number.isFinite(rainVal) && rainVal > 0)) return result;
  if (!hasPrecipFogOrThunderDescriptor(baseDesc, descriptorOpts)) return result;

  const tags = Array.isArray(descTags) ? [...descTags] : [];
  if (decorated.twilightLabel){
    tags.unshift({ text: decorated.twilightLabel, italic: true, preserveCase: true });
  }

  let main = (typeof baseDesc === 'string') ? baseDesc : '';
  if (main && main !== '–'){
    let tinted = maybeApplyGoldTint(main, tw);
    if (tw && tw.phase === 'day'){
      tinted = capitalizeDayDescription(tinted);
    }
    main = tinted;
  }

  let mainHtml = main || baseDesc || '–';

  const italicizeThunder = (
    rowIndex === 2 &&
    !!fallbackFromNowcast &&
    descSource === 'harmonie' &&
    isThunderOrHailDescriptor(baseDesc, descriptorOpts)
  );
  if (italicizeThunder){
    const body = ensureQuestionSuffix(mainHtml);
    mainHtml = wrapItalic(body);
  }

  result.applied = true;
  result.main = mainHtml;
  result.tags = tags;
  result.forceDescWhite = true;
  result.forceRainWhite = true;
  return result;
}

function computeHighlightStates({ rowIndex, rainVal, descWet, descWeak }){
  const rainWhite = (rainVal!=null && rainVal>0 && !(rowIndex>=3 && descWeak && rainVal<0.3));
  let descWhite = false;
  if (rowIndex < 3){
    if (rainWhite) descWhite = true;
    else if (descWet && !descWeak) descWhite = true;
  } else if (descWet){
    if (!descWeak) descWhite = true;
    else if (rainVal!=null && rainVal>=0.3) descWhite = true;
  }
  if (rainVal === 0) descWhite = false;
  return { rainWhite, descWhite };
}

/* --------- solut --------- */
function rainCell(val, {markGrey=false}={}){
  if (val==null || isNaN(Number(val))) return { text:'–', num:null, extraClass:'', forceGrey:true };
  const n = Number(val);
  if (n === 0) return { text:'—', num:0, extraClass:'dash', forceGrey:true };
  return { text:n.toFixed(1)+' mm', num:n, extraClass:'', forceGrey:markGrey };
}
function formatWindSpeed(val){
  if (!Number.isFinite(val)) return null;
  const rounded = Math.round(val);
  return (Object.is(rounded, -0) ? 0 : rounded).toString();
}

function windCell(mean, gust, dirDeg){
  const mOk = (mean!=null && !isNaN(Number(mean)));
  const gOk = (gust!=null && !isNaN(Number(gust)));
  const meanV = mOk ? Number(mean) : null;
  const gustV = gOk ? Number(gust) : null;

  const meanTxt = formatWindSpeed(meanV);
  let txt = (mOk && meanTxt!=null ? meanTxt+' m/s' : '–');

  let gustTxt = '';
  let highlight = false;
  if (gOk && gustV >= 15){
    const gustFmt = formatWindSpeed(gustV);
    if (gustFmt != null){
      gustTxt = ` (<em style="color:#e8e8e8">${gustFmt}</em>)`;
    }
    highlight = true;
  }
  if (mOk && meanV >= 10) highlight = true;

  const dirTxt = dir8(dirDeg);
  const dirHtml = dirTxt ? `<span class="${highlight ? 'miniW' : 'mini'} windDir">${dirTxt}</span>` : '';

  return { html: txt + gustTxt + dirHtml, white: highlight };
}

/* Ditto */
function normalizedDittoKey(s){
  return s.toLowerCase().replace(/<[^>]*>/g,'').replace(/[()[\]{}?.,]/g,'').replace(/\s+/g,' ').trim();
}
function renderRow(row, state){
  const {
    timeHtml,
    temp,
    descHtml,
    descMainHtml,
    descWhite,
    rainObj,
    rainWhite,
    windObj,
    windWhite,
    twDbg,
    rainTag,
    timeWhite = false,
    tempWhite = false,
    skipDitto = false
  } = row || {};
  const rain = rainObj || { text: '–', num: null, extraClass: '', forceGrey: false };
  const wind = windObj || { html: '–', white: false };
  const mainHtml = descMainHtml || descHtml || '–';
  const plain = mainHtml.replace(/<[^>]*>/g,'').trim();
  const normalized = plain ? normalizedDittoKey(plain) : '';
  let displayDesc = (typeof descHtml === 'string' && descHtml.length) ? descHtml : mainHtml;
  if (!skipDitto && normalized && state.prevDescKey && normalized === state.prevDescKey){
    let tailHtml = '';
    if (typeof descHtml === 'string' && descHtml.length){
      if (descHtml.startsWith(mainHtml)){
        tailHtml = descHtml.slice(mainHtml.length);
      } else {
        const idx = descHtml.indexOf(mainHtml);
        if (idx >= 0){
          tailHtml = descHtml.slice(idx + mainHtml.length);
        }
      }
    }
    if (tailHtml){
      tailHtml = tailHtml.replace(/(<span[^>]*data-ditto-ellipsis=\"1\"[^>]*>)(\s*)(?!\.\.\.)([^<]*)/gi, (match, open, ws, text) => {
        const trimmed = text || '';
        if (trimmed.startsWith('...')) return open + ws + trimmed;
        return open + ws + '...' + trimmed;
      });
    }
    displayDesc = '<span class="ditto" title="sama kuin edellä">&raquo;</span>' + (tailHtml || '');
  } else {
    state.prevDescKey = normalized || null;
  }
  const rainTagHtml = (rain.text === '—') ? '' : tag(rainTag || '');
  const twTag = DBG && twDbg ? ` <span class="soft" style="font-size:12px">${twDbg}</span>` : '';
  const descClasses = ['desc'];
  if (descWhite) descClasses.push('descWhite'); else descClasses.push('soft');
  const timeClasses = ['cell'];
  if (!timeWhite) timeClasses.push('soft');
  const tempClasses = ['cell','hh'];
  if (!tempWhite) tempClasses.push('soft');
  const rainClasses = ['cell'];
  if (!rainWhite || rain.forceGrey) rainClasses.push('soft');
  if (rain.extraClass) rainClasses.push(rain.extraClass);
  const windClasses = ['cell'];
  if (!windWhite) windClasses.push('soft');
  return (
    `<div class="row">`+
      `<div class="${timeClasses.join(' ')}">${timeHtml || '–'}</div>`+
      `<div class="${tempClasses.join(' ')}">${(temp!=null && !Number.isNaN(temp))?Math.round(temp)+'°':'–'}</div>`+
      `<div class="${descClasses.join(' ')}">${displayDesc}${twTag}</div>`+
      `<div class="${rainClasses.join(' ')}">${rain.text}${rainTagHtml}</div>`+
      `<div class="${windClasses.join(' ')}">${wind.html}</div>`+
    `</div>`
  );
}

function createHourlyRowModel({ hour, index, nowcast, twilightResolver, launchTime }){
  if (!hour || !(hour.time instanceof Date) || Number.isNaN(hour.time.getTime())) return null;
  const dUtc = new Date(hour.time);
  const isNowcastHour = index <= 2;
  const expectedNowcast = isNowcastHour;
  const smartSymbolCode = hour.smartSymbol;
  const nowcastCode = isNowcastHour ? nowcast?.sym : null;
  const descriptorOpts = { smartSymbolCode, nowcastCode };
  let rainTag = isNowcastHour ? nowcastMetaTag(nowcast?.meta) : 'HRM';
  let rainVal = null;
  let rainObj = null;
  if (isNowcastHour && nowcast && typeof nowcast.val === 'number'){
    rainVal = nowcast.val < 0.1 ? 0 : nowcast.val;
    rainObj = rainCell(rainVal);
  } else {
    const hrmVal = (typeof hour.precipitation === 'number') ? hour.precipitation : null;
    rainVal = hrmVal;
    if (!isNowcastHour){
      const wet = (rainVal != null && rainVal > 0);
      const smallWet = (wet && rainVal < 0.3);
      const ssDay = (smartSymbolCode != null) ? (Number(smartSymbolCode) % 100) : null;
      const useGreyRain = smallWet && (ssDay == null || !SMALL_RAIN_EXCEPT.has(ssDay));
      rainObj = rainCell(rainVal, { markGrey: useGreyRain });
    } else {
      rainObj = rainCell(rainVal, { markGrey: index >= 3 });
      rainTag = 'HRM';
    }
  }
  if (!rainObj) rainObj = rainCell(rainVal);
  const gust = (index === 0 && nowcast && typeof nowcast.gust === 'number') ? nowcast.gust : null;
  const windObj = windCell(hour.windSpeed, gust, hour.windDirection);
  const descSelection = selectDescription({
    nowcastText: isNowcastHour ? ncSymbolText(nowcast?.sym) : null,
    harmonieText: ssText(hour.smartSymbol),
    expectedNowcast
  });
  const fogInfo = analyzeFogDescriptor({ text: descSelection.text, source: descSelection.source });
  const baseDesc = fogInfo.baseText || descSelection.text || '–';
  const descSource = descSelection.source;
  const fallbackFromNowcast = descSelection.fallbackFromNowcast;
  const descWet = isWetDescriptor(baseDesc, descriptorOpts);
  const descWeak = isWeakWetDescriptor(baseDesc, descriptorOpts);
  let precipish;
  if (isNowcastHour){
    precipish = ((rainVal != null && rainVal >= 0.1) || (nowcastCode && ncIsPrecip(nowcastCode)) || descWet);
  } else {
    const wet = (rainVal != null && rainVal > 0);
    precipish = wet || descWet;
  }
  let descMain = baseDesc || '–';
  let descTags = [];
  let descExtra = '';
  let twDbg = '';
  let insertedThunderTag = false;
  let twilightFlags = { hadTwilightMain: false, overrideApplied: false };
  let twilightOverride = { applied: false, forceDescWhite: false, forceRainWhite: false };
  try{
    const tw = typeof twilightResolver === 'function' ? twilightResolver(new Date(dUtc)) : null;
    const decorated = decorateDescription(baseDesc, tw, { precipish, hourStart: dUtc });
    twilightFlags.hadTwilightMain = !!decorated.twilightMain;
    descMain = decorated.main || baseDesc || '–';
    descTags = Array.isArray(decorated.tags) ? [...decorated.tags] : [];
    let thunderTag = null;
    if (decorated.twilightMain){
      thunderTag = buildThunderTag({ baseText: baseDesc, source: descSource, descriptorOpts });
    }
    const override = maybeApplyTwilightPrecipOverride({
      decorated,
      rainVal,
      baseDesc,
      descTags,
      tw,
      rowIndex: index,
      fallbackFromNowcast,
      descSource,
      descriptorOpts
    });
    twilightOverride = override;
    if (override.applied){
      twilightFlags.overrideApplied = true;
      descMain = override.main;
      descTags = Array.isArray(override.tags) ? override.tags : [];
    } else if (thunderTag){
      descTags.unshift(thunderTag);
      insertedThunderTag = true;
    }
    if (DBG){
      if (tw?.dbg) twDbg = `[TW ${tw.dbg}]`;
      else if (tw){
        const p = tw.phase || 'n/a';
        if (tw.sunEvent) twDbg = `[TW ${p} | ${tw.sunEvent.type === 'set' ? 'set' : 'rise'} ${fmtHM(tw.sunEvent.at)}]`;
        else if (tw.withinChange) twDbg = `[TW ${p} | change→${tw.withinChange.to} ${fmtHM(tw.withinChange.at)}]`;
        else twDbg = `[TW ${p}]`;
      }
    }
  }catch{
    if (DBG) twDbg = '[TW!err]';
  }
  if (fogInfo.isFog){
    descMain = fogInfo.displayText;
  }
  if (DBG && isNowcastHour){
    const isNcTag = rainTag.startsWith('NC');
    const tagText = (isNcTag && nowcast?.sym && !ncIsPrecip(nowcast.sym)) ? `[${ncBase(nowcast.sym)}]` : `[${rainTag}]`;
    descExtra += ` <span class="soft" style="font-size:12px">${tagText}</span>`;
    if (nowcast?.meta && nowcast.meta !== 'NC'){
      descExtra += ` <span class="soft" style="font-size:12px">[${nowcast.meta}]</span>`;
    }
    if (twDbg && !twDbg.startsWith('[TW!err]')){
      descExtra += ` <span class="soft" style="font-size:12px">${twDbg}</span>`;
      twDbg = '';
    }
  }
  const sourceBadge = buildSourceBadge({
    source: descSource,
    expectedNowcast,
    fallbackFromNowcast
  });
  if (sourceBadge){
    descExtra += ` ${sourceBadge}`;
  }
  const highlight = computeHighlightStates({
    rowIndex: index,
    rainVal,
    descWet,
    descWeak
  });
  let { rainWhite, descWhite } = highlight;
  if (twilightOverride.applied){
    if (twilightOverride.forceRainWhite) rainWhite = true;
    if (twilightOverride.forceDescWhite) descWhite = true;
    if (rainObj.forceGrey) rainObj.forceGrey = false;
  }
  if (!twilightFlags.overrideApplied && twilightFlags.hadTwilightMain){
    descWhite = false;
  }
  if (insertedThunderTag) descWhite = false;
  const timeWhite = (rainWhite || descWhite || windObj.white);
  const initialDescHtml = buildDescriptionHtml({ main: descMain, tags: descTags, extra: descExtra });
  const contradiction = applyContradiction({
    descHtml: initialDescHtml,
    baseDesc,
    ssCode: hour.smartSymbol,
    rainVal,
    rainDisplay: rainObj.num
  });
  const finalDescHtml = (contradiction && typeof contradiction.html === 'string')
    ? contradiction.html
    : initialDescHtml;
  let timeHtml;
  if (index === 0){
    const launch = (launchTime instanceof Date && !Number.isNaN(launchTime.getTime())) ? launchTime : null;
    const displayTime = launch || dUtc;
    timeHtml = fmtHM(displayTime);
  } else {
    const timeClass = timeWhite ? 'miniW' : 'mini';
    timeHtml = `<span class="${timeClass}">klo&nbsp;</span>${fmtH(dUtc)}`;
  }
  return {
    key: hour.key,
    time: dUtc,
    timeHtml,
    timeWhite,
    temp: hour.temperature,
    tempWhite: false,
    descHtml: finalDescHtml,
    descMainHtml: descMain,
    descWhite,
    rainObj,
    rainWhite,
    rainTag,
    windObj,
    windWhite: windObj.white,
    twDbg,
    skipDitto: !!(contradiction && contradiction.flagged)
  };
}

function buildHourlyModel({ hours, nowcasts, sunPhases, launchTime }){
  if (!Array.isArray(hours) || !hours.length) return { rows: [] };
  resetTwilightState();
  const nowcastMap = nowcasts instanceof Map ? nowcasts : new Map();
  const sunMap = sunPhases instanceof Map ? sunPhases : new Map();
  const rows = [];
  const resolver = (date) => {
    const key = dateKeyForZone(date, TZ) || (
      Number.isFinite(date.getFullYear())
        ? `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}`
        : null
    );
    const dayObj = key ? (sunMap.get(key) || sunMap.get(String(key)) || null) : null;
    return analyzeTwilightForHour(date, dayObj);
  };
  hours.forEach((hour, index) => {
    const nowcast = nowcastMap.get(hour.key) || nowcastMap.get(hour.time?.toISOString()) || null;
    const row = createHourlyRowModel({ hour, index, nowcast, twilightResolver: resolver, launchTime });
    if (row) rows.push(row);
  });
  return { rows };
}

function renderHourlyModel(model){
  const rows = model?.rows || [];
  if (!rows.length){
    out.innerHTML = `<div class="muted">Ei rivejä tälle ikkunalle.</div>`;
    return;
  }
  const state = { prevDescKey: null };
  const html = rows.map(row => renderRow(row, state));
  out.innerHTML = html.join('');
}

/* --------- render --------- */
(async function(){
  scrollTo(0,1); setTimeout(()=>scrollTo(0,1),150);
  if (LAT_STR == null || LON_STR == null || !Number.isFinite(LAT) || !Number.isFinite(LON)){
    out.innerHTML = `<div class="err">Puuttuvat tai virheelliset koordinaatit. Käytä:<br><code>?lat=60.1699&lon=24.9384</code></div>`;
    return;
  }

  out.innerHTML = '<div class="muted">Ladataan säätietoja…</div>';

  try{
    const forecastData = await fetchForecast(LAT, LON);
    const now = new Date();
    const thisHourLocal = new Date(new Date(now).setMinutes(0,0,0));
    const upcoming = forecastData.hours.filter(hour => {
      const time = hour?.time instanceof Date ? hour.time : new Date(hour?.key || hour);
      return time instanceof Date && !Number.isNaN(time.getTime()) && time >= thisHourLocal;
    }).slice(0, 13);

    if (!upcoming.length){
      out.innerHTML = `<div class="muted">Ei rivejä tälle ikkunalle.</div>`;
      return;
    }

    const nowcastTargets = upcoming.slice(0, 3);
    const [nowcasts, sunPhases] = await Promise.all([
      fetchNowcasts(LAT, LON, nowcastTargets),
      fetchSunPhases(LAT, LON, upcoming)
    ]);

    const model = buildHourlyModel({ hours: upcoming, nowcasts, sunPhases, launchTime: now });
    renderHourlyModel(model);
  }catch(e){
    const msg = (e && e.message) ? e.message : String(e);
    out.innerHTML = `<div class="err">${msg}</div>`;
  }
})();
</script>

</body>
</html>
